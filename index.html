<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>micro:bit Remote</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/interact.js/1.10.27/interact.min.js">
document.addEventListener('click', (e)=>{
  const btn = e.target && e.target.closest ? e.target.closest('[data-tab]') : null;
  if (!btn) return;
  const tab = btn.getAttribute('data-tab');
  try{ updateToolbarForMode(tab); }catch(e){}
});

</script>
<link rel="stylesheet" href="style.css">
<style>
:root {
  --bg: #1a1a2e;
  --surface: #16213e;
  --card: #1f3460;
  --accent: #00d4ff;
  --pink: #ff6b9d;
  --green: #00e676;
  --orange: #ff9100;
  --purple: #b388ff;
  --red: #ff5252;
  --yellow: #ffea00;
  --text: #ffffff;
  --text-dim: #8892b0;
}

* { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; overflow: hidden; touch-action: manipulation; font-family: 'Segoe UI', system-ui, sans-serif; }
body { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: var(--text); }

.app { display: flex; flex-direction: column; height: 100dvh; }

/* Header */
header {
  display: flex; align-items: center; gap: 10px;
  padding: 8px 12px; background: rgba(22,33,62,0.95);
  border-bottom: 2px solid var(--card);
}
.logo { font-size: 1.3rem; font-weight: 800; }
.logo span { background: linear-gradient(90deg, var(--accent), var(--pink)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.spacer { flex: 1; }

.tabs { display: flex; background: var(--card); border-radius: 30px; padding: 4px; }
.tab {
  padding: 10px 20px; border: none; background: none;
  color: var(--text-dim); font-weight: 700; font-size: 0.9rem;
  border-radius: 30px; cursor: pointer; transition: 0.2s;
}
.tab.active { background: linear-gradient(135deg, var(--accent), var(--purple)); color: #000; }

.ble-btn {
  display: flex; align-items: center; gap: 8px;
  padding: 10px 16px; border-radius: 30px;
  background: var(--card); border: 2px solid var(--red);
  color: var(--red); font-weight: 700; cursor: pointer;
}
.ble-btn.connected { border-color: var(--green); color: var(--green); }
.ble-dot { width: 12px; height: 12px; border-radius: 50%; background: currentColor; }

/* Main Content */
main { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
.view { display: none; flex-direction: column; height: 100%; }
.view.active { display: flex; }

/* Builder View */
.builder-header {
  display: flex; align-items: center; gap: 8px;
  padding: 10px 12px; background: var(--surface);
  flex-wrap: wrap;
}
.title-input {
  flex: 1; min-width: 200px; padding: 12px 16px;
  background: var(--card); border: 2px solid transparent;
  border-radius: 16px; color: var(--text); font-size: 1rem; font-weight: 600;
}
.title-input:focus { outline: none; border-color: var(--accent); }
.header-btn {
  padding: 12px 20px; border: none; border-radius: 16px;
  font-weight: 700; font-size: 0.85rem; cursor: pointer; transition: 0.2s;
  display: flex; align-items: center; gap: 6px;
}
.header-btn:hover { transform: scale(1.05); }
.btn-demo { background: linear-gradient(135deg, var(--yellow), var(--orange)); color: #000; }
.btn-code { background: linear-gradient(135deg, var(--accent), var(--purple)); color: #000; }
.btn-template { background: linear-gradient(135deg, var(--pink), var(--purple)); color: #fff; }
.btn-delete { background: var(--red); color: #fff; }

/* Builder layout */
.builder-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 12px;
  min-height: 0;
}
.builder-side {
  display: flex;
  flex-direction: column;
  gap: 12px;
  min-height: 0;
  overflow-y: auto;
}
.builder-header:empty { display: none; }
.builder-view .canvas { max-width: 100%; }
.canvas-wrap { min-width: 0; }

/* Collapsible cards */
.palette-card,
.collapsible-card {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding: 10px;
  background: var(--surface);
  border: 2px solid var(--card);
  border-radius: 18px;
  min-height: 0;
}
.palette-card-toggle,
.collapsible-card-toggle {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  padding: 10px 12px;
  border: 2px solid transparent;
  border-radius: 14px;
  background: var(--card);
  color: var(--text);
  font-weight: 800;
  font-size: 0.85rem;
  min-height: 44px;
  cursor: pointer;
  transition: 0.2s;
}
.palette-card-toggle:hover,
.collapsible-card-toggle:hover { border-color: var(--accent); }
.palette-card-title,
.collapsible-card-title { display: flex; align-items: center; gap: 6px; }
.palette-card-chevron,
.collapsible-card-chevron { transition: transform 0.2s ease; }
.palette-card.collapsed .palette-card-body,
.collapsible-card.collapsed .collapsible-card-body { display: none; }
.palette-card.collapsed .palette-card-chevron,
.collapsible-card.collapsed .collapsible-card-chevron { transform: rotate(-90deg); }
.palette-card-body,
.collapsible-card-body { min-height: 0; overflow-y: auto; max-height: clamp(200px, 45vh, 560px); -webkit-overflow-scrolling: touch; }

/* Palette - Bottom on mobile */
.palette {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 8px;
  padding: 2px;
  background: transparent;
  border: none;
}
.palette-item {
  display: flex; flex-direction: column;
  align-items: center; gap: 6px; padding: 12px 16px;
  background: var(--card); border: 3px solid transparent;
  border-radius: 16px; cursor: pointer; transition: 0.2s;
  width: 100%;
  min-width: 0;
}
.palette-item:hover, .palette-item.selected { border-color: var(--accent); transform: scale(1.05); }
.palette-item.selected { background: linear-gradient(135deg, var(--accent), var(--purple)); }
.palette-item.selected .palette-name { color: #000; }
.palette-icon { font-size: 28px; }
.palette-name { font-size: 0.7rem; font-weight: 700; color: var(--text-dim); text-transform: uppercase; }

/* Canvas */
.canvas-wrap { flex: 1; padding: 10px; overflow: hidden; order: 1; display: flex; flex-direction: column; }
.canvas-hint { text-align: center; padding: 8px; color: var(--text-dim); font-size: 0.85rem; }
.canvas-hint span { color: var(--accent); font-weight: 700; }
.canvas {
  flex: 1; position: relative; background: var(--card);
  border: 3px dashed var(--text-dim); border-radius: 20px;
  overflow: hidden; min-height: 300px; max-height: 500px;
  width: 100%; max-width: 550px;
}
#widgetsLayer { position: absolute; inset: 0; overflow: visible; }

.widget {
  position: absolute; background: var(--surface);
  border: 3px solid var(--text-dim); border-radius: 16px;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  cursor: move; touch-action: none; user-select: none; gap: 4px; padding: 8px;
  min-width: 50px; min-height: 50px;
}
.widget.selected { border-color: var(--accent); box-shadow: 0 0 30px rgba(0,212,255,0.5); }
.widget-icon { font-size: 2rem; pointer-events: none; }
.widget-label { font-size: 0.75rem; font-weight: 700; color: var(--text-dim); pointer-events: none; }

/* Resize handles - all edges */
.widget .resize-handle {
  position: absolute;
  background: var(--accent);
  opacity: 0;
  transition: opacity 0.2s;
}
.widget.selected .resize-handle,
.widget:hover .resize-handle { opacity: 1; }

.widget .resize-handle.handle-se {
  bottom: -3px; right: -3px;
  width: 20px; height: 20px;
  cursor: se-resize;
  border-radius: 0 0 12px 0;
  clip-path: polygon(100% 0, 100% 100%, 0 100%);
}
.widget .resize-handle.handle-sw {
  bottom: -3px; left: -3px;
  width: 20px; height: 20px;
  cursor: sw-resize;
  border-radius: 0 0 0 12px;
  clip-path: polygon(0 0, 100% 100%, 0 100%);
}
.widget .resize-handle.handle-ne {
  top: -3px; right: -3px;
  width: 20px; height: 20px;
  cursor: ne-resize;
  border-radius: 0 12px 0 0;
  clip-path: polygon(0 0, 100% 0, 100% 100%);
}
.widget .resize-handle.handle-nw {
  top: -3px; left: -3px;
  width: 20px; height: 20px;
  cursor: nw-resize;
  border-radius: 12px 0 0 0;
  clip-path: polygon(0 0, 100% 0, 0 100%);
}
.widget .resize-handle.handle-n {
  top: -4px; left: 50%; transform: translateX(-50%);
  width: 30px; height: 8px;
  cursor: n-resize;
  border-radius: 4px;
}
.widget .resize-handle.handle-s {
  bottom: -4px; left: 50%; transform: translateX(-50%);
  width: 30px; height: 8px;
  cursor: s-resize;
  border-radius: 4px;
}
.widget .resize-handle.handle-e {
  right: -4px; top: 50%; transform: translateY(-50%);
  width: 8px; height: 30px;
  cursor: e-resize;
  border-radius: 4px;
}
.widget .resize-handle.handle-w {
  left: -4px; top: 50%; transform: translateY(-50%);
  width: 8px; height: 30px;
  cursor: w-resize;
  border-radius: 4px;
}

.widget .widget-orient-badge {
  position: absolute;
  top: 4px;
  right: 4px;
  background: rgba(0,212,255,0.3);
  color: var(--accent);
  font-size: 0.7rem;
  font-weight: 900;
  padding: 2px 6px;
  border-radius: 8px;
  pointer-events: none;
}

/* Runtime View */
/* Runtime View - only shows when .active class is present */
.runtime-view { 
  flex-direction: column;
  align-items: center; 
  justify-content: flex-start; 
  padding: 20px; 
  padding-top: 70px; 
  position: relative;
  min-height: calc(100vh - 60px);
}
/* Ensure runtime view is hidden when not active */
.runtime-view:not(.active) {
  display: none !important;
}
.back-to-build-btn {
  position: absolute;
  top: 12px;
  left: 12px;
  padding: 12px 20px;
  border: none;
  border-radius: 30px;
  background: linear-gradient(135deg, var(--accent), var(--purple));
  color: #000;
  font-size: 0.95rem;
  font-weight: 800;
  cursor: pointer;
  transition: all 0.2s ease;
  z-index: 10;
  box-shadow: 0 4px 15px rgba(0,212,255,0.3);
}
.back-to-build-btn:hover {
  transform: scale(1.05);
  box-shadow: 0 6px 20px rgba(0,212,255,0.4);
}
.back-to-build-btn:active {
  transform: scale(0.95);
}

/* Arrange Mode Button */
/* Runtime top buttons container */
.runtime-top-btns {
  position: fixed;
  top: 12px;
  right: 12px;
  display: flex;
  flex-direction: row;
  gap: 8px;
  z-index: 9999;
  pointer-events: none;
}
.runtime-top-btns > * {
  pointer-events: auto;
}
.arrange-mode-btn {
  position: static;
  padding: 8px 14px;
  border: none;
  border-radius: 20px;
  background: var(--card);
  color: var(--text);
  font-size: 0.8rem;
  font-weight: 800;
  cursor: pointer;
  transition: all 0.2s ease;
  border: 2px solid var(--text-dim);
  display: none;
}
.arrange-mode-btn.visible {
  display: block;
}
.arrange-mode-btn:hover {
  background: var(--surface);
  border-color: var(--accent);
}
.arrange-mode-btn.active {
  background: linear-gradient(135deg, var(--orange), var(--yellow));
  color: #000;
  border-color: transparent;
  box-shadow: 0 4px 15px rgba(255,145,0,0.4);
}
.arrange-mode-btn.active:hover {
  transform: scale(1.05);
}

/* Arrange Hint */
.arrange-hint {
  background: linear-gradient(135deg, rgba(255,145,0,0.2), rgba(255,234,0,0.2));
  border: 2px solid var(--orange);
  border-radius: 12px;
  padding: 10px 16px;
  margin-bottom: 12px;
  font-size: 0.9rem;
  font-weight: 700;
  color: var(--yellow);
  text-align: center;
  animation: pulse-hint 2s ease-in-out infinite;
}
@keyframes pulse-hint {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

/* Runtime grid in arrange mode */
#runtimeGrid.arrange-mode {
  border: 3px dashed var(--orange) !important;
  background-image: linear-gradient(rgba(255,145,0,0.05) 1px, transparent 1px), 
                    linear-gradient(90deg, rgba(255,145,0,0.05) 1px, transparent 1px);
  background-size: 20px 20px;
}

/* Runtime widgets in arrange mode */
#runtimeGrid.arrange-mode .rt-widget {
  cursor: move !important;
  border: 2px dashed var(--orange);
  border-radius: 12px;
  transition: box-shadow 0.2s, border-color 0.2s;
}
#runtimeGrid.arrange-mode .rt-widget:hover {
  border-color: var(--yellow);
  box-shadow: 0 0 20px rgba(255,145,0,0.4);
}
#runtimeGrid.arrange-mode .rt-widget.dragging {
  opacity: 0.8;
  z-index: 1000 !important;
  box-shadow: 0 10px 40px rgba(0,0,0,0.4), 0 0 30px rgba(255,145,0,0.5);
  border-color: var(--yellow);
}
#runtimeGrid.arrange-mode .rt-widget * {
  pointer-events: none !important;
}

/* Resize handle for runtime widgets in arrange mode */
#runtimeGrid.arrange-mode .rt-widget .rt-resize-handle {
  display: block;
  position: absolute;
  bottom: 0;
  right: 0;
  width: 20px;
  height: 20px;
  cursor: se-resize;
  background: var(--orange);
  border-radius: 0 0 10px 0;
  clip-path: polygon(100% 0, 100% 100%, 0 100%);
  pointer-events: auto !important;
}

/* Canvas/Grid resize handle in arrange mode */
#runtimeGrid.arrange-mode .canvas-resize-handle {
  position: absolute;
  bottom: -5px;
  right: -5px;
  width: 30px;
  height: 30px;
  cursor: nwse-resize;
  background: linear-gradient(135deg, var(--accent), var(--purple));
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #000;
  font-size: 14px;
  font-weight: bold;
  box-shadow: 0 4px 15px rgba(0,212,255,0.4);
  z-index: 100;
  transition: transform 0.2s;
}
#runtimeGrid.arrange-mode .canvas-resize-handle:hover {
  transform: scale(1.1);
}
#runtimeGrid.arrange-mode .canvas-resize-handle::after {
  content: 'â¤¡';
}

/* Zoom Controls */
.zoom-controls {
  position: fixed;
  bottom: 60px;
  right: 20px;
  display: flex;
  flex-direction: column;
  gap: 5px;
  z-index: 10000;
  background: rgba(0,0,0,0.85);
  padding: 6px;
  border-radius: 14px;
  backdrop-filter: blur(10px);
  border: 2px solid var(--accent);
  pointer-events: auto;
}
.zoom-btn {
  width: 38px;
  height: 38px;
  border: none;
  border-radius: 10px;
  background: var(--card);
  color: var(--text);
  font-size: 1.1rem;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
}
.zoom-btn:hover { background: var(--accent); color: #000; transform: scale(1.1); }
.zoom-btn:active { transform: scale(0.95); }
.zoom-level {
  text-align: center;
  font-size: 0.65rem;
  font-weight: 700;
  color: var(--text-dim);
  padding: 2px;
  background: rgba(0,0,0,0.3);
  border-radius: 6px;
}

/* App viewport scaling */
html {
  overflow-x: auto;
  overflow-y: auto;
}
body.scaled {
  overflow: auto;
}
.app-scaler {
  transform-origin: top left;
  transition: transform 0.15s ease;
}

/* Canvas size badge in arrange mode */
.runtime-size-badge {
  position: absolute;
  bottom: 10px;
  left: 10px;
  padding: 6px 12px;
  background: rgba(0,0,0,0.6);
  border-radius: 20px;
  font-size: 0.75rem;
  font-weight: 700;
  color: var(--text-dim);
  z-index: 100;
  display: none;
}
#runtimeGrid.arrange-mode .runtime-size-badge {
  display: block;
}

/* === FULLSCREEN MODE === */
.fullscreen-btn {
  position: static;
  padding: 8px 14px;
  border: none;
  border-radius: 20px;
  background: var(--card);
  color: var(--text);
  font-size: 0.8rem;
  font-weight: 700;
  cursor: pointer;
  border: 2px solid var(--text-dim);
  display: none;
  transition: all 0.2s;
}
.fullscreen-btn.visible { display: block; }
.fullscreen-btn:hover { border-color: var(--accent); background: var(--surface); }

body.runtime-fullscreen {
  overflow: hidden !important;
  background: #0a0a0a !important;
}
body.runtime-fullscreen .app {
  transform: none !important;
}
body.runtime-fullscreen .app > header,
body.runtime-fullscreen .back-to-build-btn,
body.runtime-fullscreen .arrange-mode-btn,
body.runtime-fullscreen #arrangeHint,
body.runtime-fullscreen .fullscreen-btn,
body.runtime-fullscreen .builder-view,
body.runtime-fullscreen #connectPrompt {
  display: none !important;
}
body.runtime-fullscreen main {
  position: fixed !important;
  inset: 0 !important;
  overflow: hidden !important;
}
body.runtime-fullscreen .runtime-view.active {
  position: fixed !important;
  inset: 0 !important;
  width: 100vw !important;
  height: 100vh !important;
  padding: 60px 20px 20px 20px !important;
  margin: 0 !important;
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  justify-content: center !important;
  background: #0a0a0a !important;
  z-index: 9998 !important;
}
body.runtime-fullscreen #runtimeContent {
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  justify-content: center !important;
  width: 100% !important;
  height: 100% !important;
  min-height: auto !important;
}
body.runtime-fullscreen #runtimeTitle {
  position: fixed !important;
  top: 15px !important;
  left: 50% !important;
  transform: translateX(-50%) !important;
  z-index: 10000 !important;
  background: rgba(0,0,0,0.8) !important;
  padding: 10px 25px !important;
  border-radius: 25px !important;
  margin: 0 !important;
}
body.runtime-fullscreen #runtimeGrid {
  max-width: 95vw !important;
  max-height: calc(100vh - 20px) !important;
  margin: 0 auto !important;
  border: 3px solid var(--accent) !important;
  transform-origin: center center !important;
}
body.runtime-fullscreen .fullscreen-exit-btn {
  display: flex !important;
  z-index: 10001 !important;
}
/* Show zoom controls in fullscreen */
body.runtime-fullscreen .zoom-controls {
  display: flex !important;
  position: fixed !important;
  bottom: 20px !important;
  right: 20px !important;
  z-index: 10001 !important;
}
/* Add fullscreen scale button */
body.runtime-fullscreen .zoom-controls .zoom-fit-btn {
  background: var(--accent) !important;
  color: #000 !important;
}
.fullscreen-exit-btn {
  display: none;
  position: fixed;
  top: 15px;
  right: 15px;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: rgba(255,82,82,0.85);
  border: 2px solid rgba(255,255,255,0.3);
  color: #fff;
  font-size: 1.5rem;
  font-weight: 900;
  cursor: pointer;
  z-index: 10001;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(10px);
  transition: all 0.2s ease;
  box-shadow: 0 4px 15px rgba(255,82,82,0.5);
}
.fullscreen-exit-btn:hover {
  background: rgba(255,82,82,1);
  transform: scale(1.1);
  box-shadow: 0 6px 20px rgba(255,82,82,0.7);
}
.fullscreen-exit-btn:active {
  transform: scale(0.95);
}

/* === UNDO/REDO BUTTONS === */
.history-buttons {
  display: flex;
  gap: 4px;
  margin-right: 8px;
}
.history-btn {
  width: 38px;
  height: 38px;
  border: none;
  border-radius: 12px;
  background: var(--card);
  color: var(--text);
  font-size: 1.1rem;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
}
.history-btn:hover:not(:disabled) {
  background: var(--accent);
  color: #000;
}
.history-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

/* === QUICK ACTIONS MENU (long-press) === */
.quick-actions-menu {
  position: fixed;
  background: rgba(20,30,50,0.95);
  border: 2px solid var(--accent);
  border-radius: 16px;
  padding: 8px;
  z-index: 1000;
  display: none;
  flex-direction: column;
  gap: 4px;
  min-width: 140px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.5), 0 0 30px rgba(0,212,255,0.2);
  backdrop-filter: blur(20px);
  animation: popIn 0.15s ease-out;
}
.quick-actions-menu.show { display: flex; }
@keyframes popIn {
  from { opacity: 0; transform: scale(0.8); }
  to { opacity: 1; transform: scale(1); }
}
.quick-action-btn {
  padding: 10px 14px;
  border: none;
  border-radius: 10px;
  background: transparent;
  color: var(--text);
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  text-align: left;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  gap: 8px;
}
.quick-action-btn:hover {
  background: var(--accent);
  color: #000;
}
.quick-action-btn.danger:hover {
  background: var(--red);
  color: #fff;
}

/* === CELEBRATION ANIMATION === */
.celebration-overlay {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 10000;
  overflow: hidden;
}
.confetti {
  position: absolute;
  width: 10px;
  height: 10px;
  animation: confetti-fall 3s ease-out forwards;
}
@keyframes confetti-fall {
  0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
  100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
}

/* === THEME OPTIONS === */
body.theme-ocean { --bg: #0a1628; --surface: #0d2137; --card: #143a5c; --accent: #00b4d8; --pink: #48cae4; --text: #caf0f8; }
body.theme-space { --bg: #0b0c10; --surface: #1f2833; --card: #2d3a4a; --accent: #66fcf1; --pink: #c5c6c7; --purple: #45a29e; }
body.theme-candy { --bg: #ffeef8; --surface: #fff5f8; --card: #ffe0eb; --accent: #ff69b4; --pink: #ff1493; --text: #4a0028; --text-dim: #8b4060; }
body.theme-forest { --bg: #1a2f1a; --surface: #243524; --card: #2d4a2d; --accent: #90ee90; --pink: #98fb98; --green: #32cd32; --text: #e8f5e9; }

/* === MAGIC WAND / AUTO-STYLE === */
.magic-btn {
  background: linear-gradient(135deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3) !important;
  background-size: 300% 300% !important;
  animation: magic-gradient 3s ease infinite;
  color: #000 !important;
}
@keyframes magic-gradient {
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}

/* === QR CODE MODAL === */
.qr-modal {
  text-align: center;
}
.qr-modal canvas {
  margin: 20px auto;
  border-radius: 16px;
  background: #fff;
  padding: 16px;
}

/* === ONBOARDING TUTORIAL === */
.tutorial-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.9);
  z-index: 5000;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
}
.tutorial-overlay.hidden { display: none; }
.tutorial-card {
  background: var(--surface);
  border: 3px solid var(--accent);
  border-radius: 24px;
  padding: 30px;
  max-width: 400px;
  text-align: center;
  animation: bounceIn 0.5s ease-out;
}
@keyframes bounceIn {
  0% { transform: scale(0.5); opacity: 0; }
  70% { transform: scale(1.05); }
  100% { transform: scale(1); opacity: 1; }
}
.tutorial-icon { font-size: 4rem; margin-bottom: 16px; }
.tutorial-title { font-size: 1.5rem; font-weight: 800; color: var(--accent); margin-bottom: 12px; }
.tutorial-text { color: var(--text-dim); margin-bottom: 20px; line-height: 1.6; }
.tutorial-dots {
  display: flex;
  justify-content: center;
  gap: 8px;
  margin-bottom: 20px;
}
.tutorial-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: var(--card);
  transition: all 0.3s;
}
.tutorial-dot.active { background: var(--accent); transform: scale(1.3); }
.tutorial-btn {
  padding: 14px 40px;
  border: none;
  border-radius: 30px;
  background: linear-gradient(135deg, var(--accent), var(--purple));
  color: #000;
  font-size: 1rem;
  font-weight: 800;
  cursor: pointer;
}
.tutorial-skip {
  margin-top: 16px;
  background: none;
  border: none;
  color: var(--text-dim);
  font-size: 0.85rem;
  cursor: pointer;
}
.tutorial-skip:hover { color: var(--text); }

/* === THEME SELECTOR === */
.theme-selector {
  display: flex;
  gap: 6px;
  padding: 8px;
  background: var(--card);
  border-radius: 16px;
}
.theme-dot {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  border: 3px solid transparent;
  cursor: pointer;
  transition: all 0.2s;
}
.theme-dot:hover { transform: scale(1.2); }
.theme-dot.active { border-color: #fff; box-shadow: 0 0 15px currentColor; }
.theme-dot[data-theme="dark"] { background: linear-gradient(135deg, #1a1a2e, #16213e); }
.theme-dot[data-theme="ocean"] { background: linear-gradient(135deg, #0a1628, #00b4d8); }
.theme-dot[data-theme="space"] { background: linear-gradient(135deg, #0b0c10, #66fcf1); }
.theme-dot[data-theme="candy"] { background: linear-gradient(135deg, #ffeef8, #ff69b4); }
.theme-dot[data-theme="forest"] { background: linear-gradient(135deg, #1a2f1a, #90ee90); }
.theme-dot[data-theme="neon"] { background: linear-gradient(135deg, #0a0a0a, #ff00ff); }

/* === AUTO ARRANGE BUTTON === */
.auto-arrange-btn {
  background: linear-gradient(135deg, var(--purple), var(--pink)) !important;
}

/* Fullscreen Button */
.fullscreen-btn {
  position: absolute;
  top: 12px;
  right: 140px;
  width: 44px;
  height: 44px;
  border: none;
  border-radius: 50%;
  background: var(--card);
  color: var(--text);
  font-size: 1.3rem;
  cursor: pointer;
  transition: all 0.2s ease;
  z-index: 10;
  border: 2px solid var(--text-dim);
  display: none;
}
.fullscreen-btn.visible { display: flex; align-items: center; justify-content: center; }
.fullscreen-btn:hover { background: var(--surface); border-color: var(--accent); transform: scale(1.1); }

/* Celebration Animation */
.celebration-overlay {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 9999;
  overflow: hidden;
}
.confetti {
  position: absolute;
  width: 12px;
  height: 12px;
  border-radius: 2px;
  animation: confetti-fall 3s ease-out forwards;
}
@keyframes confetti-fall {
  0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
  100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
}
.celebration-text {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0);
  font-size: 3rem;
  font-weight: 900;
  text-align: center;
  animation: celebration-pop 0.5s ease-out 0.2s forwards;
  text-shadow: 0 4px 20px rgba(0,0,0,0.5);
  z-index: 10000;
}
@keyframes celebration-pop {
  0% { transform: translate(-50%, -50%) scale(0); }
  50% { transform: translate(-50%, -50%) scale(1.2); }
  100% { transform: translate(-50%, -50%) scale(1); }
}

/* Quick Action Menu */
.quick-action-menu {
  position: absolute;
  background: rgba(0,0,0,0.9);
  border: 2px solid var(--accent);
  border-radius: 16px;
  padding: 8px;
  display: flex;
  gap: 6px;
  z-index: 500;
  box-shadow: 0 10px 40px rgba(0,0,0,0.5);
  animation: menu-pop 0.2s ease-out;
}
@keyframes menu-pop {
  0% { transform: scale(0.8); opacity: 0; }
  100% { transform: scale(1); opacity: 1; }
}
.quick-action-btn {
  width: 44px;
  height: 44px;
  border: none;
  border-radius: 12px;
  background: var(--card);
  color: var(--text);
  font-size: 1.2rem;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  justify-content: center;
}
.quick-action-btn:hover { background: var(--accent); color: #000; transform: scale(1.1); }
.quick-action-btn.danger:hover { background: var(--red); color: #fff; }

/* Build Toolbar */
.build-toolbar {
  display: flex;
  gap: 8px;
  padding: 10px 12px;
  background: rgba(0,0,0,0.4);
  border-radius: 16px;
  margin-bottom: 10px;
  align-items: center;
  flex-wrap: wrap;
}
.build-toolbar-btn {
  padding: 10px 14px;
  border: none;
  border-radius: 12px;
  background: var(--card);
  color: var(--text);
  font-size: 0.9rem;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  gap: 6px;
  min-height: 44px;
}
.build-toolbar-btn:hover { background: var(--surface); transform: scale(1.05); }
.build-toolbar-btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }
.build-toolbar-btn.active { background: var(--accent); color: #000; }

/* Toolbar inline theme selector */
.build-toolbar .theme-selector {
  display: flex;
  gap: 6px;
  padding: 6px 10px;
  background: var(--card);
  border-radius: 30px;
  margin-left: auto;
  margin-top: 0;
}
.theme-dot {
  width: 26px;
  height: 26px;
  border-radius: 50%;
  border: 3px solid transparent;
  cursor: pointer;
  transition: all 0.2s;
}
.theme-dot:hover { transform: scale(1.15); }
.theme-dot.active { border-color: #fff; box-shadow: 0 0 10px currentColor; }
.theme-dot[data-theme="dark"] { background: linear-gradient(135deg, #1a1a2e, #16213e); }
.theme-dot[data-theme="ocean"] { background: linear-gradient(135deg, #0077b6, #00b4d8); }
.theme-dot[data-theme="space"] { background: linear-gradient(135deg, #3c096c, #9d4edd); }
.theme-dot[data-theme="candy"] { background: linear-gradient(135deg, #ff6b9d, #feca57); }
.theme-dot[data-theme="forest"] { background: linear-gradient(135deg, #2d5a27, #52b788); }

/* Magic button animated gradient */
.magic-btn {
  background: linear-gradient(135deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3) !important;
  background-size: 300% 300% !important;
  animation: magic-gradient 3s ease infinite !important;
  color: #000 !important;
}
@keyframes magic-gradient {
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}

/* Auto arrange button */
.auto-arrange-btn {
  background: linear-gradient(135deg, var(--purple), var(--pink)) !important;
  color: #fff !important;
}

/* Snap Guides */
.snap-guide {
  position: absolute;
  background: var(--pink);
  z-index: 999;
  pointer-events: none;
  opacity: 0.8;
}
.snap-guide.horizontal { height: 2px; left: 0; right: 0; }
.snap-guide.vertical { width: 2px; top: 0; bottom: 0; }

/* Theme Selector */
.theme-selector {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  margin-top: 8px;
}
.theme-chip {
  padding: 8px 12px;
  border-radius: 20px;
  border: 2px solid transparent;
  cursor: pointer;
  font-size: 0.8rem;
  font-weight: 700;
  transition: all 0.2s;
}
.theme-chip:hover { transform: scale(1.05); }
.theme-chip.active { border-color: #fff; }
.theme-chip.dark { background: linear-gradient(135deg, #1a1a2e, #16213e); color: #fff; }
.theme-chip.ocean { background: linear-gradient(135deg, #0077b6, #00b4d8); color: #fff; }
.theme-chip.space { background: linear-gradient(135deg, #2d1b69, #7b2cbf); color: #fff; }
.theme-chip.candy { background: linear-gradient(135deg, #ff6b9d, #feca57); color: #000; }
.theme-chip.forest { background: linear-gradient(135deg, #2d5a27, #52b788); color: #fff; }
.theme-chip.sunset { background: linear-gradient(135deg, #f72585, #ff9100); color: #fff; }

/* Theme: Ocean */
body.theme-ocean { --bg: #023e8a; --surface: #0077b6; --card: #0096c7; --accent: #00b4d8; --text: #caf0f8; --text-dim: #90e0ef; }
body.theme-ocean .canvas { background: linear-gradient(135deg, #0077b6, #0096c7); border-color: #00b4d8; }

/* Theme: Space */
body.theme-space { --bg: #10002b; --surface: #240046; --card: #3c096c; --accent: #9d4edd; --pink: #e0aaff; --text: #e0aaff; --text-dim: #7b2cbf; }
body.theme-space .canvas { background: linear-gradient(135deg, #240046, #3c096c); border-color: #9d4edd; }

/* Theme: Candy */
body.theme-candy { --bg: #fff0f3; --surface: #ffccd5; --card: #ffb3c1; --accent: #ff758f; --pink: #ff4d6d; --text: #590d22; --text-dim: #a4133c; }
body.theme-candy .canvas { background: linear-gradient(135deg, #ffccd5, #ffb3c1); border-color: #ff758f; }
body.theme-candy .widget { background: #fff; border-color: #ff758f; color: #590d22; }

/* Theme: Forest */
body.theme-forest { --bg: #1b4332; --surface: #2d6a4f; --card: #40916c; --accent: #52b788; --green: #95d5b2; --text: #d8f3dc; --text-dim: #74c69d; }
body.theme-forest .canvas { background: linear-gradient(135deg, #2d6a4f, #40916c); border-color: #52b788; }

/* Theme: Sunset */
body.theme-sunset { --bg: #3d0066; --surface: #6a0572; --card: #ab0a78; --accent: #ff9100; --pink: #f72585; --text: #fff; --text-dim: #ff85a1; }
body.theme-sunset .canvas { background: linear-gradient(135deg, #6a0572, #ab0a78); border-color: #ff9100; }

/* QR Code Modal */
.qr-modal {
  text-align: center;
}
.qr-code-container {
  background: #fff;
  padding: 20px;
  border-radius: 16px;
  display: inline-block;
  margin: 16px 0;
}
.qr-code-container canvas {
  display: block;
}

/* Button Press Effects */
.rt-button.pressing {
  animation: button-squish 0.15s ease-out;
}
@keyframes button-squish {
  0% { transform: scale(1); }
  50% { transform: scale(0.9); }
  100% { transform: scale(1); }
}

/* Particle effects container */
.particles-container {
  position: absolute;
  inset: 0;
  pointer-events: none;
  overflow: hidden;
}
.particle {
  position: absolute;
  border-radius: 50%;
  pointer-events: none;
  animation: particle-burst 0.6s ease-out forwards;
}
@keyframes particle-burst {
  0% { transform: scale(1); opacity: 1; }
  100% { transform: scale(0); opacity: 0; }
}

/* ===== MOBILE-FRIENDLY ENHANCEMENTS ===== */
@media (max-width: 600px) {
  /* Safe area for notched phones */
  .app {
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
  }
  
  /* Header compact */
  header {
    padding: 6px 8px;
    gap: 6px;
    flex-wrap: wrap;
  }
  .logo { font-size: 0.95rem; }
  .tabs { padding: 3px; }
  .tab { 
    padding: 8px 12px; 
    font-size: 0.75rem;
    min-height: 44px; /* Touch target */
  }
  
  /* Hero pills compact */
  .hero-pill {
    padding: 8px 10px;
    min-height: 44px;
  }
  .pill-text { display: none; }
  
  /* Builder header scrollable */
  .builder-header {
    padding: 8px;
    gap: 6px;
    overflow-x: auto;
    flex-wrap: nowrap;
    -webkit-overflow-scrolling: touch;
  }
  .builder-header .action-card {
    display: flex;
    gap: 6px;
    flex-shrink: 0;
  }
  .title-input {
    min-width: 120px;
    flex: 0 0 auto;
    width: 140px;
    padding: 10px 12px;
    font-size: 0.9rem;
  }
  .header-btn {
    padding: 10px 12px;
    font-size: 0.7rem;
    min-height: 44px;
    white-space: nowrap;
    flex-shrink: 0;
  }
  .header-btn span:not(.btn-icon) { display: none; }
  
  /* Palette compact horizontal scroll */
  .palette {
    padding: 8px;
    gap: 6px;
    -webkit-overflow-scrolling: touch;
  }
  .palette-item {
    padding: 10px 12px;
    min-width: 65px;
    min-height: 70px;
  }
  .palette-icon { font-size: 24px; }
  .palette-name { font-size: 0.6rem; }
  
  /* Canvas more space */
  .canvas-wrap { 
    padding: 6px; 
    min-height: 300px;
  }
  .canvas { 
    min-height: 280px;
    border-radius: 16px;
  }
  
  /* Runtime view */
  .runtime-view {
    padding: 12px;
    padding-top: 60px;
  }
  .back-to-build-btn {
    top: 8px;
    left: 8px;
    padding: 10px 16px;
    font-size: 0.85rem;
    min-height: 44px;
  }
  
  /* Arrange mode mobile */
  .arrange-mode-btn {
    top: 8px;
    right: 8px;
    padding: 10px 14px;
    font-size: 0.8rem;
    min-height: 44px;
  }
  .arrange-hint {
    font-size: 0.8rem;
    padding: 8px 12px;
    margin-bottom: 8px;
  }
  #runtimeGrid.arrange-mode .rt-widget .rt-resize-handle {
    width: 28px;
    height: 28px;
  }
  
  .connect-icon { font-size: 4rem; }
  .connect-text { font-size: 1.1rem; }
  .connect-btn {
    padding: 14px 30px;
    font-size: 1rem;
    min-height: 50px;
  }
  
  /* Props panel as bottom sheet on mobile */
  .props-panel {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    max-height: 50vh;
    border-radius: 20px 20px 0 0;
    border-left: none;
    border-top: 2px solid var(--card);
    z-index: 50;
    transform: translateY(100%);
    transition: transform 0.3s ease;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }
  .props-panel.show-mobile {
    transform: translateY(0);
  }
  .props-panel .props-title {
    position: sticky;
    top: 0;
    background: var(--surface);
    padding: 12px 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  /* Template modal */
  .template-modal {
    padding: 16px;
    padding-top: 80px;
  }
  .template-content h2 { font-size: 1.4rem; }
  .template-content p { font-size: 0.9rem; margin-bottom: 16px; }
  .templates-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
  }
  .template-card {
    padding: 16px 8px;
    border-radius: 16px;
    min-height: 90px;
  }
  .template-icon { font-size: 2rem; margin-bottom: 6px; }
  .template-name { font-size: 0.8rem; }
  
  /* Modal */
  .modal {
    padding: 16px;
    max-height: 80vh;
    border-radius: 20px;
  }
  .modal-title { font-size: 1.2rem; }
  .modal-code { font-size: 0.7rem; max-height: 250px; }
  .modal-btn { 
    padding: 12px 16px; 
    min-height: 48px;
    font-size: 0.85rem;
  }
  
  /* Widgets touch-friendly */
  .widget {
    min-width: 60px;
    min-height: 60px;
  }
  .widget-icon { font-size: 1.6rem; }
  .widget-label { font-size: 0.65rem; }
  .resize-handle {
    width: 28px;
    height: 28px;
  }
  
  /* Canvas tools */
  .canvas-tools {
    top: 6px;
    right: 6px;
    gap: 4px;
  }
  .canvas-tool-btn {
    width: 40px;
    height: 40px;
    min-width: 44px;
    min-height: 44px;
  }
  .zoom-controls {
    bottom: 6px;
    left: 6px;
  }
  .zoom-btn {
    width: 40px;
    height: 40px;
    min-width: 44px;
    min-height: 44px;
  }
}

/* Extra small screens */
@media (max-width: 380px) {
  .tab { padding: 6px 10px; font-size: 0.7rem; }
  .title-input { width: 100px; font-size: 0.85rem; }
  .header-btn { padding: 8px 10px; font-size: 0.65rem; }
  .palette-item { 
    min-width: 55px; 
    padding: 8px 10px;
  }
  .palette-icon { font-size: 20px; }
  .templates-grid { gap: 8px; }
  .template-card { padding: 12px 6px; }
  .template-icon { font-size: 1.8rem; }
  .back-to-build-btn { 
    padding: 8px 12px; 
    font-size: 0.8rem;
  }
}

/* Landscape mobile */
@media (max-height: 500px) and (orientation: landscape) {
  header { padding: 4px 8px; }
  .builder-header { padding: 6px; }
  .palette { 
    padding: 6px;
    max-height: 80px;
  }
  .palette-item { 
    padding: 6px 10px;
    min-width: 50px;
  }
  .palette-icon { font-size: 18px; }
  .palette-name { display: none; }
  .canvas-wrap { padding: 4px; }
  .runtime-view { padding-top: 50px; }
  .template-modal { padding-top: 20px; }
  .templates-grid { 
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
  }
  .template-card { padding: 10px 6px; }
  .template-icon { font-size: 1.5rem; margin-bottom: 4px; }
  .template-name { font-size: 0.7rem; }
}

/* Touch improvements */
@media (pointer: coarse) {
  .tab, .header-btn, .palette-item, .template-card, 
  .connect-btn, .modal-btn, .back-to-build-btn,
  .canvas-tool-btn, .zoom-btn {
    min-height: 44px;
    min-width: 44px;
  }
  
  /* Larger hit areas */
  .widget .resize-handle {
    width: 32px;
    height: 32px;
  }
  
  /* Prevent text selection on touch */
  .palette, .builder-header, header {
    -webkit-user-select: none;
    user-select: none;
  }
}

.connect-box { text-align: center; }
.connect-icon { font-size: 6rem; margin-bottom: 20px; animation: bounce 1s infinite; }
@keyframes bounce { 0%,100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
.connect-text { font-size: 1.3rem; font-weight: 700; margin-bottom: 24px; }
.connect-btn {
  padding: 18px 40px; border: none; border-radius: 30px;
  background: linear-gradient(135deg, var(--green), var(--accent));
  color: #000; font-size: 1.2rem; font-weight: 800; cursor: pointer;
}
#runtimeContent { 
  display: none; 
  flex-direction: column; 
  align-items: center; 
  justify-content: center;
  width: 100%; 
  min-height: 400px;
}
#runtimeTitle { font-size: 1.6rem; font-weight: 800; color: var(--accent); margin-bottom: 20px; text-align: center; }
#runtimeGrid { 
  position: relative; 
  background: var(--card); 
  border: 3px solid var(--surface); 
  border-radius: 20px;
  margin: 0 auto;
  overflow: hidden;
}

/* Runtime Widgets */
/* Graph (Online) */
.rt-graph-wrap{
  width: 100%; height: 100%;
  display:flex; flex-direction:column; gap:6px;
  padding: 10px;
  border-radius: 16px;
  background: linear-gradient(145deg, rgba(0,180,216,0.15), rgba(179,136,255,0.15));
  border: 2px solid rgba(0,212,255,0.4);
  box-shadow: inset 0 2px 10px rgba(0,0,0,0.2);
  overflow: hidden;
}
.rt-graph-head{ 
  display:flex; justify-content:space-between; align-items: center;
  font-weight:800; font-size: clamp(0.75rem, 1.8vw, 0.95rem); color: var(--accent); 
  flex-shrink: 0;
}
.rt-graph-head::before { content: 'ðŸ“ˆ '; }
.rt-graph-sub{ display:flex; gap:6px; flex-wrap:wrap; font-size: clamp(0.6rem, 1.3vw, 0.75rem); color: var(--text); font-weight:700; flex-shrink: 0; }
.rt-graph-dot{ width: 10px; height:10px; border-radius:999px; display:inline-block; vertical-align:middle; margin-right:4px; box-shadow: 0 0 8px currentColor; }
.rt-graph-canvas{
  width: 100%; 
  flex: 1;
  min-height: 60px;
  max-height: 100%;
  border-radius: 10px;
  background: rgba(0,0,0,0.25);
  border: 1px solid rgba(0,212,255,0.2);
}
.rt-graph-wrap.model-grid{
  background: linear-gradient(135deg, rgba(0,212,255,0.12), rgba(179,136,255,0.12));
  border-color: rgba(0,212,255,0.4);
}
.rt-graph-wrap.model-dark{
  background: linear-gradient(145deg, rgba(0,0,0,0.25), rgba(20,30,50,0.3));
  border-color: rgba(100,150,255,0.25);
}
.rt-graph-wrap.model-min{
  background: transparent;
  border: 1px solid rgba(0,212,255,0.25);
}

/* Gauge */
.rt-gauge-wrap{
  width:100%; height:100%;
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  gap:8px; padding:10px;
  border-radius: 20px;
  background: linear-gradient(145deg, rgba(0,0,0,0.1), rgba(0,0,0,0.2));
  border: 3px solid rgba(255,255,255,0.1);
}
.rt-gauge-svg{ width: 100%; height: auto; max-height: 60%; min-height: 60px; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3)); }
.rt-gauge-ticks line{ stroke: rgba(255,255,255,0.3); stroke-width: 3; stroke-linecap: round; }
.rt-gauge-bg{ fill:none; stroke: rgba(255,255,255,0.15); stroke-width: 14; stroke-linecap: round; }
.rt-gauge-fg{ 
  fill:none; stroke: url(#gaugeGradient); stroke-width: 14; stroke-linecap: round;
  stroke-dasharray: 157.1;
  stroke-dashoffset: 157.1;
  transition: stroke-dashoffset 0.25s ease;
  filter: drop-shadow(0 0 8px currentColor);
}

.rt-gauge-label{ font-weight:800; color: var(--text-dim); font-size: clamp(0.7rem, 2vw, 0.9rem); text-align:center; }
.rt-gauge-value{ font-weight:900; font-size: clamp(1rem, 4vw, 1.6rem); color: var(--text); text-align:center; text-shadow: 0 2px 8px rgba(0,0,0,0.3); }
.rt-gauge-emoji { font-size: clamp(1.2rem, 4vw, 2rem); }
.rt-gauge-wrap.model-classic{ 
  background: linear-gradient(145deg, rgba(0,0,0,0.2), rgba(0,0,0,0.3)); 
  border: 3px solid rgba(255,255,255,0.15);
  box-shadow: inset 0 2px 10px rgba(0,0,0,0.3);
}
.rt-gauge-wrap.model-neon{ 
  background: linear-gradient(145deg, rgba(0,255,135,0.1), rgba(96,239,255,0.1)); 
  box-shadow: 0 0 40px rgba(0,255,135,0.15), inset 0 2px 10px rgba(0,0,0,0.2);
  border: 3px solid rgba(0,255,135,0.3);
}
.rt-gauge-wrap.model-min{ 
  background: transparent; 
  border: 3px dashed rgba(255,255,255,0.2);
}

.rt-widget { position: absolute; padding: 10px; display: flex; align-items: center; justify-content: center; }
.rt-button {
  width: 100%; height: 100%; border: none; border-radius: 20px;
  background: linear-gradient(145deg, #667eea, #764ba2);
  color: #fff; font-weight: 800; cursor: pointer;
  display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px;
  font-size: clamp(0.8rem, 2.5vw, 1.3rem); 
  transition: all 0.15s ease;
  box-shadow: 
    0 8px 25px rgba(102,126,234,0.5),
    inset 0 2px 4px rgba(255,255,255,0.3),
    inset 0 -2px 4px rgba(0,0,0,0.2);
  border: 3px solid rgba(255,255,255,0.2);
  text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
.rt-button:hover { 
  transform: scale(1.03) translateY(-2px); 
  box-shadow: 0 12px 35px rgba(102,126,234,0.6), inset 0 2px 4px rgba(255,255,255,0.3);
}
.rt-button:active { 
  transform: scale(0.95); 
  box-shadow: 0 4px 15px rgba(102,126,234,0.4), inset 0 2px 8px rgba(0,0,0,0.3);
}
.rt-button .icon { font-size: clamp(1.5rem, 5vw, 3rem); filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3)); }

.rt-slider-wrap { 
  width: 100%; height: 100%; 
  display: flex; flex-direction: column; 
  justify-content: space-between; align-items: center;
  padding: 8px 10px;
  position: relative;
}
.rt-slider-label {
  font-weight: 700; 
  font-size: clamp(0.75rem, 1.8vw, 0.9rem); 
  color: var(--text);
  text-align: center;
  margin-bottom: 4px;
}
.rt-slider-info { 
  display: none;
}
.rt-slider-val { 
  background: linear-gradient(135deg, var(--accent), var(--purple));
  padding: 5px 14px;
  border-radius: 14px;
  color: #000;
  font-weight: 800;
  font-size: clamp(0.9rem, 2.2vw, 1.2rem);
  min-width: 50px;
  text-align: center;
  box-shadow: 0 3px 10px rgba(0,212,255,0.4);
  margin-top: 6px;
}
.rt-slider { 
  width: 100%; 
  height: 20px; 
  border-radius: 10px; 
  background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #f5576c); 
  background-size: 300% 100%;
  animation: slider-gradient 5s ease infinite;
  -webkit-appearance: none; 
  box-shadow: inset 0 2px 6px rgba(0,0,0,0.4);
  border: none;
  cursor: pointer;
  flex-shrink: 0;
}
@keyframes slider-gradient {
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}
.rt-slider::-webkit-slider-thumb { 
  width: 34px; height: 34px; -webkit-appearance: none; 
  border-radius: 8px; 
  background: linear-gradient(145deg, #ffffff, #e6e6e6); 
  border: 3px solid var(--accent);
  cursor: pointer; 
  box-shadow: 0 4px 12px rgba(0,0,0,0.4), 0 0 12px rgba(0,212,255,0.4);
  transition: all 0.15s ease;
}
.rt-slider::-webkit-slider-thumb:hover { 
  transform: scale(1.15) rotate(5deg); 
  border-radius: 50%;
  box-shadow: 0 6px 20px rgba(0,0,0,0.5), 0 0 20px rgba(0,212,255,0.6); 
}
.rt-slider::-webkit-slider-thumb:active { 
  transform: scale(0.95); 
  background: linear-gradient(145deg, var(--accent), #0099cc); 
}
.rt-slider::-moz-range-thumb { 
  width: 34px; height: 34px; 
  border-radius: 8px; 
  background: linear-gradient(145deg, #ffffff, #e6e6e6); 
  border: 3px solid var(--accent);
  cursor: pointer;
}

/* Vertical slider support */
.rt-slider-wrap.vertical {
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
  padding: 8px;
}
.rt-slider-wrap.vertical .rt-slider-label {
  margin-bottom: 2px;
}
.rt-slider-wrap.vertical .rt-slider-val {
  margin-top: 2px;
}
.rt-slider-wrap.vertical .rt-slider {
  width: 24px;
  height: 100%;
  min-height: 60px;
  flex: 1;
  writing-mode: vertical-lr;
  direction: rtl;
  background: linear-gradient(to top, #667eea, #764ba2, #f093fb, #f5576c);
}
.rt-slider-wrap.vertical .rt-slider::-webkit-slider-thumb {
  width: 36px;
  height: 36px;
}

.rt-toggle-wrap { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 10px; width: 100%; height: 100%; }
.rt-toggle { 
  width: 70%; height: 70%; max-width: 120px; max-height: 120px; min-width: 50px; min-height: 50px; 
  aspect-ratio: 1; border: none; border-radius: 20px; 
  background: linear-gradient(145deg, #ff6b6b, #ee5a5a);
  color: #fff; font-size: clamp(1.5rem, 5vw, 3rem); 
  cursor: pointer; transition: all 0.2s ease;
  display: flex; align-items: center; justify-content: center;
  box-shadow: 
    0 6px 20px rgba(238,90,90,0.5),
    inset 0 2px 4px rgba(255,255,255,0.3),
    inset 0 -2px 4px rgba(0,0,0,0.2);
  border: 3px solid rgba(255,255,255,0.2);
}
.rt-toggle:hover { transform: scale(1.05); }
.rt-toggle:active { transform: scale(0.95); box-shadow: 0 2px 10px rgba(238,90,90,0.5), inset 0 2px 8px rgba(0,0,0,0.3); }
.rt-toggle.on { 
  background: linear-gradient(145deg, #2ed573, #26b863);
  box-shadow: 
    0 6px 20px rgba(46,213,115,0.5),
    inset 0 2px 4px rgba(255,255,255,0.3),
    inset 0 -2px 4px rgba(0,0,0,0.2);
}
.rt-toggle-wrap > span { font-weight: 800; font-size: clamp(0.7rem, 2vw, 1rem); }

.rt-led-wrap { 
  display: flex; flex-direction: column; align-items: center; justify-content: center; 
  gap: 10px; width: 100%; height: 100%; 
}
.rt-led { 
  width: 60%; height: 60%; max-width: 80%; max-height: 80%; min-width: 30px; min-height: 30px; 
  aspect-ratio: 1; 
  border-radius: 50%; 
  background: radial-gradient(circle at 30% 30%, #666, #333 40%, #222 70%, #111);
  border: 4px solid #444;
  box-shadow: 
    inset 0 -8px 15px rgba(0,0,0,0.6),
    inset 0 8px 15px rgba(255,255,255,0.1),
    0 4px 10px rgba(0,0,0,0.5);
  transition: all 0.15s ease;
  position: relative;
}
.rt-led::before {
  content: '';
  position: absolute;
  top: 15%; left: 20%;
  width: 25%; height: 20%;
  background: radial-gradient(ellipse, rgba(255,255,255,0.4), transparent);
  border-radius: 50%;
}
.rt-led.on { 
  background: radial-gradient(circle at 30% 30%, #ff8a8a, #ff5252 30%, #ff0000 60%, #cc0000);
  border-color: #ff6666;
  box-shadow: 
    inset 0 -8px 15px rgba(0,0,0,0.3),
    inset 0 8px 15px rgba(255,255,255,0.3),
    0 0 30px #ff0000,
    0 0 60px rgba(255,0,0,0.6),
    0 0 90px rgba(255,0,0,0.3);
  animation: led-pulse 1s ease-in-out infinite alternate;
}
@keyframes led-pulse {
  0% { box-shadow: inset 0 -8px 15px rgba(0,0,0,0.3), inset 0 8px 15px rgba(255,255,255,0.3), 0 0 30px #ff0000, 0 0 60px rgba(255,0,0,0.6); }
  100% { box-shadow: inset 0 -8px 15px rgba(0,0,0,0.3), inset 0 8px 15px rgba(255,255,255,0.3), 0 0 40px #ff0000, 0 0 80px rgba(255,0,0,0.8), 0 0 120px rgba(255,0,0,0.4); }
}
.rt-led-wrap span { font-weight: 800; font-size: clamp(0.7rem, 2vw, 0.9rem); }

.rt-joystick-wrap { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 6px; width: 100%; height: 100%; }
.rt-joystick-base { 
  width: 80%; height: 80%; max-width: 150px; max-height: 150px; min-width: 60px; min-height: 60px; 
  aspect-ratio: 1; border-radius: 50%; 
  background: linear-gradient(145deg, #2d3436, #1e2526);
  border: 5px solid #3d4446;
  display: flex; align-items: center; justify-content: center; touch-action: none;
  box-shadow: 
    inset 0 4px 15px rgba(0,0,0,0.5),
    inset 0 -4px 10px rgba(255,255,255,0.05),
    0 8px 25px rgba(0,0,0,0.4);
}
.rt-joystick-stick { 
  width: 50%; height: 50%; border-radius: 50%; 
  background: linear-gradient(145deg, #ff6b6b, #ee5a5a);
  pointer-events: none;
  box-shadow: 
    0 6px 20px rgba(238,90,90,0.5),
    inset 0 3px 6px rgba(255,255,255,0.4),
    inset 0 -3px 6px rgba(0,0,0,0.3);
  border: 3px solid rgba(255,255,255,0.2);
  transition: transform 0.05s ease;
}
.rt-joystick-wrap > span { font-weight: 800; font-size: clamp(0.7rem, 2vw, 1rem); }

.rt-label-text { 
  font-weight: 800; 
  font-size: clamp(0.9rem, 3.5vw, 1.8rem); 
  text-align: center; 
  width: 100%; height: 100%; 
  display: flex; align-items: center; justify-content: center; 
  word-break: break-word; overflow: hidden;
  background: linear-gradient(135deg, rgba(102,126,234,0.1), rgba(118,75,162,0.1));
  border-radius: 16px;
  border: 3px solid rgba(255,255,255,0.15);
  padding: 10px;
  text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

/* --- Widget Models (Runtime) --- */
/* Buttons */
.rt-button.model-neo{
  background: linear-gradient(145deg, #667eea, #764ba2);
  box-shadow: 0 8px 25px rgba(102,126,234,0.5), inset 0 2px 4px rgba(255,255,255,0.3);
}
.rt-button.model-flat{
  background: linear-gradient(145deg, #00b894, #00cec9);
  color: #fff;
  box-shadow: 0 6px 20px rgba(0,206,201,0.4);
}
.rt-button.model-glass{
  background: linear-gradient(145deg, rgba(255,255,255,0.15), rgba(255,255,255,0.05));
  border: 3px solid rgba(255,255,255,0.25);
  backdrop-filter: blur(15px);
  box-shadow: 0 8px 32px rgba(0,0,0,0.3), inset 0 1px 2px rgba(255,255,255,0.2);
}

/* Sliders - More fun styles! */
.rt-slider.model-track{ 
  height: 22px; border-radius: 999px; 
  background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3, #54a0ff);
  border: 3px solid rgba(255,255,255,0.4);
}
.rt-slider.model-track::-webkit-slider-thumb {
  background: radial-gradient(circle at 30% 30%, #fff 0%, #feca57 80%, #ff9100 100%);
  border-color: #ff9100;
  box-shadow: 0 0 20px rgba(255,145,0,0.6), 0 4px 10px rgba(0,0,0,0.3);
}
.rt-slider.model-min{ 
  height: 14px; border-radius: 999px;
  background: linear-gradient(90deg, #a29bfe, #fd79a8);
  border: 2px solid rgba(255,255,255,0.3);
}
.rt-slider.model-min::-webkit-slider-thumb{
  width: 32px; height: 32px;
  background: radial-gradient(circle at 30% 30%, #fd79a8, #e84393);
  border-color: #e84393;
}
.rt-slider.model-neon{
  height: 20px;
  border-radius: 999px;
  background: linear-gradient(90deg, #00ff87, #60efff, #00ff87);
  background-size: 200% 100%;
  animation: neon-slide 3s ease-in-out infinite;
  box-shadow: 0 0 25px rgba(0,255,135,0.5), 0 0 50px rgba(96,239,255,0.3), inset 0 0 10px rgba(255,255,255,0.2);
  border: 2px solid rgba(255,255,255,0.5);
}
@keyframes neon-slide {
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}
.rt-slider.model-neon::-webkit-slider-thumb{
  background: radial-gradient(circle at 30% 30%, #fff, #60efff);
  border-color: #00ff87;
  box-shadow: 0 0 30px rgba(0,255,135,0.8), 0 0 60px rgba(96,239,255,0.5), 0 4px 15px rgba(0,0,0,0.4);
}

/* Vertical slider model overrides */
.rt-slider-wrap.vertical .rt-slider.model-track {
  background: linear-gradient(to top, #ff6b6b, #feca57, #48dbfb, #ff9ff3, #54a0ff);
}
.rt-slider-wrap.vertical .rt-slider.model-min {
  width: 14px;
  background: linear-gradient(to top, #a29bfe, #fd79a8);
}
.rt-slider-wrap.vertical .rt-slider.model-neon {
  background: linear-gradient(to top, #00ff87, #60efff, #00ff87);
  background-size: 100% 200%;
  animation: neon-slide-v 3s ease-in-out infinite;
}
@keyframes neon-slide-v {
  0%, 100% { background-position: 50% 0%; }
  50% { background-position: 50% 100%; }
}

/* Toggles */
.rt-toggle.model-square{ border-radius: 16px; }
.rt-toggle.model-pill{
  width: 80% !important;
  height: 50% !important;
  max-width: 100px;
  min-height: 36px;
  aspect-ratio: auto;
  border-radius: 999px;
  display:flex; align-items:center; justify-content:center;
  font-size: 1.4rem;
}
.rt-toggle.model-icon{
  background: var(--card);
  border: 3px solid var(--surface);
  color: var(--text);
}
.rt-toggle.model-icon.on{
  border-color: var(--green);
  box-shadow: 0 0 30px rgba(0,230,118,0.35);
}

/* LEDs */
.rt-led.model-dot{ border-radius: 50%; aspect-ratio: 1; }
.rt-led.model-bar{
  width: 90%;
  height: 30%;
  min-height: 18px;
  max-height: 50%;
  border-radius: 999px;
  aspect-ratio: auto;
}
.rt-led.model-ring{
  background: transparent !important;
  border: 6px solid rgba(255,255,255,0.18);
  box-shadow: none !important;
  aspect-ratio: 1;
}
.rt-led.model-ring.on{
  background: transparent !important;
}

/* Joysticks */
.rt-joystick-base.model-classic{ 
  border: 5px solid #3d4446;
  background: linear-gradient(145deg, #2d3436, #1e2526);
}
.rt-joystick-base.model-neon{
  border: 4px solid #00ff87;
  background: linear-gradient(145deg, #1a1a2e, #16213e);
  box-shadow: 0 0 40px rgba(0,255,135,0.3), inset 0 4px 15px rgba(0,0,0,0.5);
}
.rt-joystick-base.model-neon .rt-joystick-stick {
  background: linear-gradient(145deg, #00ff87, #60efff);
  box-shadow: 0 0 25px rgba(0,255,135,0.6), 0 6px 20px rgba(0,0,0,0.4);
}
.rt-joystick-base.model-min{
  border: 3px dashed rgba(255,255,255,0.25);
  background: transparent;
}
.rt-joystick-stick.model-min{
  background: linear-gradient(145deg, rgba(255,255,255,0.2), rgba(255,255,255,0.1));
  border: 2px solid rgba(255,255,255,0.3);
}

/* Labels */
.rt-label-text.model-plain{ 
  background: transparent;
  border: none;
}
.rt-label-text.model-card{
  background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
  border: 3px solid rgba(255,255,255,0.2);
  border-radius: 20px;
  padding: 12px 16px;
  box-shadow: 0 4px 15px rgba(0,0,0,0.2);
}
.rt-label-text.model-glow{
  text-shadow: 0 0 20px rgba(102,126,234,0.8), 0 0 40px rgba(118,75,162,0.6);
  background: linear-gradient(135deg, #667eea, #764ba2, #f093fb);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
}

/* Props panel helpers */
.props-row{
  display:flex;
  gap:8px;
  align-items:center;
}
.props-apply{
  margin-top: 10px;
  width: 100%;
  padding: 10px 12px;
  border-radius: 14px;
  border: 2px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.06);
  color: var(--text);
  font-weight: 800;
  cursor: pointer;
}
.props-apply:hover{
  border-color: var(--accent);
}


/* Loading Overlay (kid-friendly) */
.loading-overlay{
  position: fixed; inset: 0;
  display: none;
  align-items: center; justify-content: center;
  background: rgba(0,0,0,0.65);
  z-index: 3000;
  padding: 18px;
}
.loading-overlay.show{ display:flex; }
.loading-card{
  width: min(520px, 95vw);
  background: linear-gradient(135deg, rgba(0,212,255,0.14), rgba(255,107,157,0.10));
  border: 2px solid rgba(255,255,255,0.18);
  border-radius: 22px;
  padding: 18px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.45);
  text-align: center;
}
.loading-title{ font-weight: 900; font-size: 1.1rem; }
.loading-sub{ margin-top: 6px; color: var(--text-dim); font-weight: 800; }
.loading-bar{
  margin-top: 14px;
  height: 14px;
  background: rgba(0,0,0,0.22);
  border-radius: 999px;
  overflow: hidden;
  border: 2px solid rgba(255,255,255,0.12);
}
.loading-bar-fill{
  height: 100%;
  width: 0%;
  border-radius: 999px;
  background: linear-gradient(90deg, var(--accent), var(--pink), var(--yellow));
  transition: width 0.18s ease;
}
.loading-pct{ margin-top: 10px; font-weight: 900; color: var(--accent); }

/* Graph: clearer axes & legend */
.rt-graph-head{ align-items: center; }
.rt-graph-head span:first-child{ display:flex; gap:8px; align-items:center; }
.rt-graph-head span:first-child::before{ content:"ðŸ“ˆ"; }
.rt-graph-sub{ opacity: 0.92; }
.rt-graph-sub .legend-item{ display:flex; align-items:center; gap:6px; margin-right:10px; }
.rt-graph-dot{ box-shadow: 0 0 18px rgba(255,255,255,0.10); }

/* Gauge: nicer RemoteXY-like arc + ticks */
.rt-gauge-wrap{ position: relative; overflow: hidden; }
.rt-gauge-wrap::before{
  content:"";
  position:absolute; inset:0;
  background: radial-gradient(circle at 50% 40%, rgba(255,255,255,0.10), rgba(0,0,0,0) 60%);
  pointer-events:none;
}
.rt-gauge-svg{ max-height: 130px; }
.rt-gauge-center{ display:flex; flex-direction:column; align-items:center; gap:2px; }
.rt-gauge-value{ font-size: 1.2rem; }
.rt-gauge-emoji{ font-size: 1.05rem; margin-bottom: -2px; }

/* Toast */
.toast { position: fixed; bottom: -100px; left: 50%; transform: translateX(-50%); padding: 16px 32px; background: var(--card); border: 3px solid var(--accent); border-radius: 30px; font-weight: 700; font-size: 1rem; transition: 0.3s; z-index: 1000; }
.toast.show { bottom: 30px; }
.toast.success { border-color: var(--green); color: var(--green); }
.toast.error { border-color: var(--red); color: var(--red); }

/* Modal */
.modal-bg { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 200; align-items: center; justify-content: center; padding: 20px; }
.modal-bg.show { display: flex; }
.modal { background: var(--surface); border: 3px solid var(--accent); border-radius: 24px; padding: 24px;  width: 100%; max-height: 85vh; overflow-y: auto; }
.modal-title { font-size: 1.4rem; font-weight: 800; color: var(--accent); margin-bottom: 16px; }
.modal-code { background: var(--card); padding: 16px; border-radius: 16px; font-family: 'Fira Code', 'Consolas', monospace; font-size: 0.8rem; max-height: 400px; overflow: auto; color: var(--green); white-space: pre-wrap; word-break: break-all; margin-bottom: 16px; line-height: 1.5; }
.modal-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
.modal-btn { flex: 1; padding: 14px 20px; border: none; border-radius: 16px; font-weight: 700; cursor: pointer; }
.modal-btn.primary { background: linear-gradient(135deg, var(--accent), var(--purple)); color: #000; }
.modal-btn.secondary { background: var(--card); color: var(--text); }
.modal-btn.flash { background: linear-gradient(135deg, #ff6b35, #f7931e); color: #fff; position: relative; overflow: hidden; }
.modal-btn.flash:hover { transform: scale(1.02); box-shadow: 0 4px 20px rgba(255,107,53,0.4); }
.modal-btn.flash:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
.modal-btn.flash.flashing { animation: flashPulse 1s infinite; }
@keyframes flashPulse { 0%,100% { box-shadow: 0 0 10px rgba(255,107,53,0.5); } 50% { box-shadow: 0 0 25px rgba(255,107,53,0.8); } }

/* Flash Progress */
.flash-progress { margin-top: 16px; padding: 12px; background: var(--card); border-radius: 12px; }
.flash-status { font-size: 0.9rem; color: var(--text); margin-bottom: 8px; text-align: center; }
.flash-bar-bg { width: 100%; height: 8px; background: var(--surface); border-radius: 4px; overflow: hidden; }
.flash-bar { height: 100%; width: 0%; background: linear-gradient(90deg, #ff6b35, #f7931e, #00e676); border-radius: 4px; transition: width 0.3s; }

/* Template Modal */
.template-modal { position: fixed; inset: 0; background: rgba(26,26,46,0.98); z-index: 100; display: flex; padding-top: 120px; box-sizing: border-box; align-items: center; justify-content: center; padding: 20px; }
.template-modal.hidden { display: none; }
.template-content { text-align: center;  width: 100%; }
.template-content h2 { font-size: 1.8rem; margin-bottom: 10px; background: linear-gradient(90deg, var(--accent), var(--pink)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.template-content p { color: var(--text-dim); margin-bottom: 24px; font-size: 1rem; }
.templates-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
.template-card { background: var(--card); border: 3px solid transparent; border-radius: 20px; padding: 20px 10px; cursor: pointer; transition: 0.2s; }
.template-card:hover { border-color: var(--accent); transform: scale(1.05); }
.template-card:active { transform: scale(0.95); }
.template-icon { font-size: 3rem; margin-bottom: 10px; }
.template-name { font-weight: 700; font-size: 0.9rem; }

/* Responsive */
@media (min-width: 768px) {
  .builder-main { flex-direction: row; }
  .builder-side { flex: 0 0 clamp(260px, 28vw, 360px); }
  .palette-card { order: 0; }
}
@media (max-width: 500px) {
  .logo { font-size: 1rem; }
  .tab { padding: 8px 14px; font-size: 0.8rem; }
  .ble-btn span:last-child { display: none; }
  .templates-grid { grid-template-columns: repeat(2, 1fr); }
  .template-icon { font-size: 2.2rem; }
  .header-btn { padding: 10px 14px; font-size: 0.75rem; }
}

/* Properties Panel */
.props-panel{
  background: var(--surface);
  border-left: 2px solid var(--card);
  padding: 12px;
  
  min-
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.props-title{ font-weight: 800; color: var(--accent); display: flex; justify-content: space-between; align-items: center; }
.props-close-btn {
  display: none;
  background: rgba(255,255,255,0.1);
  border: none;
  color: var(--text);
  width: 32px;
  height: 32px;
  border-radius: 50%;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.2s;
}
.props-close-btn:hover { background: rgba(255,82,82,0.3); }
@media (max-width: 600px) {
  .props-close-btn { display: flex; align-items: center; justify-content: center; }
}
.props-empty{ color: var(--text-dim); font-weight: 600; font-size: 0.9rem; }
.props-title-actions { display: flex; gap: 6px; align-items: center; }
.props-collapse-btn { display: flex; align-items: center; justify-content: center; }
.props-panel.collapsed #propsEmpty,
.props-panel.collapsed #propsForm { display: none !important; }
@media (max-width: 600px) {
  .props-collapse-btn { display: none; }
}

.props-form label{
  display:block;
  margin-top: 10px;
  font-size: 0.8rem;
  color: var(--text-dim);
  font-weight: 800;
  text-transform: uppercase;
}
.props-form input, .props-form select{
  width: 100%;
  margin-top: 6px;
  padding: 10px 12px;
  border-radius: 14px;
  border: 2px solid transparent;
  background: var(--card);
  color: var(--text);
  font-weight: 700;
}
.props-form input:focus, .props-form select:focus{
  outline: none;
  border-color: var(--accent);
}

@media (min-width: 768px) {
  #propsPanel { max-height: clamp(240px, 45vh, 560px); overflow-y: auto; }
}

/* Size & Orientation controls */
.props-form .props-row {
  display: flex;
  align-items: flex-end;
}
.props-form .props-row label {
  margin: 0 0 4px 0;
  text-transform: none;
  font-size: 0.7rem;
}
.props-form .props-row input[type="number"] {
  margin-top: 0;
  padding: 8px 10px;
  text-align: center;
}
.props-form .prop-preset-size {
  background: linear-gradient(135deg, var(--card), var(--surface));
  font-weight: 800;
  transition: all 0.15s ease;
}
.props-form .prop-preset-size:hover {
  background: linear-gradient(135deg, var(--accent), var(--purple));
  color: #000;
  transform: scale(1.05);
}

@media (max-width: 768px){
  .props-panel{
    width: 100%;
    border-left: none;
    border-top: 2px solid var(--card);
  }
}


/* RTL support (Arabic) */
body.rtl { direction: rtl; }
body.rtl header, body.rtl .builder-header, body.rtl .palette, body.rtl .props-panel, body.rtl .modal { direction: rtl; }
body.rtl .tabs { direction: ltr; } /* keep tab order */
body.rtl .modal-code { direction: ltr; } /* code stays LTR */


/* ===== Hero header (Serial Logger style) ===== */
.hero-header{
  position: sticky;
  top: 0;
  z-index: 300;
  padding: 14px 18px;
  background: transparent;
}
.hero-inner{
  
  margin: 0 auto;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:16px;
  padding: 14px 18px;
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,.10);
  background: linear-gradient(180deg, rgba(12,24,54,.92), rgba(8,16,40,.88));
  box-shadow:
    0 16px 40px rgba(0,0,0,.40),
    inset 0 1px 0 rgba(255,255,255,.06);
  backdrop-filter: blur(10px);
}
.hero-left{
  display:flex;
  align-items:center;
  gap:14px;
  min-
}
.hero-logo{
  
  height: 56px;
  border-radius: 14px;
  display:flex;
  align-items:center;
  justify-content:center;
  background: rgba(255,255,255,.05);
  border: 1px solid rgba(255,255,255,.08);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
  overflow:hidden;
}
.hero-logo svg{
  
  height: 54px;
}
.hero-titles{
  display:flex;
  flex-direction:column;
  gap:4px;
}
.hero-title{
  letter-spacing: .16em;
  font-weight: 900;
  font-size: 20px;
  color: #ffbf3a;
  text-transform: uppercase;
  line-height: 1.1;
}
.hero-subtitle{
  font-size: 13px;
  color: rgba(255,255,255,.75);
  line-height: 1.2;
}
.hero-center{
  flex: 1;
  display:flex;
  justify-content:center;
}
.bismillah{
  font-size: 12px;
  color: rgba(255,255,255,.45);
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.03);
  
  text-align:center;
  white-space: nowrap;
  overflow:hidden;
  text-overflow: ellipsis;
}
.hero-right{
  display:flex;
  align-items:center;
  gap:10px;
}
.hero-pill{
  display:flex;
  align-items:center;
  gap:8px;
  padding: 9px 12px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  color: rgba(255,255,255,.90);
  cursor:pointer;
  user-select:none;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
}
.hero-pill:hover{ background: rgba(255,255,255,.06); }
.pill-dot{
  
  height: 10px;
  border-radius: 50%;
  background: rgba(255,255,255,.35);
  box-shadow: 0 0 0 3px rgba(255,255,255,.06);
}
.hero-pill-ble .pill-dot{ background: rgba(255,80,80,.85); }
.hero-pill-ble.connected .pill-dot{ background: rgba(63,220,125,.90); }
.hero-pill-sound.connected .pill-dot{ background: rgba(0,200,255,.85); }
.hero-pill-lang .pill-dot{ background: rgba(170,120,255,.85); }
.pill-text{ font-weight: 700; font-size: 12px; }

/* Responsive */
@media (max-width: 900px){
  .hero-center{ display:none; }
  .hero-left{ min- }
  .hero-title{ font-size: 16px; }
}
@media (max-width: 620px){
  .hero-subtitle{ display:none; }
  .hero-inner{ padding: 12px 12px; }
  .hero-logo{  height:46px; }
  .hero-logo svg{  height:44px; }
  .pill-text{ display:none; }
  .hero-pill{ padding: 9px 10px; }
}


/* Fun kid animations */
@keyframes rainbowShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}
@keyframes logoWiggle {
  0%,100% { transform: rotate(-2deg) scale(1); }
  25% { transform: rotate(3deg) scale(1.03); }
  50% { transform: rotate(-4deg) scale(1.06); }
  75% { transform: rotate(2deg) scale(1.03); }
}
@keyframes popBounce {
  0% { transform: translateY(0); }
  40% { transform: translateY(-4px); }
  70% { transform: translateY(1px); }
  100% { transform: translateY(0); }
}

.hero-logo { animation: logoWiggle 3.2s ease-in-out infinite; }
.hero-title{
  background: linear-gradient(90deg, #ffbf3a, #00c8ff, #aa78ff, #3fdc7d, #ff5a8a, #ffbf3a);
  background-size: 350% 350%;
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  text-shadow: 0 10px 30px rgba(0,0,0,.25);
  animation: rainbowShift 5s ease-in-out infinite, popBounce 2.4s ease-in-out infinite;
}
.hero-subtitle{
  background: linear-gradient(90deg, rgba(255,255,255,.85), rgba(255,255,255,.55));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}
.hero-logo svg { filter: drop-shadow(0 10px 18px rgba(0,0,0,.35)); }
@media (prefers-reduced-motion: reduce){
  .hero-logo, .hero-title { animation: none !important; }
}


.hero-tabs{ margin-top: 8px; display:flex; gap:8px; }
.hero-tabs .tab{
  padding: 8px 12px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 800;
}


/* === Safe overrides so external style.css won't break header controls === */
.serial-header-safe button{
  border-radius: 999px !important;
}
.serial-header-safe .hero-pill{
  border-radius: 999px !important;
  border: 1px solid rgba(255,255,255,.10) !important;
  background: rgba(255,255,255,.04) !important;
  color: rgba(255,255,255,.90) !important;
}
.serial-header-safe .hero-tabs .tab{
  border-radius: 999px !important;
  border: 1px solid rgba(255,255,255,.14) !important;
  background: rgba(255,255,255,.05) !important;
  color: rgba(255,255,255,.90) !important;
}
.serial-header-safe .hero-tabs .tab.active{
  background: rgba(255,255,255,.10) !important;
  box-shadow: 0 0 0 1px rgba(255,255,255,.10) inset !important;
}


/* ===== Flexible canvas width ===== */
.canvas,
#canvas,
.board,
.builder-canvas{
  width: 100%;
  max-width: 100%;
  min-width: 280px;
}

.builder-layout,
.main-layout{
  display: flex;
  justify-content: center;
  align-items: stretch;
}

@media (min-width: 900px){
  .canvas,
  #canvas,
  .board,
  .builder-canvas{
    max-width: 780px; /* soft limit like before */
  }
}


/* ===== Canvas flexibility (builder screen) ===== */
/* Make the center column flexible and allow the canvas to grow */
.builder-main, .main, .main-content, .builder-content, .builder-area, .center-panel, .center-col {
  flex: 1 1 auto;
  min-width: 0; /* prevents overflow forcing scroll */
}

/* Target the dashed canvas container and its inner board */
.canvas-dropzone, .dropzone, .board-drop, .canvas-wrap, .canvas-container, .canvas-frame {
  width: 100% !important;
  max-width: none !important;
  min-width: 320px;
  box-sizing: border-box;
}

.canvas-dropzone *, .dropzone *, .board-drop * {
  box-sizing: border-box;
}

/* If there's an inner scrolling element, disable it */
.canvas-dropzone, .dropzone, .board-drop, .canvas-wrap, .canvas-container, .canvas-frame {
  overflow: visible !important;
}

/* Actual board element (where widgets are placed) */
#canvasBoard, #board, .board, .canvas, .builder-canvas {
  width: 100% !important;
  max-width: none !important;
  min-width: 320px;
}

/* Remove forced fixed sizes if any were applied inline */
#canvasBoard, #board, .board, .canvas, .builder-canvas {
  height: auto !important;
}

/* Keep a soft max width only on very large screens so it still looks nice */
@media (min-width: 1200px){
  #canvasBoard, #board, .board, .canvas, .builder-canvas {
    max-width: 980px !important;
    margin-left: auto;
    margin-right: auto;
  }
}


/* ===== Resizable builder canvas (drag corner) ===== */
.resizable-wrap{
  position: relative;
  width: 100%;
  height: 520px;
  max-width: 100%;
  border-radius: 18px;
}
@media (max-width: 700px){
  .resizable-wrap{ height: 460px; }
}
.canvas-resizer{
  position:absolute;
  width: 18px;
  height: 18px;
  right: 10px;
  bottom: 10px;
  border-radius: 6px;
  background: rgba(255,255,255,.18);
  border: 1px solid rgba(255,255,255,.25);
  cursor: nwse-resize;
  box-shadow: 0 10px 18px rgba(0,0,0,.25);
}
.canvas-resizer:after{
  content:'';
  position:absolute;
  right:4px; bottom:4px;
  width: 8px; height: 8px;
  border-right: 2px solid rgba(255,255,255,.65);
  border-bottom: 2px solid rgba(255,255,255,.65);
  border-radius: 1px;
  opacity:.9;
}
.canvas-size-badge{
  position:absolute;
  left: 12px;
  bottom: 10px;
  padding: 6px 10px;
  border-radius: 999px;
  font-size: 11px;
  font-weight: 800;
  color: rgba(255,255,255,.85);
  background: rgba(0,0,0,.22);
  border: 1px solid rgba(255,255,255,.12);
  user-select:none;
}


}


/* Canvas toolbar (Build/Play + Name) centered above canvas */
.canvas-toolbar{
  width: 100%;
  display:flex;
  justify-content:center;
  margin: 10px 0 10px 0;
  pointer-events:auto;
}
.canvas-toolbar-inner{
  display:flex;
  align-items:center;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(10,18,44,.55);
  box-shadow: 0 14px 34px rgba(0,0,0,.22);
  backdrop-filter: blur(10px);
}
.canvas-toolbar-inner .tabs{ margin:0 !important; }
.canvas-toolbar-inner #titleInput{ width: min(360px, 40vw); }
@media (max-width: 720px){
  .canvas-toolbar-inner{
    width: 100%;
    justify-content:space-between;
    flex-wrap: wrap;
  }
  .canvas-toolbar-inner #titleInput{ width: 100%; }
}


/* Hide the "tap..." helper text */
.tap-hint, .canvas-hint, .builder-hint, .tap-instruction, .hint-text, .place-hint{
  display: none !important;
}


/* === Fix: don't let toolbar tab/button styles leak into widgets === */
.canvas-toolbar-inner .tab{
  padding: 9px 14px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 900;
}

/* Keep icon tiles consistent */
.widget-palette .icon,
.widget-btn .icon{
  border-radius: 14px !important;
}

/* === NEW FEATURES CSS === */
.widget.multi-selected { border-color: var(--pink) !important; box-shadow: 0 0 20px rgba(255,107,157,0.5) !important; }
.widget.locked { opacity: 0.7; cursor: not-allowed !important; }
.widget.locked::after { content: 'ðŸ”’'; position: absolute; top: 4px; right: 4px; font-size: 12px; }
.widget-ghost { position: absolute; background: rgba(0,212,255,0.15); border: 2px dashed var(--accent); border-radius: 16px; pointer-events: none; z-index: 1000; }
.align-guide { position: absolute; background: var(--accent); pointer-events: none; z-index: 999; opacity: 0.8; }
.align-guide.horizontal { height: 1px; left: 0; right: 0; }
.align-guide.vertical { width: 1px; top: 0; bottom: 0; }
.canvas.show-grid { background-image: linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px); background-size: 20px 20px; }
.minimap { position: absolute; bottom: 40px; right: 10px; width: 120px; height: 80px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; overflow: hidden; z-index: 100; }
.minimap-widget { position: absolute; background: var(--accent); border-radius: 2px; opacity: 0.7; }
.minimap-viewport { position: absolute; border: 1px solid var(--pink); background: rgba(255,107,157,0.1); }
.zoom-controls { position: absolute; bottom: 40px; left: 10px; display: flex; gap: 4px; z-index: 100; }
.zoom-btn { width: 32px; height: 32px; border: none; border-radius: 8px; background: rgba(0,0,0,0.5); color: white; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
.zoom-btn:hover { background: rgba(0,0,0,0.7); }
.zoom-level { padding: 0 8px; background: rgba(0,0,0,0.5); border-radius: 8px; color: white; font-size: 12px; display: flex; align-items: center; }
.canvas-tools { position: absolute; top: 10px; right: 10px; display: flex; gap: 6px; z-index: 100; }
.canvas-tool-btn { width: 36px; height: 36px; border: none; border-radius: 10px; background: rgba(0,0,0,0.4); color: white; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: 0.2s; }
.canvas-tool-btn:hover { background: rgba(0,0,0,0.6); }
.canvas-tool-btn.active { background: var(--accent); color: #000; }
.selection-box { position: absolute; border: 2px dashed var(--accent); background: rgba(0,212,255,0.1); pointer-events: none; z-index: 1000; }
.widget-color-dot { position: absolute; top: 4px; left: 4px; width: 10px; height: 10px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.3); }
.widget:not(:active) { transition: left 0.1s ease, top 0.1s ease; }

/* === MEGA FEATURES CSS === */
/* Layers Panel */
.layers-panel { position: fixed; right: 10px; top: 50%; transform: translateY(-50%); width: 200px; max-height: 400px; background: rgba(0,0,0,0.85); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; z-index: 200; overflow: hidden; display: none; }
.layers-panel.show { display: block; }
.layers-header { padding: 10px; background: rgba(255,255,255,0.05); font-weight: 700; font-size: 12px; display: flex; justify-content: space-between; align-items: center; }
.layers-list { max-height: 300px; overflow-y: auto; }
.layer-item { padding: 8px 10px; display: flex; align-items: center; gap: 8px; cursor: pointer; border-bottom: 1px solid rgba(255,255,255,0.05); font-size: 12px; }
.layer-item:hover { background: rgba(255,255,255,0.05); }
.layer-item.selected { background: rgba(0,212,255,0.2); }
.layer-item .layer-icon { font-size: 16px; }
.layer-vis { opacity: 0.5; cursor: pointer; }
.layer-vis.visible { opacity: 1; }

/* Toolbar Panel */
.smart-toolbar { position: absolute; top: 10px; left: 10px; display: flex; flex-wrap: wrap; gap: 4px; z-index: 100; max-width: 200px; }
.toolbar-group { display: flex; gap: 2px; background: rgba(0,0,0,0.5); border-radius: 8px; padding: 3px; }
.toolbar-sep { width: 1px; background: rgba(255,255,255,0.1); margin: 0 2px; }

/* Theme classes */
body.theme-light { --bg: #f0f4f8; --surface: #ffffff; --card: #e2e8f0; --accent: #3b82f6; --text: #1e293b; --text-dim: #64748b; }
body.theme-light .canvas { background: #e2e8f0; border-color: #94a3b8; }
body.theme-light .widget { background: #ffffff; border-color: #cbd5e1; color: #1e293b; }
body.theme-neon { --bg: #0a0a0a; --surface: #1a1a1a; --card: #2a2a2a; --accent: #ff00ff; --text: #00ffff; }
body.theme-neon .widget { box-shadow: 0 0 20px rgba(255,0,255,0.3); }
body.theme-nature { --bg: #1a2f1a; --surface: #2d4a2d; --card: #3d5a3d; --accent: #4ade80; --text: #ecfdf5; }
body.theme-sunset { --bg: #2d1b2d; --surface: #4a2c4a; --card: #6b3a6b; --accent: #f97316; --text: #fef3c7; }

/* Ruler */
.ruler { position: absolute; background: rgba(0,0,0,0.3); z-index: 50; }
.ruler-h { top: 0; left: 0; right: 0; height: 20px; }
.ruler-v { top: 0; left: 0; bottom: 0; width: 20px; }
.ruler-mark { position: absolute; color: rgba(255,255,255,0.5); font-size: 8px; }

/* History Panel */
.history-panel { position: fixed; left: 10px; top: 50%; transform: translateY(-50%); width: 60px; background: rgba(0,0,0,0.85); border-radius: 12px; z-index: 200; padding: 8px; display: none; }
.history-panel.show { display: block; }
.history-item { width: 44px; height: 30px; background: rgba(255,255,255,0.1); border-radius: 4px; margin-bottom: 4px; cursor: pointer; overflow: hidden; }
.history-item:hover { outline: 2px solid var(--accent); }

/* Search/Filter */
.widget-search { position: absolute; top: -40px; left: 0; right: 0; display: flex; gap: 8px; padding: 0 10px; }
.widget-search input { flex: 1; padding: 8px 12px; border: none; border-radius: 20px; background: rgba(0,0,0,0.3); color: white; font-size: 12px; }
.widget-search input::placeholder { color: rgba(255,255,255,0.5); }

/* Group indicator */
.widget.grouped::before { content: 'âš­'; position: absolute; top: -8px; right: -8px; background: var(--purple); color: white; width: 16px; height: 16px; border-radius: 50%; font-size: 10px; display: flex; align-items: center; justify-content: center; }

/* D-Pad widget */
.rt-dpad { 
  width: 100%; height: 100%; position: relative; 
  display: grid; grid-template: 1fr 1fr 1fr / 1fr 1fr 1fr; gap: 6px; padding: 10px;
  background: linear-gradient(145deg, rgba(0,0,0,0.2), rgba(0,0,0,0.3));
  border-radius: 20px;
  border: 3px solid rgba(255,255,255,0.1);
}
.dpad-btn { 
  background: linear-gradient(145deg, #3d4446, #2d3436);
  border: 3px solid rgba(255,255,255,0.15);
  border-radius: 12px; 
  display: flex; align-items: center; justify-content: center; 
  font-size: clamp(14px, 4vw, 28px); 
  cursor: pointer; transition: all 0.1s ease;
  box-shadow: 0 4px 10px rgba(0,0,0,0.3), inset 0 1px 2px rgba(255,255,255,0.1);
  color: #fff;
}
.dpad-btn:hover { background: linear-gradient(145deg, #4d5456, #3d4446); transform: scale(1.02); }
.dpad-btn:active, .dpad-btn.active { 
  background: linear-gradient(145deg, #667eea, #764ba2);
  border-color: rgba(255,255,255,0.3);
  transform: scale(0.95);
  box-shadow: 0 2px 5px rgba(0,0,0,0.3), inset 0 2px 4px rgba(0,0,0,0.2), 0 0 20px rgba(102,126,234,0.5);
}
.dpad-center { 
  background: linear-gradient(145deg, #1e2526, #151a1b);
  border-radius: 50%; 
  box-shadow: inset 0 2px 8px rgba(0,0,0,0.5);
}

/* XY Pad */
.rt-xypad { 
  width: 100%; height: 100%; 
  background: linear-gradient(145deg, rgba(0,0,0,0.3), rgba(0,0,0,0.4));
  border-radius: 16px; position: relative; touch-action: none;
  border: 3px solid rgba(255,255,255,0.15);
  box-shadow: inset 0 4px 15px rgba(0,0,0,0.4);
}
.xypad-dot { 
  position: absolute; width: 20%; height: 20%; 
  max-width: 40px; max-height: 40px; min-width: 20px; min-height: 20px; 
  background: linear-gradient(145deg, #ff6b6b, #ee5a5a);
  border: 3px solid rgba(255,255,255,0.3);
  border-radius: 50%; 
  transform: translate(-50%, -50%); pointer-events: none; 
  box-shadow: 0 0 20px rgba(238,90,90,0.6), 0 4px 15px rgba(0,0,0,0.4), inset 0 2px 4px rgba(255,255,255,0.3);
  transition: box-shadow 0.1s ease;
}
.xypad-crosshair { position: absolute; inset: 0; pointer-events: none; }
.xypad-crosshair::before, .xypad-crosshair::after { content: ''; position: absolute; background: rgba(255,255,255,0.15); }
.xypad-crosshair::before { left: 50%; top: 10%; bottom: 10%; width: 2px; border-radius: 1px; }
.xypad-crosshair::after { top: 50%; left: 10%; right: 10%; height: 2px; border-radius: 1px; }

/* Battery Widget */
.rt-battery { 
  width: 100%; height: 100%; 
  display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 6px;
  background: linear-gradient(145deg, rgba(0,0,0,0.1), rgba(0,0,0,0.2));
  border-radius: 16px;
  padding: 10px;
}
.battery-body { 
  width: 45%; max-width: 70px; min-width: 35px; height: 65%; max-height: 100px; 
  background: linear-gradient(145deg, #2d3436, #1e2526);
  border: 4px solid #4d5456;
  border-radius: 10px; position: relative; overflow: hidden;
  box-shadow: inset 0 4px 10px rgba(0,0,0,0.5), 0 4px 15px rgba(0,0,0,0.3);
}
.battery-tip { 
  width: 40%; max-width: 30px; height: 10px; 
  background: linear-gradient(145deg, #4d5456, #3d4446);
  border-radius: 4px 4px 0 0;
  box-shadow: 0 -2px 5px rgba(0,0,0,0.2);
}
.battery-level { 
  position: absolute; bottom: 0; left: 0; right: 0; 
  background: linear-gradient(0deg, #2ed573, #7bed9f);
  transition: height 0.3s ease, background 0.3s ease;
  box-shadow: 0 0 20px rgba(46,213,115,0.5), inset 0 -4px 10px rgba(0,0,0,0.2);
}
.battery-level.low { 
  background: linear-gradient(0deg, #ffa502, #ffbe76);
  box-shadow: 0 0 20px rgba(255,165,2,0.5), inset 0 -4px 10px rgba(0,0,0,0.2);
}
.battery-level.critical { 
  background: linear-gradient(0deg, #ff4757, #ff6b81);
  box-shadow: 0 0 20px rgba(255,71,87,0.5), inset 0 -4px 10px rgba(0,0,0,0.2);
  animation: battery-pulse 0.5s ease-in-out infinite alternate;
}
@keyframes battery-pulse {
  0% { opacity: 0.7; }
  100% { opacity: 1; }
}
.battery-text { font-size: clamp(11px, 2.5vw, 16px); font-weight: 800; }
.battery-emoji { font-size: clamp(1rem, 3vw, 1.5rem); }

/* Timer Widget */
.rt-timer { 
  width: 100%; height: 100%; 
  display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 10px;
  background: linear-gradient(145deg, rgba(102,126,234,0.15), rgba(118,75,162,0.15));
  border-radius: 20px;
  border: 3px solid rgba(255,255,255,0.15);
  padding: 10px;
}
.timer-display { 
  font-family: 'Courier New', monospace; 
  font-size: clamp(20px, 6vw, 42px); 
  font-weight: 900;
  background: linear-gradient(135deg, #667eea, #764ba2, #f093fb);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-shadow: none;
  filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
}
.timer-label { font-size: clamp(0.7rem, 2vw, 1rem); font-weight: 800; opacity: 0.8; }
.timer-controls { display: flex; gap: 6px; flex-wrap: wrap; justify-content: center; }
.timer-btn { 
  padding: 6px 14px; border: none; border-radius: 14px; 
  background: linear-gradient(145deg, #667eea, #764ba2);
  color: white; cursor: pointer; 
  font-size: clamp(12px, 2.5vw, 16px); font-weight: 700;
  box-shadow: 0 4px 12px rgba(102,126,234,0.4);
  transition: all 0.15s ease;
}
.timer-btn:hover { transform: scale(1.05); box-shadow: 0 6px 18px rgba(102,126,234,0.5); }
.timer-btn:active { transform: scale(0.95); }
.timer-btn:hover { background: rgba(255,255,255,0.2); }

/* Share Modal */
.share-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 1000; }
.share-modal.show { display: flex; }
.share-content { background: var(--surface); padding: 24px; border-radius: 16px; max-width: 400px; width: 90%; text-align: center; }
.share-qr { width: 200px; height: 200px; margin: 16px auto; background: white; border-radius: 8px; }
.share-link { width: 100%; padding: 12px; border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; background: rgba(0,0,0,0.3); color: white; font-size: 12px; margin: 8px 0; }

/* Sensor Simulator */
.sensor-sim { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); border-radius: 12px; padding: 12px; display: none; z-index: 200; }
.sensor-sim.show { display: flex; gap: 16px; }
.sensor-group { text-align: center; }
.sensor-label { font-size: 10px; color: rgba(255,255,255,0.5); margin-bottom: 4px; }
.sensor-value { font-size: 14px; font-weight: 700; }
.sensor-slider { width: 80px; }

/* Touch-friendly resize */
@media (pointer: coarse) {
  .resize-handle { width: 32px !important; height: 32px !important; }
  .canvas-tool-btn { width: 44px; height: 44px; }
  .zoom-btn { width: 40px; height: 40px; }
}

/* High contrast mode */
body.high-contrast { --bg: #000; --surface: #000; --card: #111; --accent: #ffff00; --text: #ffffff; }
body.high-contrast .widget { border-width: 4px; }


/* === Widget Properties scroll fix === */
.widget-properties,
#widgetProperties,
.properties-panel,
.sidebar-properties {
  max-height: calc(100vh - 140px);
  overflow-y: auto;
  overscroll-behavior: contain;
}

/* mobile */
@media (max-width: 768px) {
  .widget-properties,
  #widgetProperties,
  .properties-panel,
  .sidebar-properties {
    max-height: calc(100vh - 110px);
  }
}


/* === FORCE Widget Properties Scroll === */
#widgetProperties,
.widget-properties-panel,
.widget-properties,
.properties-panel,
.right-sidebar,
aside.widget-properties {
  height: calc(100vh - 120px) !important;
  overflow-y: auto !important;
  overflow-x: hidden;
}

/* ensure inner content can scroll */
#widgetProperties > * {
  min-height: max-content;
}

/* mobile */
@media (max-width: 768px) {
  #widgetProperties,
  .widget-properties-panel,
  .widget-properties,
  .properties-panel,
  .right-sidebar,
  aside.widget-properties {
    height: calc(100vh - 100px) !important;
  }
}


/* === Polishing: remove boxes around logo & bismillah, keep bismillah discreet & centered === */
.hero-logo{
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
}
.hero-logo svg{
  filter: drop-shadow(0 8px 14px rgba(0,0,0,.25)) !important;
}
.bismillah{
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
  padding: 0 !important;
  opacity: .55 !important;
  letter-spacing: .02em;
  text-align: center !important;
}
.hero-center{
  justify-content: center !important;
}


/* === Widget Properties: guaranteed vertical scrolling === */
#propsPanel, .props-panel{
  display:flex;
  flex-direction:column;
  min-height:0;
}
#propsForm, .props-form{
  flex: 1 1 auto;
  min-height: 0;           /* critical for flex scroll */
  overflow-y: auto !important;
  overflow-x: hidden;
  padding-right: 6px;      /* room for scrollbar */
  overscroll-behavior: contain;
}
#propsEmpty, .props-empty{
  flex: 1 1 auto;
  min-height: 0;
  overflow-y: auto;
}


/* === Header final polish === */

/* Bigger logo */
.hero-logo,
.app-logo,
.logo {
  transform: scale(1.25);
  transform-origin: center;
}

/* Discrete bismillah, top-center */
.bismillah{
  position: absolute;
  top: 8px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 0.8rem;
  opacity: 0.35;
  letter-spacing: .04em;
  text-align: center;
  pointer-events: none;
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
}

/* Ensure header can host absolute element */
.header,
.app-header,
.top-header{
  position: relative;
}


/* === Header tweaks: even bigger logo === */
.hero-logo,
.app-logo,
.logo {
  transform: scale(1.45);
  transform-origin: center;
}


/* === Header: MUCH bigger logo === */
.hero-logo,
.app-logo,
.logo {
  transform: scale(1.9);
  transform-origin: center;
}


/* === Header: FORCE BIG LOGO (real size, not transform) === */
.hero-logo,
.app-logo,
.logo {
  width: 120px !important;
  height: auto !important;
}

.hero-logo svg,
.app-logo svg,
.logo svg {
  width: 120px !important;
  height: auto !important;
}

/* mobile */
@media (max-width: 768px) {
  .hero-logo,
  .app-logo,
  .logo,
  .hero-logo svg,
  .app-logo svg,
  .logo svg {
    width: 96px !important;
  }
}


/* === Header: logo slightly smaller === */
.hero-logo,
.app-logo,
.logo {
  width: 100px !important;
  height: auto !important;
}

.hero-logo svg,
.app-logo svg,
.logo svg {
  width: 100px !important;
  height: auto !important;
}

/* mobile */
@media (max-width: 768px) {
  .hero-logo,
  .app-logo,
  .logo,
  .hero-logo svg,
  .app-logo svg,
  .logo svg {
    width: 84px !important;
  }
}


/* === Header card width expansion === */
.header-card,
.app-header-card,
.hero-card {
  max-width: 92% !important;
  width: 92% !important;
}

/* large screens */
@media (min-width: 1200px) {
  .header-card,
  .app-header-card,
  .hero-card {
    max-width: 1200px !important;
    width: 1200px !important;
  }
}


/* === Header card width expansion (correct selector) === */
.hero-header .hero-inner{
  width: 100% !important;
  max-width: min(1400px, calc(100% - 8px)) !important;
}
@media (min-width: 1200px){
  .hero-header .hero-inner{
    max-width: 1500px !important;
  }
}

</style>

<style>
.vertical-toolbar{
  display:flex;
  flex-direction:column;
  gap:10px;
  background:rgba(20,40,80,0.85);
  padding:12px;
  border-radius:16px;
  box-shadow:0 10px 30px rgba(0,0,0,.35);
}
.vertical-toolbar button{
  width:100%;
}

/* ===== Hero header (Serial Logger style) ===== */
.hero-header{
  position: sticky;
  top: 0;
  z-index: 50;
  padding: 14px 18px;
  background: transparent;
}
.hero-inner{
  
  margin: 0 auto;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:16px;
  padding: 14px 18px;
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,.10);
  background: linear-gradient(180deg, rgba(12,24,54,.92), rgba(8,16,40,.88));
  box-shadow:
    0 16px 40px rgba(0,0,0,.40),
    inset 0 1px 0 rgba(255,255,255,.06);
  backdrop-filter: blur(10px);
}
.hero-left{
  display:flex;
  align-items:center;
  gap:14px;
  min-
}
.hero-logo{
  
  height: 56px;
  border-radius: 14px;
  display:flex;
  align-items:center;
  justify-content:center;
  background: rgba(255,255,255,.05);
  border: 1px solid rgba(255,255,255,.08);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
  overflow:hidden;
}
.hero-logo svg{
  
  height: 54px;
}
.hero-titles{
  display:flex;
  flex-direction:column;
  gap:4px;
}
.hero-title{
  letter-spacing: .16em;
  font-weight: 900;
  font-size: 20px;
  color: #ffbf3a;
  text-transform: uppercase;
  line-height: 1.1;
}
.hero-subtitle{
  font-size: 13px;
  color: rgba(255,255,255,.75);
  line-height: 1.2;
}
.hero-center{
  flex: 1;
  display:flex;
  justify-content:center;
}
.bismillah{
  font-size: 12px;
  color: rgba(255,255,255,.45);
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.03);
  
  text-align:center;
  white-space: nowrap;
  overflow:hidden;
  text-overflow: ellipsis;
}
.hero-right{
  display:flex;
  align-items:center;
  gap:10px;
}
.hero-pill{
  display:flex;
  align-items:center;
  gap:8px;
  padding: 9px 12px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  color: rgba(255,255,255,.90);
  cursor:pointer;
  user-select:none;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
}
.hero-pill:hover{ background: rgba(255,255,255,.06); }
.pill-dot{
  
  height: 10px;
  border-radius: 50%;
  background: rgba(255,255,255,.35);
  box-shadow: 0 0 0 3px rgba(255,255,255,.06);
}
.hero-pill-ble .pill-dot{ background: rgba(255,80,80,.85); }
.hero-pill-ble.connected .pill-dot{ background: rgba(63,220,125,.90); }
.hero-pill-sound.connected .pill-dot{ background: rgba(0,200,255,.85); }
.hero-pill-lang .pill-dot{ background: rgba(170,120,255,.85); }
.pill-text{ font-weight: 700; font-size: 12px; }

/* Responsive */
@media (max-width: 900px){
  .hero-center{ display:none; }
  .hero-left{ min- }
  .hero-title{ font-size: 16px; }
}
@media (max-width: 620px){
  .hero-subtitle{ display:none; }
  .hero-inner{ padding: 12px 12px; }
  .hero-logo{  height:46px; }
  .hero-logo svg{  height:44px; }
  .pill-text{ display:none; }
  .hero-pill{ padding: 9px 10px; }
}


/* Fun kid animations */
@keyframes rainbowShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}
@keyframes logoWiggle {
  0%,100% { transform: rotate(-2deg) scale(1); }
  25% { transform: rotate(3deg) scale(1.03); }
  50% { transform: rotate(-4deg) scale(1.06); }
  75% { transform: rotate(2deg) scale(1.03); }
}
@keyframes popBounce {
  0% { transform: translateY(0); }
  40% { transform: translateY(-4px); }
  70% { transform: translateY(1px); }
  100% { transform: translateY(0); }
}

.hero-logo { animation: logoWiggle 3.2s ease-in-out infinite; }
.hero-title{
  background: linear-gradient(90deg, #ffbf3a, #00c8ff, #aa78ff, #3fdc7d, #ff5a8a, #ffbf3a);
  background-size: 350% 350%;
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  text-shadow: 0 10px 30px rgba(0,0,0,.25);
  animation: rainbowShift 5s ease-in-out infinite, popBounce 2.4s ease-in-out infinite;
}
.hero-subtitle{
  background: linear-gradient(90deg, rgba(255,255,255,.85), rgba(255,255,255,.55));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}
.hero-logo svg { filter: drop-shadow(0 10px 18px rgba(0,0,0,.35)); }
@media (prefers-reduced-motion: reduce){
  .hero-logo, .hero-title { animation: none !important; }
}


.hero-tabs{ margin-top: 8px; display:flex; gap:8px; }
.hero-tabs .tab{
  padding: 8px 12px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 800;
}


/* === Safe overrides so external style.css won't break header controls === */
.serial-header-safe button{
  border-radius: 999px !important;
}
.serial-header-safe .hero-pill{
  border-radius: 999px !important;
  border: 1px solid rgba(255,255,255,.10) !important;
  background: rgba(255,255,255,.04) !important;
  color: rgba(255,255,255,.90) !important;
}
.serial-header-safe .hero-tabs .tab{
  border-radius: 999px !important;
  border: 1px solid rgba(255,255,255,.14) !important;
  background: rgba(255,255,255,.05) !important;
  color: rgba(255,255,255,.90) !important;
}
.serial-header-safe .hero-tabs .tab.active{
  background: rgba(255,255,255,.10) !important;
  box-shadow: 0 0 0 1px rgba(255,255,255,.10) inset !important;
}


/* ===== Flexible canvas width ===== */
.canvas,
#canvas,
.board,
.builder-canvas{
  width: 100%;
  max-width: 100%;
  min-width: 280px;
}

.builder-layout,
.main-layout{
  display: flex;
  justify-content: center;
  align-items: stretch;
}

@media (min-width: 900px){
  .canvas,
  #canvas,
  .board,
  .builder-canvas{
    max-width: 780px; /* soft limit like before */
  }
}


/* ===== Canvas flexibility (builder screen) ===== */
/* Make the center column flexible and allow the canvas to grow */
.builder-main, .main, .main-content, .builder-content, .builder-area, .center-panel, .center-col {
  flex: 1 1 auto;
  min-width: 0; /* prevents overflow forcing scroll */
}

/* Target the dashed canvas container and its inner board */
.canvas-dropzone, .dropzone, .board-drop, .canvas-wrap, .canvas-container, .canvas-frame {
  width: 100% !important;
  max-width: none !important;
  min-width: 320px;
  box-sizing: border-box;
}

.canvas-dropzone *, .dropzone *, .board-drop * {
  box-sizing: border-box;
}

/* If there's an inner scrolling element, disable it */
.canvas-dropzone, .dropzone, .board-drop, .canvas-wrap, .canvas-container, .canvas-frame {
  overflow: visible !important;
}

/* Actual board element (where widgets are placed) */
#canvasBoard, #board, .board, .canvas, .builder-canvas {
  width: 100% !important;
  max-width: none !important;
  min-width: 320px;
}

/* Remove forced fixed sizes if any were applied inline */
#canvasBoard, #board, .board, .canvas, .builder-canvas {
  height: auto !important;
}

/* Keep a soft max width only on very large screens so it still looks nice */
@media (min-width: 1200px){
  #canvasBoard, #board, .board, .canvas, .builder-canvas {
    max-width: 980px !important;
    margin-left: auto;
    margin-right: auto;
  }
}


/* ===== Resizable builder canvas (drag corner) ===== */
.resizable-wrap{
  position: relative;
  width: 100%;
  height: 520px;
  max-width: 100%;
  border-radius: 18px;
}
@media (max-width: 700px){
  .resizable-wrap{ height: 460px; }
}
.canvas-resizer{
  position:absolute;
  width: 18px;
  height: 18px;
  right: 10px;
  bottom: 10px;
  border-radius: 6px;
  background: rgba(255,255,255,.18);
  border: 1px solid rgba(255,255,255,.25);
  cursor: nwse-resize;
  box-shadow: 0 10px 18px rgba(0,0,0,.25);
}
.canvas-resizer:after{
  content:'';
  position:absolute;
  right:4px; bottom:4px;
  width: 8px; height: 8px;
  border-right: 2px solid rgba(255,255,255,.65);
  border-bottom: 2px solid rgba(255,255,255,.65);
  border-radius: 1px;
  opacity:.9;
}
.canvas-size-badge{
  position:absolute;
  left: 12px;
  bottom: 10px;
  padding: 6px 10px;
  border-radius: 999px;
  font-size: 11px;
  font-weight: 800;
  color: rgba(255,255,255,.85);
  background: rgba(0,0,0,.22);
  border: 1px solid rgba(255,255,255,.12);
  user-select:none;
}


}


/* Canvas toolbar (Build/Play + Name) centered above canvas */
.canvas-toolbar{
  width: 100%;
  display:flex;
  justify-content:center;
  margin: 10px 0 10px 0;
  pointer-events:auto;
}
.canvas-toolbar-inner{
  display:flex;
  align-items:center;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(10,18,44,.55);
  box-shadow: 0 14px 34px rgba(0,0,0,.22);
  backdrop-filter: blur(10px);
}
.canvas-toolbar-inner .tabs{ margin:0 !important; }
.canvas-toolbar-inner #titleInput{ width: min(360px, 40vw); }
@media (max-width: 720px){
  .canvas-toolbar-inner{
    width: 100%;
    justify-content:space-between;
    flex-wrap: wrap;
  }
  .canvas-toolbar-inner #titleInput{ width: 100%; }
}


/* Hide the "tap..." helper text */
.tap-hint, .canvas-hint, .builder-hint, .tap-instruction, .hint-text, .place-hint{
  display: none !important;
}


/* === Fix: don't let toolbar tab/button styles leak into widgets === */
.canvas-toolbar-inner .tab{
  padding: 9px 14px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 900;
}

/* Defensive reset for widget palette/buttons to keep original rounded-square shape */
.widget-palette button,
.widget-btn,
.palette button,
.widget-list button{
  border-radius: 18px !important;
  padding: 12px 10px !important;
}

/* Keep icon tiles consistent */
.widget-palette .icon,
.widget-btn .icon{
  border-radius: 14px !important;
}


/* === Widget Properties scroll fix === */
.widget-properties,
#widgetProperties,
.properties-panel,
.sidebar-properties {
  max-height: calc(100vh - 140px);
  overflow-y: auto;
  overscroll-behavior: contain;
}

/* mobile */
@media (max-width: 768px) {
  .widget-properties,
  #widgetProperties,
  .properties-panel,
  .sidebar-properties {
    max-height: calc(100vh - 110px);
  }
}


/* === FORCE Widget Properties Scroll === */
#widgetProperties,
.widget-properties-panel,
.widget-properties,
.properties-panel,
.right-sidebar,
aside.widget-properties {
  height: calc(100vh - 120px) !important;
  overflow-y: auto !important;
  overflow-x: hidden;
}

/* ensure inner content can scroll */
#widgetProperties > * {
  min-height: max-content;
}

/* mobile */
@media (max-width: 768px) {
  #widgetProperties,
  .widget-properties-panel,
  .widget-properties,
  .properties-panel,
  .right-sidebar,
  aside.widget-properties {
    height: calc(100vh - 100px) !important;
  }
}

</style>


<style>
/* Action buttons card (kids-friendly) */
.builder-header{display:flex;align-items:flex-start;gap:14px;justify-content:flex-start;}
.action-card{
  display:flex;
  flex-direction:column;
  gap:10px;
  background:rgba(20,40,80,0.85);
  padding:12px;
  border-radius:16px;
  box-shadow:0 10px 30px rgba(0,0,0,.35);
}
.action-card .header-btn{justify-content:center;}
@media (max-width: 900px){
  .action-card .header-btn{}
}

/* ===== Hero header (Serial Logger style) ===== */
.hero-header{
  position: sticky;
  top: 0;
  z-index: 50;
  padding: 14px 18px;
  background: transparent;
}
.hero-inner{
  
  margin: 0 auto;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:16px;
  padding: 14px 18px;
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,.10);
  background: linear-gradient(180deg, rgba(12,24,54,.92), rgba(8,16,40,.88));
  box-shadow:
    0 16px 40px rgba(0,0,0,.40),
    inset 0 1px 0 rgba(255,255,255,.06);
  backdrop-filter: blur(10px);
}
.hero-left{
  display:flex;
  align-items:center;
  gap:14px;
  min-
}
.hero-logo{
  
  height: 56px;
  border-radius: 14px;
  display:flex;
  align-items:center;
  justify-content:center;
  background: rgba(255,255,255,.05);
  border: 1px solid rgba(255,255,255,.08);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
  overflow:hidden;
}
.hero-logo svg{
  
  height: 54px;
}
.hero-titles{
  display:flex;
  flex-direction:column;
  gap:4px;
}
.hero-title{
  letter-spacing: .16em;
  font-weight: 900;
  font-size: 20px;
  color: #ffbf3a;
  text-transform: uppercase;
  line-height: 1.1;
}
.hero-subtitle{
  font-size: 13px;
  color: rgba(255,255,255,.75);
  line-height: 1.2;
}
.hero-center{
  flex: 1;
  display:flex;
  justify-content:center;
}
.bismillah{
  font-size: 12px;
  color: rgba(255,255,255,.45);
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.03);
  
  text-align:center;
  white-space: nowrap;
  overflow:hidden;
  text-overflow: ellipsis;
}
.hero-right{
  display:flex;
  align-items:center;
  gap:10px;
}
.hero-pill{
  display:flex;
  align-items:center;
  gap:8px;
  padding: 9px 12px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  color: rgba(255,255,255,.90);
  cursor:pointer;
  user-select:none;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
}
.hero-pill:hover{ background: rgba(255,255,255,.06); }
.pill-dot{
  
  height: 10px;
  border-radius: 50%;
  background: rgba(255,255,255,.35);
  box-shadow: 0 0 0 3px rgba(255,255,255,.06);
}
.hero-pill-ble .pill-dot{ background: rgba(255,80,80,.85); }
.hero-pill-ble.connected .pill-dot{ background: rgba(63,220,125,.90); }
.hero-pill-sound.connected .pill-dot{ background: rgba(0,200,255,.85); }
.hero-pill-lang .pill-dot{ background: rgba(170,120,255,.85); }
.pill-text{ font-weight: 700; font-size: 12px; }

/* Responsive */
@media (max-width: 900px){
  .hero-center{ display:none; }
  .hero-left{ min- }
  .hero-title{ font-size: 16px; }
}
@media (max-width: 620px){
  .hero-subtitle{ display:none; }
  .hero-inner{ padding: 12px 12px; }
  .hero-logo{  height:46px; }
  .hero-logo svg{  height:44px; }
  .pill-text{ display:none; }
  .hero-pill{ padding: 9px 10px; }
}


/* Fun kid animations */
@keyframes rainbowShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}
@keyframes logoWiggle {
  0%,100% { transform: rotate(-2deg) scale(1); }
  25% { transform: rotate(3deg) scale(1.03); }
  50% { transform: rotate(-4deg) scale(1.06); }
  75% { transform: rotate(2deg) scale(1.03); }
}
@keyframes popBounce {
  0% { transform: translateY(0); }
  40% { transform: translateY(-4px); }
  70% { transform: translateY(1px); }
  100% { transform: translateY(0); }
}

.hero-logo { animation: logoWiggle 3.2s ease-in-out infinite; }
.hero-title{
  background: linear-gradient(90deg, #ffbf3a, #00c8ff, #aa78ff, #3fdc7d, #ff5a8a, #ffbf3a);
  background-size: 350% 350%;
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  text-shadow: 0 10px 30px rgba(0,0,0,.25);
  animation: rainbowShift 5s ease-in-out infinite, popBounce 2.4s ease-in-out infinite;
}
.hero-subtitle{
  background: linear-gradient(90deg, rgba(255,255,255,.85), rgba(255,255,255,.55));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}
.hero-logo svg { filter: drop-shadow(0 10px 18px rgba(0,0,0,.35)); }
@media (prefers-reduced-motion: reduce){
  .hero-logo, .hero-title { animation: none !important; }
}


.hero-tabs{ margin-top: 8px; display:flex; gap:8px; }
.hero-tabs .tab{
  padding: 8px 12px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 800;
}


/* === Safe overrides so external style.css won't break header controls === */
.serial-header-safe button{
  border-radius: 999px !important;
}
.serial-header-safe .hero-pill{
  border-radius: 999px !important;
  border: 1px solid rgba(255,255,255,.10) !important;
  background: rgba(255,255,255,.04) !important;
  color: rgba(255,255,255,.90) !important;
}
.serial-header-safe .hero-tabs .tab{
  border-radius: 999px !important;
  border: 1px solid rgba(255,255,255,.14) !important;
  background: rgba(255,255,255,.05) !important;
  color: rgba(255,255,255,.90) !important;
}
.serial-header-safe .hero-tabs .tab.active{
  background: rgba(255,255,255,.10) !important;
  box-shadow: 0 0 0 1px rgba(255,255,255,.10) inset !important;
}


/* ===== Flexible canvas width ===== */
.canvas,
#canvas,
.board,
.builder-canvas{
  width: 100%;
  max-width: 100%;
  min-width: 280px;
}

.builder-layout,
.main-layout{
  display: flex;
  justify-content: center;
  align-items: stretch;
}

@media (min-width: 900px){
  .canvas,
  #canvas,
  .board,
  .builder-canvas{
    max-width: 780px; /* soft limit like before */
  }
}


/* ===== Canvas flexibility (builder screen) ===== */
/* Make the center column flexible and allow the canvas to grow */
.builder-main, .main, .main-content, .builder-content, .builder-area, .center-panel, .center-col {
  flex: 1 1 auto;
  min-width: 0; /* prevents overflow forcing scroll */
}

/* Target the dashed canvas container and its inner board */
.canvas-dropzone, .dropzone, .board-drop, .canvas-wrap, .canvas-container, .canvas-frame {
  width: 100% !important;
  max-width: none !important;
  min-width: 320px;
  box-sizing: border-box;
}

.canvas-dropzone *, .dropzone *, .board-drop * {
  box-sizing: border-box;
}

/* If there's an inner scrolling element, disable it */
.canvas-dropzone, .dropzone, .board-drop, .canvas-wrap, .canvas-container, .canvas-frame {
  overflow: visible !important;
}

/* Actual board element (where widgets are placed) */
#canvasBoard, #board, .board, .canvas, .builder-canvas {
  width: 100% !important;
  max-width: none !important;
  min-width: 320px;
}

/* Remove forced fixed sizes if any were applied inline */
#canvasBoard, #board, .board, .canvas, .builder-canvas {
  height: auto !important;
}

/* Keep a soft max width only on very large screens so it still looks nice */
@media (min-width: 1200px){
  #canvasBoard, #board, .board, .canvas, .builder-canvas {
    max-width: 980px !important;
    margin-left: auto;
    margin-right: auto;
  }
}


/* ===== Resizable builder canvas (drag corner) ===== */
.resizable-wrap{
  position: relative;
  width: 100%;
  height: 520px;
  max-width: 100%;
  border-radius: 18px;
}
@media (max-width: 700px){
  .resizable-wrap{ height: 460px; }
}
.canvas-resizer{
  position:absolute;
  width: 18px;
  height: 18px;
  right: 10px;
  bottom: 10px;
  border-radius: 6px;
  background: rgba(255,255,255,.18);
  border: 1px solid rgba(255,255,255,.25);
  cursor: nwse-resize;
  box-shadow: 0 10px 18px rgba(0,0,0,.25);
}
.canvas-resizer:after{
  content:'';
  position:absolute;
  right:4px; bottom:4px;
  width: 8px; height: 8px;
  border-right: 2px solid rgba(255,255,255,.65);
  border-bottom: 2px solid rgba(255,255,255,.65);
  border-radius: 1px;
  opacity:.9;
}
.canvas-size-badge{
  position:absolute;
  left: 12px;
  bottom: 10px;
  padding: 6px 10px;
  border-radius: 999px;
  font-size: 11px;
  font-weight: 800;
  color: rgba(255,255,255,.85);
  background: rgba(0,0,0,.22);
  border: 1px solid rgba(255,255,255,.12);
  user-select:none;
}


}


/* Canvas toolbar (Build/Play + Name) centered above canvas */
.canvas-toolbar{
  width: 100%;
  display:flex;
  justify-content:center;
  margin: 10px 0 10px 0;
  pointer-events:auto;
}
.canvas-toolbar-inner{
  display:flex;
  align-items:center;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(10,18,44,.55);
  box-shadow: 0 14px 34px rgba(0,0,0,.22);
  backdrop-filter: blur(10px);
}
.canvas-toolbar-inner .tabs{ margin:0 !important; }
.canvas-toolbar-inner #titleInput{ width: min(360px, 40vw); }
@media (max-width: 720px){
  .canvas-toolbar-inner{
    width: 100%;
    justify-content:space-between;
    flex-wrap: wrap;
  }
  .canvas-toolbar-inner #titleInput{ width: 100%; }
}


/* Hide the "tap..." helper text */
.tap-hint, .canvas-hint, .builder-hint, .tap-instruction, .hint-text, .place-hint{
  display: none !important;
}


/* === Fix: don't let toolbar tab/button styles leak into widgets === */
.canvas-toolbar-inner .tab{
  padding: 9px 14px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 900;
}

/* Defensive reset for widget palette/buttons to keep original rounded-square shape */
.widget-palette button,
.widget-btn,
.palette button,
.widget-list button{
  border-radius: 18px !important;
  padding: 12px 10px !important;
}

/* Keep icon tiles consistent */
.widget-palette .icon,
.widget-btn .icon{
  border-radius: 14px !important;
}


/* === Widget Properties scroll fix === */
.widget-properties,
#widgetProperties,
.properties-panel,
.sidebar-properties {
  max-height: calc(100vh - 140px);
  overflow-y: auto;
  overscroll-behavior: contain;
}

/* mobile */
@media (max-width: 768px) {
  .widget-properties,
  #widgetProperties,
  .properties-panel,
  .sidebar-properties {
    max-height: calc(100vh - 110px);
  }
}


/* === FORCE Widget Properties Scroll === */
#widgetProperties,
.widget-properties-panel,
.widget-properties,
.properties-panel,
.right-sidebar,
aside.widget-properties {
  height: calc(100vh - 120px) !important;
  overflow-y: auto !important;
  overflow-x: hidden;
}

/* ensure inner content can scroll */
#widgetProperties > * {
  min-height: max-content;
}

/* mobile */
@media (max-width: 768px) {
  #widgetProperties,
  .widget-properties-panel,
  .widget-properties,
  .properties-panel,
  .right-sidebar,
  aside.widget-properties {
    height: calc(100vh - 100px) !important;
  }
}

</style>


<style>

/* === Helper Tools Panel (draggable + collapsible, mobile friendly) === */
.helper-panel{
  position: fixed;
  top: calc(var(--headerH, 90px) + 12px);
  right: 12px;
  width: min(340px, 92vw);
  max-height: calc(100vh - var(--headerH, 90px) - 24px);
  overflow: auto;
  z-index: 220;
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(10,18,44,0.62);
  backdrop-filter: blur(10px);
  box-shadow: 0 18px 50px rgba(0,0,0,0.40);
}

/* Folded state: keep titlebar visible, hide contents (does NOT exit) */
.helper-panel.folded{
  width: min(260px, 70vw);
  max-height: none;
  overflow: visible;
}
.helper-panel.folded .helper-body{ display:none; }
.helper-panel.folded .helper-titlebar{ border-bottom: none; }
@media (max-width: 720px){
  .helper-panel{
    left: 10px;
    right: 10px;
    width: auto;
    bottom: 10px;
    top: auto;
    max-height: 52vh;
    border-radius: 20px;
  }
}

.helper-titlebar{
  position: sticky;
  top: 0;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding: 10px 12px;
  user-select:none;
  cursor: grab;
  background: rgba(255,255,255,0.04);
  border-bottom: 1px solid rgba(255,255,255,0.10);
  border-radius: 18px 18px 0 0;
}
.helper-titlebar:active{ cursor: grabbing; }
.helper-title{
  font-weight: 900;
  font-size: 12px;
  letter-spacing: .14em;
  text-transform: uppercase;
  color: rgba(255,255,255,0.90);
  display:flex;
  align-items:center;
  gap:8px;
}
.helper-actions{ display:flex; gap:8px; align-items:center; }
.helper-action{
  width: 32px; height: 32px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(0,0,0,0.25);
  color: rgba(255,255,255,0.92);
  cursor:pointer;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight: 900;
}
.helper-action:hover{ border-color: rgba(0,212,255,0.45); }

.helper-body{ padding: 10px 10px 14px; }
.helper-details{
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(0,0,0,0.26);
  overflow:hidden;
  margin: 10px 0;
}
.helper-details summary{
  list-style:none;
  cursor:pointer;
  padding: 10px 12px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  font-weight: 900;
  font-size: 12px;
  color: rgba(255,255,255,0.90);
}
.helper-details summary::-webkit-details-marker{ display:none; }
.helper-details .helper-content{
  padding: 10px 12px 12px;
  border-top: 1px solid rgba(255,255,255,0.08);
}

.helper-fab{
  position: fixed;
  bottom: 18px;
  width: 54px; height: 54px;
  border-radius: 50%;
  background: linear-gradient(135deg, rgba(0,212,255,0.95), rgba(179,136,255,0.92));
  color: #000;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size: 24px;
  font-weight: 900;
  cursor:pointer;
  z-index: 230;
  box-shadow: 0 16px 40px rgba(0,0,0,0.35);
  border: 1px solid rgba(255,255,255,0.20);
}

/* When moved into the helper panel, force normal flow */
.helper-panel .smart-toolbar,
.helper-panel .canvas-tools,
.helper-panel .zoom-controls,
.helper-panel .minimap{
  position: static !important;
  top:auto !important; right:auto !important; bottom:auto !important; left:auto !important;
  transform:none !important;
}
.helper-panel .minimap{ width: 100% !important; height: 120px !important; }


/* === Widget Properties scroll fix === */
.widget-properties,
#widgetProperties,
.properties-panel,
.sidebar-properties {
  max-height: calc(100vh - 140px);
  overflow-y: auto;
  overscroll-behavior: contain;
}

/* mobile */
@media (max-width: 768px) {
  .widget-properties,
  #widgetProperties,
  .properties-panel,
  .sidebar-properties {
    max-height: calc(100vh - 110px);
  }
}


/* === FORCE Widget Properties Scroll === */
#widgetProperties,
.widget-properties-panel,
.widget-properties,
.properties-panel,
.right-sidebar,
aside.widget-properties {
  height: calc(100vh - 120px) !important;
  overflow-y: auto !important;
  overflow-x: hidden;
}

/* ensure inner content can scroll */
#widgetProperties > * {
  min-height: max-content;
}

/* mobile */
@media (max-width: 768px) {
  #widgetProperties,
  .widget-properties-panel,
  .widget-properties,
  .properties-panel,
  .right-sidebar,
  aside.widget-properties {
    height: calc(100vh - 100px) !important;
  }
}

</style>

</head>
<body>
<div class="app">
  
<header class="hero-header serial-header-safe">
  <div class="hero-inner">
    <div class="hero-left">
      <div class="hero-logo" aria-label="Logo">
        <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="6.000mm" height="3.214mm" viewBox="-92.820084 179.975632 6.000000 3.214096">
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-90.26918,180.70665C-90.270096,180.703674,-90.280693,180.55484,-90.292725,180.3759C-90.304756,180.19696,-90.315605,180.042282,-90.316826,180.032166L-90.319046,180.013763L-90.29628,180.013763C-90.283752,180.013748,-90.25869,180.012115,-90.240585,180.010117C-90.222481,180.008118,-90.191841,180.005646,-90.172501,180.004608L-90.137344,180.002731L-90.128738,180.131226C-90.124008,180.201889,-90.119133,180.269699,-90.117897,180.281921L-90.115662,180.304123L-90.05497,180.20639C-90.021591,180.152634,-89.977379,180.08139,-89.956726,180.048065L-89.919182,179.987488L-89.883324,179.985062C-89.863602,179.983734,-89.824806,179.980759,-89.797112,179.978455C-89.769424,179.976166,-89.739342,179.974884,-89.73027,179.975632L-89.713783,179.976974L-89.825653,180.145996L-89.937531,180.315033L-89.796638,180.490601C-89.719147,180.587158,-89.655746,180.667526,-89.655746,180.669174C-89.655746,180.670837,-89.657356,180.672195,-89.659317,180.672195C-89.676155,180.672195,-89.856628,180.684464,-89.861404,180.685928C-89.865883,180.687317,-89.896164,180.651016,-89.971275,180.554199C-90.028305,180.480698,-90.076393,180.421448,-90.07814,180.422516C-90.079887,180.423599,-90.086746,180.433975,-90.093384,180.445587L-90.105461,180.466675L-90.097374,180.581726C-90.091408,180.66658,-90.090439,180.697479,-90.093674,180.699478C-90.099167,180.702866,-90.137032,180.7061,-90.21048,180.709442C-90.257515,180.711578,-90.267807,180.71109,-90.26918,180.70665z"/>
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-89.190971,180.7686C-89.267868,180.753281,-89.31105,180.739975,-89.360039,180.716522C-89.393906,180.700302,-89.471527,180.651245,-89.480576,180.640335C-89.484718,180.635345,-89.482971,180.627808,-89.446373,180.493073C-89.44014,180.470108,-89.428429,180.473007,-89.40416,180.50351C-89.35006,180.571503,-89.267303,180.622406,-89.189331,180.635666C-89.152946,180.641846,-89.149734,180.641846,-89.129295,180.635406C-89.09346,180.624115,-89.075447,180.597748,-89.081604,180.565582C-89.085762,180.543793,-89.121902,180.514221,-89.183189,180.482422C-89.254944,180.44519,-89.27681,180.430908,-89.309555,180.399933C-89.365524,180.347,-89.382957,180.291809,-89.367203,180.217453C-89.349838,180.135468,-89.298691,180.084976,-89.207352,180.059616C-89.16906,180.048981,-89.099213,180.048294,-89.053474,180.058105C-88.98037,180.073776,-88.906212,180.104935,-88.843803,180.14621C-88.810745,180.16806,-88.807495,180.171295,-88.809486,180.180176C-88.810699,180.185577,-88.820007,180.220505,-88.830177,180.257782C-88.847977,180.323044,-88.849014,180.325516,-88.858116,180.324509C-88.863312,180.323944,-88.870895,180.31871,-88.874962,180.312897C-88.886063,180.297012,-88.932678,180.252243,-88.951851,180.239044C-89.003326,180.203629,-89.07032,180.181305,-89.113388,180.185211C-89.166359,180.190018,-89.195839,180.22757,-89.177078,180.266357C-89.168106,180.284912,-89.14418,180.302139,-89.078835,180.337082C-88.97522,180.392517,-88.924667,180.434921,-88.900993,180.486298C-88.888092,180.514282,-88.885109,180.566086,-88.894295,180.602661C-88.921547,180.711212,-89.010704,180.773865,-89.135971,180.772491C-89.156639,180.772263,-89.181389,180.770508,-89.190971,180.7686z"/>
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-91.104111,180.90361C-91.134857,180.834915,-91.198944,180.691757,-91.246529,180.585495C-91.294121,180.479233,-91.332542,180.391785,-91.331917,180.391159C-91.330269,180.389511,-91.248558,180.352615,-91.135277,180.302368C-91.080956,180.278275,-91.021782,180.253952,-91.003784,180.248306C-90.923584,180.22316,-90.848717,180.234344,-90.799507,180.278824C-90.775833,180.300217,-90.757965,180.329971,-90.742996,180.372955C-90.732986,180.401703,-90.731194,180.412506,-90.731262,180.44368C-90.731339,180.474075,-90.733147,180.485123,-90.741638,180.507187C-90.753166,180.53714,-90.772163,180.572006,-90.780914,180.579269C-90.784096,180.581909,-90.786697,180.585449,-90.786697,180.587128C-90.786697,180.590454,-90.750763,180.609756,-90.581421,180.697388C-90.520706,180.72879,-90.466957,180.757034,-90.461975,180.760147C-90.4533,180.765549,-90.456924,180.767578,-90.547188,180.807983C-90.599037,180.831192,-90.645187,180.85022,-90.64975,180.850266C-90.654312,180.850327,-90.720131,180.816483,-90.796013,180.775055L-90.933975,180.699768L-90.960068,180.711792C-90.974419,180.718399,-90.986549,180.72406,-90.987015,180.72435C-90.987488,180.724655,-90.965302,180.775085,-90.937721,180.836411C-90.910133,180.897751,-90.887093,180.950424,-90.886513,180.953476C-90.885788,180.957291,-90.909706,180.96991,-90.96286,180.993774C-91.005432,181.012878,-91.042053,181.028519,-91.044235,181.028519C-91.046425,181.028519,-91.073364,180.972321,-91.104111,180.90361zM-90.99427,180.585632C-90.928116,180.554184,-90.903168,180.526901,-90.902977,180.485809C-90.902802,180.449066,-90.926598,180.406387,-90.953178,180.395752C-90.982254,180.384109,-91.00518,180.388504,-91.073784,180.418884C-91.095886,180.428665,-91.114441,180.437119,-91.115021,180.437668C-91.116417,180.439011,-91.04142,180.606354,-91.039421,180.606354C-91.038567,180.606354,-91.018242,180.597031,-90.99427,180.585632z"/>
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-88.328873,181.18129C-88.367035,181.1548,-88.399017,181.132355,-88.399948,181.131424C-88.400887,181.130493,-88.36216,181.072723,-88.313889,181.003052C-88.265625,180.933365,-88.227539,180.875137,-88.229256,180.873642C-88.232262,180.871017,-88.36467,180.779251,-88.401207,180.754456L-88.418991,180.742401L-88.505783,180.867996C-88.55352,180.937073,-88.594093,180.993607,-88.59594,180.993622C-88.59967,180.993668,-88.741692,180.896652,-88.741692,180.894058C-88.741692,180.892731,-88.562958,180.634018,-88.382385,180.373978C-88.362411,180.345215,-88.344566,180.321136,-88.342712,180.320465C-88.340332,180.319611,-88.229614,180.393921,-88.196304,180.418747C-88.195633,180.41925,-88.226578,180.465042,-88.265076,180.520508C-88.303574,180.575974,-88.335899,180.623642,-88.336906,180.62645C-88.338058,180.629654,-88.30468,180.655014,-88.246178,180.695328C-88.195274,180.730423,-88.152,180.759674,-88.150009,180.76033C-88.148026,180.761002,-88.11441,180.715302,-88.075317,180.658768C-88.036224,180.602249,-88.002808,180.556,-88.00106,180.556C-87.996506,180.556,-87.856689,180.652924,-87.856689,180.656067C-87.856689,180.66153,-88.251923,181.229736,-88.255615,181.229599C-88.257751,181.229523,-88.29071,181.207779,-88.328873,181.18129z"/>
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-91.754158,181.531448C-91.888771,181.512161,-92.043076,181.366882,-92.082649,181.222183C-92.093285,181.183273,-92.092499,181.109177,-92.081032,181.069366C-92.049042,180.958313,-91.935387,180.846329,-91.824692,180.816788C-91.785378,180.806305,-91.704155,180.807419,-91.663956,180.818985C-91.603546,180.836395,-91.54142,180.875549,-91.484215,180.932281C-91.430611,180.985458,-91.394707,181.040161,-91.374954,181.098755C-91.364899,181.128601,-91.362389,181.143066,-91.360794,181.18042C-91.358604,181.231888,-91.362877,181.260315,-91.379135,181.302338C-91.403221,181.364624,-91.466469,181.439941,-91.530434,181.482498C-91.598885,181.528046,-91.669739,181.543549,-91.754158,181.531448zM-91.605019,181.363525C-91.545914,181.336853,-91.511971,181.268951,-91.52636,181.206177C-91.548233,181.110733,-91.662498,180.996597,-91.760284,180.972504C-91.805176,180.961456,-91.846542,180.972488,-91.884094,181.005539C-91.904282,181.023315,-91.923706,181.059692,-91.92746,181.086777C-91.935303,181.143326,-91.900101,181.216187,-91.832245,181.283859C-91.751648,181.364258,-91.670021,181.392868,-91.605019,181.363525z"/>
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-90.370827,181.625046C-90.382538,181.620316,-90.390862,181.606598,-90.416695,181.549454C-90.474388,181.421844,-90.474808,181.421082,-90.488495,181.41835C-90.495407,181.416962,-90.549316,181.415833,-90.608307,181.415833L-90.715553,181.415833L-90.723869,181.430634C-90.735786,181.451828,-90.771561,181.484283,-90.794991,181.495132C-90.860039,181.525269,-90.93119,181.512695,-90.977165,181.462952C-90.988503,181.450684,-91.003014,181.430267,-91.009399,181.417587C-91.019745,181.397064,-91.021019,181.390701,-91.021019,181.35968C-91.021019,181.328476,-91.019714,181.322067,-91.008591,181.298569C-90.99292,181.265488,-90.965279,181.238113,-90.930862,181.221588C-90.907669,181.210464,-90.901016,181.209076,-90.869965,181.208862C-90.80793,181.208435,-90.764534,181.22995,-90.732475,181.277023L-90.715042,181.302612L-90.575615,181.304077C-90.436188,181.305527,-90.43618,181.305542,-90.416817,181.31517C-90.398369,181.324356,-90.3964,181.32692,-90.375305,181.369354C-90.363121,181.39386,-90.334541,181.455734,-90.31179,181.506851C-90.28904,181.557983,-90.267876,181.603714,-90.264763,181.60849C-90.253143,181.626328,-90.259285,181.628876,-90.313087,181.628616C-90.340317,181.628479,-90.366295,181.626862,-90.370827,181.625046z"/>
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-87.689041,181.814713C-87.786903,181.790314,-87.870369,181.715668,-87.921272,181.60704C-87.961113,181.522034,-87.962357,181.427811,-87.924713,181.347366C-87.880302,181.252457,-87.770462,181.160889,-87.653992,181.121689C-87.640503,181.117157,-87.61174,181.110748,-87.590088,181.107452C-87.543861,181.100433,-87.500732,181.104416,-87.451973,181.120224C-87.34948,181.153458,-87.251862,181.266296,-87.221748,181.386353C-87.207726,181.442276,-87.215767,181.522842,-87.240837,181.577591C-87.277092,181.656799,-87.35939,181.734268,-87.458282,181.782288C-87.516975,181.810791,-87.550575,181.819305,-87.610748,181.820877C-87.648811,181.821884,-87.665543,181.820572,-87.689041,181.814713zM-87.607124,181.645813C-87.521301,181.624573,-87.416893,181.542801,-87.382721,181.470062C-87.368477,181.439743,-87.366684,181.395477,-87.378441,181.364151C-87.39109,181.330444,-87.414368,181.304169,-87.445808,181.288101C-87.470551,181.275452,-87.474403,181.274643,-87.507584,181.27504C-87.550888,181.275543,-87.590546,181.287354,-87.635773,181.313187C-87.705246,181.35289,-87.755898,181.400772,-87.779976,181.449539C-87.793938,181.477798,-87.794716,181.481354,-87.794716,181.516357C-87.794716,181.549286,-87.793526,181.555664,-87.783806,181.574631C-87.750412,181.639832,-87.686684,181.665497,-87.607124,181.645813z"/>
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-91.179817,182.039474C-91.240829,182.01506,-91.283562,181.954742,-91.284126,181.892227C-91.284538,181.846878,-91.272766,181.820145,-91.236206,181.783401C-91.198219,181.745209,-91.182449,181.739227,-91.119781,181.739273C-91.077911,181.739304,-91.073738,181.740036,-91.050072,181.751389C-91.022453,181.764633,-90.989449,181.794998,-90.973816,181.821548L-90.964127,181.837997L-90.801819,181.837997L-90.639519,181.837997L-90.639519,181.87619C-90.639519,181.897202,-90.640625,181.92247,-90.641983,181.932358L-90.644447,181.950317L-90.804367,181.950317L-90.964287,181.950317L-90.981079,181.974396C-91.000191,182.001801,-91.03743,182.0336,-91.057686,182.039841C-91.065216,182.04216,-91.091415,182.044769,-91.115913,182.045639C-91.153854,182.046982,-91.163322,182.046066,-91.179817,182.039474z"/>
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-90.43026,182.097061C-90.443474,182.091797,-90.44574,182.086975,-90.445808,182.064041L-90.445862,182.044144L-90.473946,182.030762C-90.509743,182.013718,-90.522903,182.002441,-90.536835,181.976837C-90.552689,181.947708,-90.555206,181.902817,-90.542641,181.873596C-90.531776,181.848343,-90.494835,181.812912,-90.473343,181.807114C-90.454979,181.80217,-90.451126,181.79776,-90.447922,181.777969C-90.443199,181.748764,-90.442154,181.746368,-90.43222,181.741837C-90.426376,181.739182,-90.403076,181.737305,-90.37587,181.737305L-90.329475,181.737305L-90.325516,181.747726C-90.32296,181.75444,-90.32196,181.818039,-90.322708,181.926041C-90.3237,182.07019,-90.324684,182.094437,-90.329674,182.09758C-90.337296,182.102402,-90.417938,182.10199,-90.43026,182.097061z"/>
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-88.590645,182.127808L-88.590645,181.999313L-88.701027,181.812332C-88.761742,181.709473,-88.811409,181.623474,-88.811409,181.621216C-88.811409,181.618393,-88.782516,181.617432,-88.719673,181.618134L-88.62793,181.619171L-88.567894,181.728592C-88.534874,181.788773,-88.506706,181.838013,-88.505295,181.838013C-88.503883,181.838013,-88.476761,181.788773,-88.445015,181.728592L-88.387306,181.619171L-88.297256,181.618134C-88.247726,181.617569,-88.207207,181.617935,-88.207207,181.618958C-88.207207,181.621033,-88.414284,181.971008,-88.422684,181.983139C-88.426903,181.989243,-88.427971,182.017624,-88.427971,182.123535L-88.427971,182.256302L-88.509308,182.256302L-88.590645,182.256302L-88.590645,182.127808z"/>
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-89.308197,182.253403C-89.309006,182.251801,-89.309547,182.226959,-89.309387,182.198212L-89.309105,182.14592L-89.263596,182.144821L-89.218086,182.143738L-89.218086,181.936768L-89.218086,181.729797L-89.263596,181.728714L-89.309105,181.727615L-89.309105,181.673401L-89.309105,181.619171L-89.13578,181.618164L-88.962463,181.617157L-88.962463,181.673355L-88.962463,181.729553L-89.007004,181.729553L-89.051544,181.729553L-89.051544,181.936768L-89.051544,182.143982L-89.007004,182.143982L-88.962463,182.143982L-88.962463,182.200134L-88.962463,182.256302L-89.13459,182.256302C-89.229256,182.256302,-89.307381,182.25499,-89.308197,182.253403z"/>
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-89.905563,182.262238C-89.96151,182.247894,-89.990219,182.234238,-90.052368,182.192383C-90.115425,182.149918,-90.14962,182.130615,-90.192177,182.113449L-90.219284,182.102524L-90.218651,182.052567C-90.218292,182.025085,-90.217857,181.94191,-90.217682,181.867706L-90.217354,181.732803L-90.20089,181.726425C-90.161942,181.711304,-90.114967,181.68573,-90.064362,181.6521C-90.005035,181.612671,-89.953232,181.586243,-89.917183,181.577011C-89.823479,181.552994,-89.732635,181.562454,-89.646065,181.605209C-89.560043,181.64769,-89.498184,181.720734,-89.463531,181.820694C-89.453461,181.849747,-89.45282,181.85553,-89.452698,181.919342L-89.452568,181.987122L-89.466812,182.025299C-89.487122,182.079727,-89.50985,182.117279,-89.545082,182.154602C-89.597618,182.210281,-89.660454,182.245728,-89.739082,182.264069C-89.786667,182.275162,-89.858246,182.274368,-89.905563,182.262238zM-89.721596,181.735367L-89.721596,181.698578L-89.795181,181.698578L-89.868774,181.698578L-89.868774,181.735367L-89.868774,181.772156L-89.795181,181.772156L-89.721596,181.772156L-89.721596,181.735367zM-90.027565,181.888351L-90.027565,181.698578L-90.062424,181.698578L-90.097282,181.698578L-90.097282,181.888351L-90.097282,182.07814L-90.062424,182.07814L-90.027565,182.07814L-90.027565,181.888351zM-89.566666,181.888351L-89.566666,181.698578L-89.603462,181.698578L-89.640259,181.698578L-89.640259,181.888351L-89.640259,182.07814L-89.603462,182.07814L-89.566666,182.07814L-89.566666,181.888351zM-89.873528,182.154633L-89.872482,182.07814L-89.797035,182.07814L-89.721596,182.07814L-89.721596,181.963882L-89.721596,181.849625L-89.795181,181.849625L-89.868774,181.849625L-89.868774,181.886276L-89.868774,181.922928L-89.831009,181.924042L-89.793243,181.925156L-89.792145,181.964844L-89.791039,182.004547L-89.868637,182.004547L-89.946236,182.004547L-89.946236,182.116226C-89.946236,182.177643,-89.945007,182.229126,-89.943512,182.230621C-89.942017,182.232117,-89.925896,182.232834,-89.907684,182.232239L-89.87458,182.231125L-89.873528,182.154633z"/>
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-92.15197,182.548569C-92.177536,182.545853,-92.224594,182.540802,-92.256546,182.537354C-92.288498,182.53392,-92.338173,182.52858,-92.366928,182.525513C-92.395683,182.522461,-92.434898,182.518082,-92.454071,182.515793C-92.473244,182.513504,-92.512894,182.509094,-92.542183,182.505966C-92.57148,182.502853,-92.620277,182.497635,-92.650635,182.494385C-92.680992,182.491135,-92.728966,182.486145,-92.757248,182.483307C-92.785538,182.480469,-92.809792,182.47702,-92.811157,182.475662C-92.812523,182.474289,-92.799805,182.436142,-92.782898,182.390884C-92.754135,182.313873,-92.751503,182.308502,-92.74189,182.307388C-92.736244,182.306732,-92.704903,182.310547,-92.672249,182.315887C-92.639587,182.321213,-92.58847,182.329208,-92.558647,182.333633C-92.528824,182.338074,-92.494835,182.343353,-92.483124,182.345383C-92.471405,182.347397,-92.437416,182.352676,-92.407593,182.357101C-92.377769,182.361511,-92.338562,182.367523,-92.320465,182.370438C-92.302368,182.373352,-92.287102,182.37529,-92.286552,182.374741C-92.285995,182.374191,-92.372719,182.313995,-92.479263,182.240982C-92.585815,182.167969,-92.673676,182.107132,-92.674507,182.105774C-92.675339,182.104416,-92.662621,182.067581,-92.64624,182.023911L-92.616463,181.944504L-92.597237,181.944794C-92.586662,181.944946,-92.555351,181.947952,-92.527664,181.951462C-92.499969,181.954971,-92.454651,181.960617,-92.426956,181.964005C-92.399269,181.967392,-92.36528,181.971695,-92.351433,181.973557C-92.328728,181.976624,-92.30175,181.979965,-92.19651,181.992737C-92.178406,181.994934,-92.159386,181.99675,-92.154243,181.996765C-92.148262,181.99678,-92.215065,181.952087,-92.340157,181.87236C-92.44754,181.803909,-92.536781,181.746689,-92.53846,181.745178C-92.542084,181.741913,-92.481216,181.576385,-92.476608,181.576981C-92.47123,181.577667,-91.883232,181.983047,-91.883003,181.986237C-91.882706,181.990311,-91.945244,182.160767,-91.948204,182.16394C-91.950806,182.166733,-91.989197,182.1633,-92.237175,182.138077C-92.266998,182.13504,-92.3097,182.130722,-92.332069,182.128479C-92.354439,182.126236,-92.376221,182.123383,-92.380486,182.122147C-92.38739,182.120148,-92.387596,182.120544,-92.382416,182.125809C-92.379227,182.129059,-92.299919,182.184326,-92.206192,182.248627C-92.112465,182.312927,-92.033577,182.367615,-92.030884,182.370163C-92.023773,182.376907,-92.089813,182.554764,-92.099144,182.554016C-92.102638,182.553726,-92.126411,182.551285,-92.15197,182.548569z"/>
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-87.128403,182.564102C-87.143234,182.558975,-87.167259,182.546646,-87.181786,182.536728C-87.243195,182.494766,-87.274879,182.442429,-87.301308,182.33931C-87.310005,182.305374,-87.317406,182.277313,-87.317749,182.276932C-87.318092,182.276566,-87.334915,182.280426,-87.355141,182.285492C-87.475342,182.315628,-87.534744,182.329453,-87.537277,182.327881C-87.540825,182.325684,-87.582123,182.160416,-87.579628,182.158386C-87.578636,182.157593,-87.527283,182.144516,-87.465508,182.129364C-87.403732,182.114197,-87.299156,182.088531,-87.233116,182.072311C-87.167084,182.056107,-87.067268,182.031494,-87.011299,182.017624C-86.955338,182.003754,-86.90667,181.99295,-86.903137,181.993637C-86.89814,181.994598,-86.890068,182.02179,-86.866554,182.116867C-86.824165,182.288239,-86.820068,182.309433,-86.820084,182.35701C-86.820129,182.467148,-86.873154,182.536438,-86.980072,182.566071C-87.022186,182.577744,-87.091675,182.576828,-87.128403,182.564102zM-87.029533,182.389496C-86.989899,182.377716,-86.96804,182.346741,-86.967896,182.302109C-86.967819,182.279099,-86.980309,182.210999,-86.986679,182.199707C-86.988358,182.196732,-87.018852,182.202759,-87.084679,182.219101C-87.137245,182.232147,-87.181396,182.243958,-87.182785,182.245346C-87.186104,182.248672,-87.166954,182.318787,-87.156876,182.34024C-87.145279,182.364914,-87.122299,182.386688,-87.100632,182.393509C-87.080498,182.399857,-87.060677,182.398743,-87.029533,182.389496z"/>
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-90.936707,182.606812C-90.969139,182.590576,-90.996002,182.563431,-91.010574,182.532135C-91.01944,182.513092,-91.020889,182.504822,-91.02095,182.473129C-91.021019,182.439178,-91.020012,182.434204,-91.008255,182.410309C-90.991882,182.377029,-90.965805,182.351044,-90.933876,182.336182C-90.910561,182.325317,-90.905411,182.324448,-90.864159,182.324265C-90.822647,182.324097,-90.81813,182.324844,-90.797768,182.335159C-90.769356,182.349548,-90.740501,182.375031,-90.72467,182.399689L-90.712036,182.419388L-90.596565,182.418213C-90.518204,182.417404,-90.479713,182.415649,-90.476784,182.412704C-90.474403,182.410324,-90.451157,182.361526,-90.42511,182.30426L-90.377762,182.200134L-90.329086,182.199066C-90.302315,182.198471,-90.275864,182.199707,-90.270309,182.201828C-90.260429,182.205582,-90.260323,182.206009,-90.265526,182.220337C-90.268456,182.228394,-90.285095,182.266373,-90.302498,182.304718C-90.319901,182.343063,-90.345772,182.400543,-90.359985,182.432449C-90.388527,182.496521,-90.406647,182.520279,-90.43071,182.525162C-90.437981,182.526642,-90.50544,182.528824,-90.580612,182.529999L-90.7173,182.532166L-90.730164,182.552261C-90.745949,182.576935,-90.770706,182.598938,-90.796379,182.611115C-90.813423,182.619186,-90.821381,182.6203,-90.862671,182.620331C-90.908592,182.620377,-90.910179,182.620087,-90.936707,182.606812z"/>
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-89.823586,182.830811C-89.825005,182.829391,-89.826164,182.809341,-89.826164,182.78627L-89.826164,182.744308L-88.327271,182.744308L-86.828384,182.744324L-86.828384,182.788864L-86.828384,182.833405L-88.324692,182.833389C-89.147659,182.833389,-89.822166,182.83223,-89.823586,182.830811z"/>
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-90.825432,182.968948L-90.825432,182.926346L-88.826904,182.926346L-86.828384,182.926346L-86.828384,182.968964L-86.828384,183.011566L-88.826904,183.011551L-90.825432,183.011551L-90.825432,182.968948z"/>
    <path style="stroke:none;fill:#007BFF;fill-rule:evenodd" d="M-92.820084,183.14711L-92.820084,183.104507L-89.824234,183.104507L-86.828384,183.104523L-86.828384,183.147125L-86.828384,183.189728L-89.824234,183.189713L-92.820084,183.189713L-92.820084,183.14711z"/>
</svg>

      </div>
      <div class="hero-titles">
        <div class="hero-title">MICRO:BIT REMOTE STUDIO</div>
        <div class="hero-subtitle">Build fun remotes â€¢ Connect â€¢ Play â€¢ Learn</div>
        <div class="tabs hero-tabs">
          <button class="tab active" data-tab="builder">âœï¸ Build</button>
          <button class="tab" data-tab="runtime">â–¶ï¸ Play</button>
        </div>
      </div>
    </div>

    <div class="hero-center">
      <div class="bismillah" lang="ar" dir="rtl">Ø¨ÙØ³Ù’Ù…Ù Ù±Ù„Ù„ÙŽÙ‘Ù°Ù‡Ù Ù±Ù„Ø±ÙŽÙ‘Ø­Ù’Ù…ÙŽÙ°Ù†Ù Ù±Ù„Ø±ÙŽÙ‘Ø­ÙÙŠÙ…Ù</div>
    </div>

    <div class="hero-right">
      <button id="langBtn" class="hero-pill hero-pill-lang" title="Language">
        <span class="pill-dot"></span>
        <span class="pill-text">ðŸŒ</span>
      </button>

      <button id="soundBtn" class="hero-pill hero-pill-sound" title="Sound">
        <span class="pill-dot"></span>
        <span class="pill-text">Sound On</span>
      </button>

      <button id="bleBtn" class="hero-pill hero-pill-ble" title="Connection">
        <span class="pill-dot"></span>
        <span class="pill-text">Connect</span>
      </button>
    </div>
  </div>
</header>


  <div id="templateModal" class="template-modal">
    <div class="template-content">
      <h2>ðŸŽ¨ Choose a Template!</h2>
      <p>Pick one to start building your remote</p>
      <div class="templates-grid">
        <div class="template-card" data-tpl="gamepad"><div class="template-icon">ðŸŽ®</div><div class="template-name">Game Pad</div></div>
        <div class="template-card" data-tpl="robot"><div class="template-icon">ðŸ¤–</div><div class="template-name">Robot</div></div>
        <div class="template-card" data-tpl="mixer"><div class="template-icon">ðŸŽµ</div><div class="template-name">DJ Mixer</div></div>
        <div class="template-card" data-tpl="racing"><div class="template-icon">ðŸŽï¸</div><div class="template-name">Race Car</div></div>
        <div class="template-card" data-tpl="lights"><div class="template-icon">ðŸ’¡</div><div class="template-name">Lights</div></div>
        <div class="template-card" data-tpl="blank"><div class="template-icon">âœ¨</div><div class="template-name">Start Fresh</div></div>
      </div>
    </div>
  </div>

  <main>
    <div class="view builder-view active">
      <div class="builder-header">
        <input type="text" id="titleInput" class="title-input" placeholder="ðŸ·ï¸ Name your remote..." maxlength="25">
      </div>
      <div class="builder-main">
        <div class="canvas-wrap">
          <div class="build-toolbar">
            <button class="build-toolbar-btn" id="undoBtn" title="Undo (Ctrl+Z)" disabled>â†©ï¸</button>
            <button class="build-toolbar-btn" id="redoBtn" title="Redo (Ctrl+Y)" disabled>â†ªï¸</button>
            <button class="build-toolbar-btn auto-arrange-btn" id="autoArrangeBtn" title="Auto-arrange widgets">âœ¨ Tidy</button>
            <button class="build-toolbar-btn magic-btn" id="magicBtn" title="Magic styling!">ðŸª„ Magic</button>
            <div class="theme-selector">
              <div class="theme-dot active" data-theme="dark" title="Dark"></div>
              <div class="theme-dot" data-theme="ocean" title="Ocean"></div>
              <div class="theme-dot" data-theme="space" title="Space"></div>
              <div class="theme-dot" data-theme="candy" title="Candy"></div>
              <div class="theme-dot" data-theme="forest" title="Forest"></div>
            </div>
          </div>
          <div class="canvas-hint">ðŸ‘† Tap a widget below, then <span>tap here</span> to place it! â€¢ ðŸ“± Shake phone for surprise!</div>
          <div id="canvas" class="canvas"><div id="widgetsLayer"></div></div>
        </div>

        <aside class="builder-side">
          <div class="collapsible-card" id="actionsCard">
            <button class="collapsible-card-toggle" id="actionsToggle" type="button" aria-expanded="true" aria-controls="actionsBody">
              <span class="collapsible-card-title">ðŸŽ® Actions</span>
              <span class="collapsible-card-chevron">â–¾</span>
            </button>
            <div class="collapsible-card-body action-card" id="actionsBody">
              <button class="header-btn btn-demo" id="demoBtn">ðŸŽ® Try All Widgets!</button>
              <button class="header-btn btn-code" id="exportJsonBtn">ðŸ“¦ Export</button>
              <button class="header-btn btn-code" id="importJsonBtn">ðŸ“‚ Import</button>
              <button class="header-btn btn-template" id="templateBtn">ðŸŽ¨ Templates</button>
              <button class="header-btn btn-code" id="codeBtn">ðŸ“„ Code</button>
              <button class="header-btn btn-delete" id="deleteBtn">ðŸ—‘ï¸</button>
            </div>
          </div>

          <div id="propsPanel" class="props-panel props-card">
            <div class="props-title">
              ðŸ› ï¸ Widget Properties
              <div class="props-title-actions">
                <button id="propsCollapseBtn" class="props-close-btn props-collapse-btn" type="button" title="Collapse">â€“</button>
                <button id="propsPanelClose" class="props-close-btn" type="button">âœ•</button>
              </div>
            </div>
            <div id="propsEmpty" class="props-empty">Select a widget to edit it.</div>
            <div id="propsForm" class="props-form" style="display:none;"></div>
          </div>

          <div class="palette-card collapsible-card" id="paletteCard">
            <button class="palette-card-toggle collapsible-card-toggle" id="paletteToggle" type="button" aria-expanded="true" aria-controls="paletteBody">
              <span class="palette-card-title collapsible-card-title">ðŸ§© Widgets</span>
              <span class="palette-card-chevron collapsible-card-chevron">â–¾</span>
            </button>
            <div class="palette-card-body collapsible-card-body" id="paletteBody">
              <div class="palette">
                <div class="palette-item" data-type="button"><div class="palette-icon">ðŸ‘†</div><div class="palette-name">Button</div></div>
                <div class="palette-item" data-type="slider"><div class="palette-icon">ðŸŽšï¸</div><div class="palette-name">Slider</div></div>
                <div class="palette-item" data-type="toggle"><div class="palette-icon">ðŸ”˜</div><div class="palette-name">Switch</div></div>
                <div class="palette-item" data-type="joystick"><div class="palette-icon">ðŸ•¹ï¸</div><div class="palette-name">Joystick</div></div>
                <div class="palette-item" data-type="dpad"><div class="palette-icon">âœ›</div><div class="palette-name">D-Pad</div></div>
                <div class="palette-item" data-type="xypad"><div class="palette-icon">ðŸ“</div><div class="palette-name">XY Pad</div></div>
                <div class="palette-item" data-type="led"><div class="palette-icon">ðŸ’¡</div><div class="palette-name">Light</div></div>
                <div class="palette-item" data-type="label"><div class="palette-icon">ðŸ·ï¸</div><div class="palette-name">Label</div></div>
                <div class="palette-item" data-type="gauge"><div class="palette-icon">ðŸ§­</div><div class="palette-name">Gauge</div></div>
                <div class="palette-item" data-type="graph"><div class="palette-icon">ðŸ“ˆ</div><div class="palette-name">Graph</div></div>
                <div class="palette-item" data-type="battery"><div class="palette-icon">ðŸ”‹</div><div class="palette-name">Battery</div></div>
                <div class="palette-item" data-type="timer"><div class="palette-icon">â±ï¸</div><div class="palette-name">Timer</div></div>
              </div>
            </div>
          </div>
        </aside>
      </div>
    </div>

    <div class="view runtime-view">
      <button id="backToBuildBtn" class="back-to-build-btn">â† Back to Build</button>
      <div class="runtime-top-btns">
        <button id="arrangeModeBtn" class="arrange-mode-btn">ðŸ“ Arrange</button>
        <button id="fullscreenBtn" class="fullscreen-btn">â›¶ Fullscreen</button>
      </div>
      <button id="fullscreenExitBtn" class="fullscreen-exit-btn">âœ•</button>
      <div id="quickActionsMenu" class="quick-actions-menu">
        <button class="quick-action-btn" data-action="duplicate">ðŸ“‹ Duplicate</button>
        <button class="quick-action-btn" data-action="color">ðŸŽ¨ Random Color</button>
        <button class="quick-action-btn" data-action="lock">ðŸ”’ Lock/Unlock</button>
        <button class="quick-action-btn" data-action="front">â¬†ï¸ Bring Front</button>
        <button class="quick-action-btn" data-action="back">â¬‡ï¸ Send Back</button>
        <button class="quick-action-btn danger" data-action="delete">ðŸ—‘ï¸ Delete</button>
      </div>
      <div id="connectPrompt" class="connect-box">
        <div class="connect-icon">ðŸ“¡</div>
        <div class="connect-text">Connect your micro:bit!</div>
        <button id="connectBtn" class="connect-btn">ðŸ”— Connect</button>
      </div>
      <div id="runtimeContent">
        <div id="runtimeTitle"></div>
        <div id="arrangeHint" class="arrange-hint" style="display:none;">
          ðŸ‘† Drag widgets to rearrange â€¢ Tap "Done" when finished
        </div>
        <div id="runtimeGrid"></div>
      </div>
    </div>
  </main>
</div>

<div id="toast" class="toast"></div>

<!-- Tutorial Overlay -->
<div id="tutorialOverlay" class="tutorial-overlay hidden">
  <div class="tutorial-card">
    <div class="tutorial-icon" id="tutorialIcon">ðŸ‘‹</div>
    <div class="tutorial-title" id="tutorialTitle">Welcome!</div>
    <div class="tutorial-text" id="tutorialText">Let's build your first remote control!</div>
    <div class="tutorial-dots">
      <div class="tutorial-dot active" data-step="0"></div>
      <div class="tutorial-dot" data-step="1"></div>
      <div class="tutorial-dot" data-step="2"></div>
      <div class="tutorial-dot" data-step="3"></div>
    </div>
    <button class="tutorial-btn" id="tutorialNextBtn">Let's Go! ðŸš€</button>
    <button class="tutorial-skip" id="tutorialSkipBtn">Skip Tutorial</button>
  </div>
</div>

<div id="loadingOverlay" class="loading-overlay" aria-hidden="true">
  <div class="loading-card">
    <div class="loading-title">ðŸ§© Loading your remote...</div>
    <div class="loading-sub" id="loadingSub">Getting layout from micro:bit</div>
    <div class="loading-bar">
      <div class="loading-bar-fill" id="loadingBarFill"></div>
    </div>
    <div class="loading-pct" id="loadingPct">0%</div>
  </div>
</div>

<div id="modalBg" class="modal-bg">
  <div class="modal">
    <div id="modalTitle" class="modal-title"></div>
    <pre id="modalCode" class="modal-code"></pre>
    <div class="modal-buttons">
      <button class="modal-btn primary" id="copyBtn">ðŸ“‹ Copy</button>
      <button class="modal-btn primary" id="downloadBtn">ðŸ’¾ Save</button>
      <button class="modal-btn flash" id="flashBtn">âš¡ Flash to micro:bit</button>
      <button class="modal-btn secondary" id="modalClose">âœ–ï¸ Close</button>
    </div>
    <div id="flashProgress" class="flash-progress" style="display:none;">
      <div class="flash-status" id="flashStatus">Preparing...</div>
      <div class="flash-bar-bg"><div class="flash-bar" id="flashBar"></div></div>
    </div>
  </div>
</div>

<!-- Hidden iframe for MakeCode compilation -->
<iframe id="makecodeFrame" style="display:none;position:absolute;left:-9999px;width:1px;height:1px;" sandbox="allow-scripts allow-same-origin allow-popups allow-forms"></iframe>
<input type="file" id="fileInput" accept=".json" hidden>

<script>
window.__ovl = window.__ovl || { t:null };

const UART_SERVICE = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const UART_TX_CHAR = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
const UART_RX_CHAR = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

// ========================================
// BLUETOOTH FLASHING (Partial Flashing Service)
// ========================================
const PFS_SERVICE = 'e97dd91d-251d-470a-a062-fa1922dfa9a8';
const PFS_CHAR = 'e97d3b10-251d-470a-a062-fa1922dfa9a8';

// Partial Flashing commands
const PFS_CMD = {
  REGION_INFO: 0x00,
  FLASH_DATA: 0x01,
  END_OF_TX: 0x02,
  STATUS: 0xEE,
  RESET: 0xFF
};

// Flash state
const flashState = {
  device: null,
  server: null,
  pfsChar: null,
  hexData: null,
  isFlashing: false,
  progress: 0,
  packetNum: 0,
  resolve: null,
  reject: null
};

// Update flash UI
function updateFlashUI(status, progress) {
  const statusEl = document.getElementById('flashStatus');
  const barEl = document.getElementById('flashBar');
  const progressEl = document.getElementById('flashProgress');
  const flashBtn = document.getElementById('flashBtn');
  
  if (status) {
    progressEl.style.display = 'block';
    statusEl.textContent = status;
  }
  if (progress !== undefined) {
    barEl.style.width = progress + '%';
  }
  if (flashBtn) {
    flashBtn.disabled = flashState.isFlashing;
    flashBtn.classList.toggle('flashing', flashState.isFlashing);
    flashBtn.textContent = flashState.isFlashing ? 'â³ Flashing...' : 'âš¡ Flash to micro:bit';
  }
}

// MakeCode compilation via iframe messaging
const MakeCodeCompiler = {
  iframe: null,
  pendingCompile: null,
  isReady: false,
  
  init() {
    this.iframe = document.getElementById('makecodeFrame');
    if (!this.iframe) return;
    
    // Listen for messages from MakeCode
    window.addEventListener('message', (e) => this.handleMessage(e));
  },
  
  handleMessage(e) {
    // Accept messages from MakeCode domains
    if (!e.origin.includes('makecode.microbit.org') && !e.origin.includes('makecode.com')) return;
    
    const data = e.data;
    if (!data || typeof data !== 'object') return;
    
    console.log('[MakeCode] Message:', data.type || data.action);
    
    if (data.type === 'pxthost') {
      if (data.action === 'workspacesync') {
        // MakeCode is ready
        this.isReady = true;
        console.log('[MakeCode] Editor ready');
      }
    }
    
    // Handle compiled hex response
    if (data.type === 'pxthost' && data.action === 'workspacesave') {
      if (this.pendingCompile && data.project && data.project.text) {
        // Find the hex file in the response
        const hexFile = Object.keys(data.project.text).find(k => k.endsWith('.hex'));
        if (hexFile) {
          this.pendingCompile.resolve(data.project.text[hexFile]);
          this.pendingCompile = null;
        }
      }
    }
  },
  
  // Compile TypeScript code to hex using MakeCode's compile endpoint
  async compile(tsCode) {
    updateFlashUI('Compiling code...', 5);
    
    // Use MakeCode's cloud compile API
    try {
      const response = await fetch('https://makecode.microbit.org/api/compile/v3', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          config: {
            name: 'micro:bit Remote',
            dependencies: { bluetooth: '*', core: '*' },
            files: ['main.ts'],
            supportedTargets: ['microbit']
          },
          files: {
            'main.ts': tsCode
          }
        })
      });
      
      if (!response.ok) throw new Error('Compile request failed');
      
      const result = await response.json();
      if (result.hex) {
        return result.hex;
      } else if (result.hexurl) {
        // Fetch the hex from the URL
        const hexResponse = await fetch(result.hexurl);
        return await hexResponse.text();
      }
      throw new Error('No hex in compile response');
    } catch (err) {
      console.error('[MakeCode] Compile error:', err);
      throw err;
    }
  }
};

// Parse Intel HEX format
function parseIntelHex(hexString) {
  const lines = hexString.split('\n').filter(l => l.startsWith(':'));
  const data = [];
  let extendedAddr = 0;
  
  for (const line of lines) {
    const bytes = line.slice(1).match(/.{2}/g).map(h => parseInt(h, 16));
    const byteCount = bytes[0];
    const address = (bytes[1] << 8) | bytes[2];
    const recordType = bytes[3];
    const payload = bytes.slice(4, 4 + byteCount);
    
    if (recordType === 0x00) { // Data record
      const fullAddr = extendedAddr + address;
      for (let i = 0; i < payload.length; i++) {
        data.push({ addr: fullAddr + i, byte: payload[i] });
      }
    } else if (recordType === 0x02) { // Extended segment address
      extendedAddr = ((payload[0] << 8) | payload[1]) << 4;
    } else if (recordType === 0x04) { // Extended linear address
      extendedAddr = ((payload[0] << 8) | payload[1]) << 16;
    }
  }
  
  return data;
}

// Connect to micro:bit for flashing
async function connectForFlash() {
  updateFlashUI('Connecting to micro:bit...', 10);
  
  try {
    // Request device with Partial Flashing Service
    const device = await navigator.bluetooth.requestDevice({
      filters: [{ namePrefix: 'BBC micro:bit' }],
      optionalServices: [PFS_SERVICE, UART_SERVICE]
    });
    
    flashState.device = device;
    device.addEventListener('gattserverdisconnected', onFlashDisconnect);
    
    updateFlashUI('Connecting to GATT...', 15);
    const server = await device.gatt.connect();
    flashState.server = server;
    
    updateFlashUI('Finding Partial Flash Service...', 20);
    
    try {
      const pfsService = await server.getPrimaryService(PFS_SERVICE);
      flashState.pfsChar = await pfsService.getCharacteristic(PFS_CHAR);
      
      // Enable notifications
      await flashState.pfsChar.startNotifications();
      flashState.pfsChar.addEventListener('characteristicvaluechanged', onPfsNotification);
      
      console.log('[Flash] Partial Flashing Service connected');
      return true;
    } catch (e) {
      console.warn('[Flash] PFS not available:', e.message);
      throw new Error('Partial Flashing Service not available. Please flash a MakeCode program to your micro:bit first via USB, then try again.');
    }
  } catch (err) {
    console.error('[Flash] Connection error:', err);
    throw err;
  }
}

function onFlashDisconnect() {
  console.log('[Flash] Disconnected');
  flashState.device = null;
  flashState.server = null;
  flashState.pfsChar = null;
  if (flashState.isFlashing) {
    flashState.isFlashing = false;
    updateFlashUI('Disconnected during flash', 0);
  }
}

function onPfsNotification(event) {
  const value = new Uint8Array(event.target.value.buffer);
  console.log('[Flash] PFS notification:', Array.from(value).map(b => b.toString(16).padStart(2, '0')).join(' '));
  
  // Handle flash acknowledgments
  if (flashState.resolve) {
    flashState.resolve(value);
  }
}

// Flash hex data to micro:bit
async function flashHexToDevice(hexString) {
  if (!flashState.pfsChar) {
    throw new Error('Not connected to Partial Flashing Service');
  }
  
  updateFlashUI('Parsing hex file...', 25);
  
  // Parse the hex file
  const hexData = parseIntelHex(hexString);
  if (hexData.length === 0) {
    throw new Error('Invalid or empty hex file');
  }
  
  console.log('[Flash] Hex parsed:', hexData.length, 'bytes');
  
  // Put micro:bit into flash mode
  updateFlashUI('Entering flash mode...', 30);
  await sendPfsCommand(PFS_CMD.RESET, [0x00]); // Reset to BLE mode
  await sleep(500);
  
  // Get region info
  updateFlashUI('Reading memory map...', 35);
  await sendPfsCommand(PFS_CMD.REGION_INFO, [0x00]);
  await sleep(100);
  
  // Start flashing
  updateFlashUI('Flashing...', 40);
  flashState.isFlashing = true;
  
  // Group data into 16-byte chunks (4 packets per block)
  const chunkSize = 16;
  const totalChunks = Math.ceil(hexData.length / chunkSize);
  let currentChunk = 0;
  
  for (let i = 0; i < hexData.length; i += chunkSize) {
    const chunk = hexData.slice(i, Math.min(i + chunkSize, hexData.length));
    const addr = chunk[0].addr;
    
    // Build flash packet: [0x01, packetNum, addr(4 bytes), data(16 bytes)]
    const packet = new Uint8Array(20);
    packet[0] = PFS_CMD.FLASH_DATA;
    packet[1] = flashState.packetNum % 4;
    packet[2] = (addr >> 0) & 0xFF;
    packet[3] = (addr >> 8) & 0xFF;
    
    for (let j = 0; j < chunk.length && j < 16; j++) {
      packet[4 + j] = chunk[j].byte;
    }
    
    try {
      await flashState.pfsChar.writeValueWithoutResponse(packet);
    } catch (e) {
      console.error('[Flash] Write error:', e);
    }
    
    flashState.packetNum++;
    currentChunk++;
    
    // Update progress every 4 packets (1 block)
    if (flashState.packetNum % 4 === 0) {
      const progress = 40 + Math.floor((currentChunk / totalChunks) * 50);
      updateFlashUI(`Flashing... ${Math.floor((currentChunk / totalChunks) * 100)}%`, progress);
      await sleep(5); // Small delay between blocks
    }
  }
  
  // End of transmission
  updateFlashUI('Finalizing...', 95);
  await sendPfsCommand(PFS_CMD.END_OF_TX, []);
  await sleep(100);
  
  // Reset to application mode
  await sendPfsCommand(PFS_CMD.RESET, [0x01]);
  
  flashState.isFlashing = false;
  updateFlashUI('Flash complete! âœ“', 100);
}

async function sendPfsCommand(cmd, data) {
  if (!flashState.pfsChar) return;
  
  const packet = new Uint8Array(1 + data.length);
  packet[0] = cmd;
  for (let i = 0; i < data.length; i++) {
    packet[1 + i] = data[i];
  }
  
  await flashState.pfsChar.writeValueWithoutResponse(packet);
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Main flash function
async function flashToMicrobit() {
  if (flashState.isFlashing) {
    toast('Flash already in progress', 'warning');
    return;
  }
  
  // Check Web Bluetooth support
  if (!navigator.bluetooth) {
    toast('Web Bluetooth not supported. Use Chrome or Edge on desktop/Android.', 'error');
    return;
  }
  
  const flashBtn = document.getElementById('flashBtn');
  const progressEl = document.getElementById('flashProgress');
  
  try {
    flashState.isFlashing = true;
    updateFlashUI('Starting...', 0);
    
    // Get the current code from the modal
    const code = document.getElementById('modalCode').textContent;
    if (!code) {
      throw new Error('No code to flash');
    }
    
    // Compile the code
    updateFlashUI('Compiling with MakeCode...', 5);
    
    // For now, we'll use a simplified approach - download the hex and let user flash via USB
    // Full BLE partial flashing requires the micro:bit to already have a compatible runtime
    
    // Try MakeCode compile API
    let hexString;
    try {
      hexString = await MakeCodeCompiler.compile(code);
      console.log('[Flash] Got hex:', hexString.length, 'bytes');
    } catch (compileErr) {
      console.error('[Flash] Compile failed:', compileErr);
      // Fallback: offer to open MakeCode
      toast('Could not compile. Opening MakeCode to compile manually...', 'warning');
      
      // Create a MakeCode share URL with the code
      const encoded = encodeURIComponent(code);
      window.open(`https://makecode.microbit.org/#pub:`, '_blank');
      
      flashState.isFlashing = false;
      updateFlashUI('', 0);
      progressEl.style.display = 'none';
      return;
    }
    
    // Connect and flash
    await connectForFlash();
    await flashHexToDevice(hexString);
    
    toast('âœ… Flash complete!', 'success');
    beepSuccess && beepSuccess();
    
    // Close modal after success
    setTimeout(() => {
      document.getElementById('modalBg').classList.remove('show');
      progressEl.style.display = 'none';
    }, 2000);
    
  } catch (err) {
    console.error('[Flash] Error:', err);
    toast('Flash failed: ' + err.message, 'error');
    updateFlashUI('Error: ' + err.message, 0);
  } finally {
    flashState.isFlashing = false;
    updateFlashUI(null, undefined);
  }
}

// Alternative: Direct USB flashing via WebUSB
async function flashViaUSB() {
  if (!navigator.usb) {
    toast('WebUSB not supported. Use Chrome or Edge.', 'error');
    return;
  }
  
  try {
    updateFlashUI('Requesting USB device...', 5);
    
    const device = await navigator.usb.requestDevice({
      filters: [{ vendorId: 0x0D28 }] // ARM DAPLink
    });
    
    await device.open();
    await device.selectConfiguration(1);
    await device.claimInterface(0);
    
    // Get the code and compile
    const code = document.getElementById('modalCode').textContent;
    updateFlashUI('Compiling...', 10);
    
    const hexString = await MakeCodeCompiler.compile(code);
    
    // For WebUSB DAPLink flashing, we need the DAP.js library
    // This is complex, so for now we'll download the hex
    updateFlashUI('WebUSB flashing coming soon! Downloading hex instead...', 50);
    
    // Download the hex file
    const blob = new Blob([hexString], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'microbit-remote.hex';
    a.click();
    URL.revokeObjectURL(url);
    
    toast('Hex downloaded! Drag it to your micro:bit drive.', 'success');
    
  } catch (err) {
    console.error('[USB Flash] Error:', err);
    toast('USB flash error: ' + err.message, 'error');
  }
}

// Initialize MakeCode compiler
document.addEventListener('DOMContentLoaded', () => {
  MakeCodeCompiler.init();
});

// ========================================
// END BLUETOOTH FLASHING
// ========================================

const encoder = new TextEncoder();
const esc = s => { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; };
const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);

// ---- Resizable canvas helper (builder) ----
function findCanvasDropzone(){
  return document.querySelector('.canvas-dropzone, .dropzone, .board-drop, .canvas-wrap, .canvas-container, .canvas-frame, .builder-canvas, .board, .canvas');
}

function makeCanvasResizable(){
  const dz = findCanvasDropzone();
  if (!dz) return;

  // Avoid double wrapping
  if (dz.closest('.resizable-wrap')) return;

  const wrap = document.createElement('div');
  wrap.className = 'resizable-wrap';

  // Restore saved size
  try{
    const saved = JSON.parse(localStorage.getItem('kid_canvas_size') || 'null');
    if (saved && saved.w && saved.h){
      wrap.style.width = Math.min(saved.w, window.innerWidth - 80) + 'px';
      wrap.style.height = Math.min(saved.h, window.innerHeight - 220) + 'px';
    }
  }catch(e){}

  // Insert wrapper in DOM
  const parent = dz.parentElement;
  parent.insertBefore(wrap, dz);
  wrap.appendChild(dz);

  // Ensure the dropzone stretches inside wrapper
  dz.style.width = '100%';
  dz.style.height = '100%';
  dz.style.maxWidth = 'none';
  dz.style.overflow = 'hidden';

  // Add resizer handles + size badge
  const handleXY = document.createElement('div');
  handleXY.className = 'canvas-resizer canvas-resizer-xy';
  const handleE = document.createElement('div');
  handleE.className = 'canvas-resizer canvas-resizer-e';
  const handleS = document.createElement('div');
  handleS.className = 'canvas-resizer canvas-resizer-s';
  const badge = document.createElement('div');
  badge.className = 'canvas-size-badge';
  badge.textContent = '';
  wrap.appendChild(badge);
  wrap.appendChild(handleE);
  wrap.appendChild(handleS);
  wrap.appendChild(handleXY);

  function updateBadge(){
    const r = wrap.getBoundingClientRect();
    badge.textContent = Math.round(r.width) + 'Ã—' + Math.round(r.height);
  }
  updateBadge();

  let dragging = false;
  let dragMode = 'xy';
  let startX=0, startY=0, startW=0, startH=0;

  const onMove = (e) => {
    if (!dragging) return;
    const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
    const clientY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
    const dx = clientX - startX;
    const dy = clientY - startY;

    const minW = 320, minH = 320;
    const maxW = Math.max(360, window.innerWidth - 60);
    const maxH = Math.max(360, window.innerHeight - 180);

    let targetW = startW;
    let targetH = startH;
    if (dragMode === 'x') targetW = startW + dx;
    else if (dragMode === 'y') targetH = startH + dy;
    else { targetW = startW + dx; targetH = startH + dy; }

    const newW = Math.max(minW, Math.min(maxW, targetW));
    const newH = Math.max(minH, Math.min(maxH, targetH));
wrap.style.width = newW + 'px';
    wrap.style.height = newH + 'px';
    updateBadge();
  };

  const onUp = () => {
    if (!dragging) return;
    dragging = false;
    document.body.style.userSelect = '';
    document.body.style.cursor = '';
    try{
      const r = wrap.getBoundingClientRect();
      localStorage.setItem('kid_canvas_size', JSON.stringify({w: Math.round(r.width), h: Math.round(r.height)}));
    }catch(e){}
    window.removeEventListener('mousemove', onMove);
    window.removeEventListener('mouseup', onUp);
    window.removeEventListener('touchmove', onMove);
    window.removeEventListener('touchend', onUp);
  };

  const onDown = (mode, e) => {
    e.preventDefault();
    dragging = true;
    dragMode = mode || 'xy';
    const r = wrap.getBoundingClientRect();
    startW = r.width; startH = r.height;
    startX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
    startY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
    document.body.style.userSelect = 'none';
    document.body.style.cursor = (mode==='x' ? 'ew-resize' : mode==='y' ? 'ns-resize' : 'nwse-resize');
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    window.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('touchend', onUp);
  };

  const bindHandle = (el, mode) => {
    el.addEventListener('pointerdown', (e)=>onDown(mode,e), {passive:false});
    el.addEventListener('mousedown', (e)=>onDown(mode,e), {passive:false});
    el.addEventListener('touchstart', (e)=>onDown(mode,e), {passive:false});
  };

  bindHandle(handleXY, 'xy');
  bindHandle(handleE, 'x');
  bindHandle(handleS, 'y');

  // Update badge if window resized
  window.addEventListener('resize', ()=>updateBadge());
}


// ===============================
// Kid-friendly i18n + JSON templates
// ===============================
const I18N = {
  en: {
    build: "âœï¸ Build", play: "â–¶ï¸ Play",
    chooseTpl: "ðŸŽ¨ Choose a Template!",
    pickTpl: "Pick one to start building your remote",
    templates: { gamepad:"Game Pad", robot:"Robot", mixer:"DJ Mixer", racing:"Race Car", lights:"Lights", blank:"Start Fresh" },
    buttons: { demo:"ðŸŽ® Try All Widgets!", export:"ðŸ“¦ Export", import:"ðŸ“‚ Import", code:"ðŸ“„ Code" },
    hint: "ðŸ‘† Tap a widget below, then tap the board to place it!",
    propsTitle: "ðŸ› ï¸ Widget Properties",
    propsEmpty: "Select a widget to edit it.",
    connect: "Connect", connected: "Connected",
    runtimeConnectText: "Connect your micro:bit!",
    runtimeConnectBtn: "ðŸ”— Connect",
    toastExport: "ðŸ“¦ Exported JSON!",
    toastImport: "ðŸ“‚ Imported!",
    toastImportFail: "âŒ Import failed"
  },
  fr: {
    build: "âœï¸ Construire", play: "â–¶ï¸ Jouer",
    chooseTpl: "ðŸŽ¨ Choisis un modÃ¨le !",
    pickTpl: "Prends-en un pour commencer",
    templates: { gamepad:"Manette", robot:"Robot", mixer:"DJ Mixer", racing:"Course", lights:"LumiÃ¨res", blank:"Nouveau" },
    buttons: { demo:"ðŸŽ® DÃ©mo widgets !", export:"ðŸ“¦ Export", import:"ðŸ“‚ Import", code:"ðŸ“„ Code" },
    hint: "ðŸ‘† Choisis un widget, puis tape sur le tableau pour le placer !",
    propsTitle: "ðŸ› ï¸ PropriÃ©tÃ©s",
    propsEmpty: "SÃ©lectionne un widget pour lâ€™Ã©diter.",
    connect: "Connecter", connected: "ConnectÃ©",
    runtimeConnectText: "Connecte ton micro:bit !",
    runtimeConnectBtn: "ðŸ”— Connecter",
    toastExport: "ðŸ“¦ JSON exportÃ© !",
    toastImport: "ðŸ“‚ ImportÃ© !",
    toastImportFail: "âŒ Import impossible"
  },
  ar: {
    build: "âœï¸ Ø¨Ù†Ø§Ø¡", play: "â–¶ï¸ ØªØ´ØºÙŠÙ„",
    chooseTpl: "ðŸŽ¨ Ø§Ø®ØªØ± Ù‚Ø§Ù„Ø¨Ù‹Ø§!",
    pickTpl: "Ø§Ø®ØªØ± ÙˆØ§Ø­Ø¯Ù‹Ø§ Ù„Ù„Ø¨Ø¯Ø¡",
    templates: { gamepad:"Ø°Ø±Ø§Ø¹ ØªØ­ÙƒÙ…", robot:"Ø±ÙˆØ¨ÙˆØª", mixer:"Ù…ÙˆØ³ÙŠÙ‚Ù‰", racing:"Ø³Ø¨Ø§Ù‚", lights:"Ø£Ø¶ÙˆØ§Ø¡", blank:"Ø§Ø¨Ø¯Ø£" },
    buttons: { demo:"ðŸŽ® Ø¹Ø±Ø¶ ÙƒÙ„ Ø§Ù„Ø£Ø¯ÙˆØ§Øª!", export:"ðŸ“¦ ØªØµØ¯ÙŠØ±", import:"ðŸ“‚ Ø§Ø³ØªÙŠØ±Ø§Ø¯", code:"ðŸ“„ Ø§Ù„ÙƒÙˆØ¯" },
    hint: "ðŸ‘† Ø§Ø®ØªØ± Ø£Ø¯Ø§Ø©ØŒ Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø© Ù„ÙˆØ¶Ø¹Ù‡Ø§!",
    propsTitle: "ðŸ› ï¸ Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø£Ø¯Ø§Ø©",
    propsEmpty: "Ø§Ø®ØªØ± Ø£Ø¯Ø§Ø© Ù„ØªØ¹Ø¯ÙŠÙ„Ù‡Ø§.",
    connect: "Ø§ØªØµØ§Ù„", connected: "Ù…ØªØµÙ„",
    runtimeConnectText: "Ø§ØªØµÙ„ Ø¨Ø§Ù„Ù€ micro:bit!",
    runtimeConnectBtn: "ðŸ”— Ø§ØªØµØ§Ù„",
    toastExport: "ðŸ“¦ ØªÙ… Ø§Ù„ØªØµØ¯ÙŠØ±!",
    toastImport: "ðŸ“‚ ØªÙ… Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯!",
    toastImportFail: "âŒ ÙØ´Ù„ Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯"
  }
};

const LANGS = ["en","fr","ar"];
const LANG_ICON = { en:"ðŸ‡¬ðŸ‡§", fr:"ðŸ‡«ðŸ‡·", ar:"ðŸ‡©ðŸ‡¿" };
const LANG_NAME = { en:"English", fr:"FranÃ§ais", ar:"Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©" };

function saveLang() { try { localStorage.setItem("kid_lang", state.lang); } catch(e){} }
function loadLang() { try { return localStorage.getItem("kid_lang"); } catch(e){ return null; } }
function detectBrowserLang(){
  const n = String(navigator.language || "en").toLowerCase();
  if (n.startsWith("fr")) return "fr";
  if (n.startsWith("ar")) return "ar";
  return "en";
}

function setLang(lang){
  state.lang = LANGS.includes(lang) ? lang : "en";
  saveLang();
  const t = I18N[state.lang] || I18N.en;

  document.documentElement.lang = state.lang;
  const rtl = (state.lang === "ar");
  document.documentElement.dir = rtl ? "rtl" : "ltr";
  document.body.classList.toggle("rtl", rtl);

  // Tabs
  const tabs = $$(".tab");
  if (tabs[0]) tabs[0].textContent = t.build;
  if (tabs[1]) tabs[1].textContent = t.play;

  // Top buttons
  const langBtn = $("#langBtn");
  if (langBtn){
    const s = langBtn.querySelector("span:last-child");
    if (s) s.textContent = LANG_ICON[state.lang] || "ðŸŒ";
    langBtn.title = "Language: " + (LANG_NAME[state.lang] || state.lang);
  }

  const bleBtn = $("#bleBtn");
  if (bleBtn){
    const s = bleBtn.querySelector("span:last-child");
    if (s) s.textContent = (state.ble && state.ble.connected) ? t.connected : t.connect;
  }

  // Builder header buttons
  const demoBtn = $("#demoBtn"); if (demoBtn) demoBtn.textContent = t.buttons.demo;
  const exportBtn = $("#exportJsonBtn"); if (exportBtn) exportBtn.textContent = t.buttons.export;
  const importBtn = $("#importJsonBtn"); if (importBtn) importBtn.textContent = t.buttons.import;
  const codeBtn = $("#codeBtn"); if (codeBtn) codeBtn.textContent = t.buttons.code;

  // Hint
  const hint = document.querySelector(".canvas-hint");
  if (hint) hint.textContent = t.hint;

  // Props panel
  const pt = document.querySelector(".props-title"); if (pt) pt.textContent = t.propsTitle;
  const pe = $("#propsEmpty"); if (pe) pe.textContent = t.propsEmpty;

  // Template modal
  const tm = $("#templateModal");
  if (tm){
    const h2 = tm.querySelector("h2"); if (h2) h2.textContent = t.chooseTpl;
    const p = tm.querySelector("p"); if (p) p.textContent = t.pickTpl;
    tm.querySelectorAll(".template-card").forEach(card=>{
      const key = card.dataset.tpl;
      const nameEl = card.querySelector(".template-name");
      if (nameEl && t.templates[key]) nameEl.textContent = t.templates[key];
    });
  }

  // Runtime connect screen
  const ct = document.querySelector(".connect-text"); if (ct) ct.textContent = t.runtimeConnectText;
  const cb = $("#connectBtn"); if (cb) cb.textContent = t.runtimeConnectBtn;
}

function cycleLang(){
  const i = LANGS.indexOf(state.lang || "en");
  const next = LANGS[(i + 1) % LANGS.length];
  setLang(next);
  if (typeof toast === "function") toast((LANG_ICON[next]||"ðŸŒ") + " " + (LANG_NAME[next]||next), "success");
}

// ---- Export / Import JSON layout ----
function exportLayoutJson(){
  const t = I18N[state.lang] || I18N.en;
  if (!state.widgets || state.widgets.length === 0){
    if (typeof toast === "function") toast("ðŸ‘† Add some widgets first!", "error");
    return;
  }
  const title = ($("#titleInput") && $("#titleInput").value) ? $("#titleInput").value : "My Remote";
  const cfg = { schemaVersion: 1, title: title, widgets: state.widgets };

  const blob = new Blob([JSON.stringify(cfg, null, 2)], { type: "application/json" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  const safe = String(title).toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,"");
  a.download = (safe || "my-remote") + ".json";
  a.click();

  if (typeof toast === "function") toast(t.toastExport, "success");
}

function importLayoutJsonFile(file){
  const t = I18N[state.lang] || I18N.en;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const cfg = JSON.parse(String(reader.result || "{}"));
      if (!cfg || !Array.isArray(cfg.widgets)) throw new Error("Bad format");
      state.widgets = cfg.widgets.map(w => ({...w}));
      // Recompute nextId safely
      let maxNum = 0;
      state.widgets.forEach(w=>{
        const m = String(w.id||"").match(/(\d+)$/);
        if (m) maxNum = Math.max(maxNum, parseInt(m[1],10));
      });
      state.nextId = Math.max(10, maxNum + 1);
      if ($("#titleInput")) $("#titleInput").value = cfg.title || "My Remote";
      if (typeof applyWidgetDefaults === "function") state.widgets.forEach(applyWidgetDefaults);
      state.selected = null;
      if (typeof renderWidgets === "function") renderWidgets();
      try{ ensureCanvasToolbar(); }catch(e){}
try{ placeToolbarWhereHintWas(); }catch(e){}
  try{ updateToolbarForMode('builder'); }catch(e){}
try{ placeToolbarWhereHintWas(); }catch(e){}
try{ moveBuildPlayNameTopRight(); }catch(e){}
makeCanvasResizable();
if (typeof renderPropsPanel === "function") renderPropsPanel();
      if (typeof toast === "function") toast(t.toastImport, "success");
    } catch(e){
      console.error(e);
      if (typeof toast === "function") toast(t.toastImportFail, "error");
    }
  };
  reader.readAsText(file);
}


const ICONS = { button:'ðŸ‘†', slider:'ðŸŽšï¸', toggle:'ðŸ”˜', joystick:'ðŸ•¹ï¸', led:'ðŸ’¡', label:'ðŸ·ï¸', graph:'ðŸ“ˆ', gauge:'ðŸ§­', dpad:'âœ›', xypad:'ðŸ“', battery:'ðŸ”‹', timer:'â±ï¸', image:'ðŸ–¼ï¸' };
const SIZES = { button:[100,100], slider:[90,180], toggle:[100,100], joystick:[140,140], led:[80,80], label:[200,50], graph:[300,150], gauge:[140,160], dpad:[140,140], xypad:[150,150], battery:[80,100], timer:[120,80], image:[100,100] };

// Themes
const THEMES = {
  dark: { bg:'#1a1a2e', surface:'#16213e', card:'#1f3460', accent:'#00d4ff', text:'#ffffff' },
  light: { bg:'#f0f4f8', surface:'#ffffff', card:'#e2e8f0', accent:'#3b82f6', text:'#1e293b' },
  neon: { bg:'#0a0a0a', surface:'#1a1a1a', card:'#2a2a2a', accent:'#ff00ff', text:'#00ffff' },
  nature: { bg:'#1a2f1a', surface:'#2d4a2d', card:'#3d5a3d', accent:'#4ade80', text:'#ecfdf5' },
  sunset: { bg:'#2d1b2d', surface:'#4a2c4a', card:'#6b3a6b', accent:'#f97316', text:'#fef3c7' }
};

const templates = {
  gamepad: [
    { t:'joystick', x:20, y:30, w:120, h:120, label:'Move' },
    { t:'button', x:180, y:40, w:90, h:90, label:'Jump' },
    { t:'button', x:290, y:40, w:90, h:90, label:'Fire' },
    { t:'toggle', x:180, y:160, w:90, h:90, label:'Turbo' }
  ],
  robot: [
    { t:'slider', x:20, y:20, w:90, h:180, label:'Arm 1' },
    { t:'slider', x:130, y:20, w:90, h:180, label:'Arm 2' },
    { t:'slider', x:240, y:20, w:90, h:180, label:'Arm 3' },
    { t:'toggle', x:350, y:80, w:90, h:90, label:'Grip' }
  ],
  mixer: [
    { t:'slider', x:20, y:20, w:80, h:200, label:'Bass' },
    { t:'slider', x:120, y:20, w:80, h:200, label:'Mid' },
    { t:'slider', x:220, y:20, w:80, h:200, label:'High' },
    { t:'toggle', x:320, y:80, w:90, h:90, label:'FX' },
    { t:'led', x:320, y:20, w:90, h:50, label:'Beat' }
  ],
  racing: [
    { t:'joystick', x:150, y:20, w:130, h:130, label:'Steer' },
    { t:'slider', x:20, y:170, w:80, h:140, label:'Gas' },
    { t:'slider', x:330, y:170, w:80, h:140, label:'Brake' },
    { t:'button', x:150, y:180, w:130, h:80, label:'Nitro!' }
  ],
  lights: [
    { t:'toggle', x:30, y:30, w:100, h:100, label:'Red' },
    { t:'toggle', x:160, y:30, w:100, h:100, label:'Green' },
    { t:'toggle', x:290, y:30, w:100, h:100, label:'Blue' },
    { t:'led', x:90, y:160, w:100, h:100, label:'Status' },
    { t:'led', x:230, y:160, w:100, h:100, label:'Alert' }
  ],
  blank: []
};

const state = {
  widgets: [], selected: null, nextId: 1, selectedType: null,
  ble: { device:null, server:null, service:null, notifyChar:null, writeChar:null, connected:false },
  config: null, values: {}, rxBuffer: '',
  justDragged: false, _dragT: null,
  // New features
  multiSelect: [], clipboard: [], undoStack: [], maxUndo: 50, redoStack: [],
  zoom: 1, gridSnap: true, gridSize: 20, showGuides: true,
  // More features
  theme: 'dark',
  groups: {}, // groupId -> [widgetIds]
  widgetTemplates: [], // saved widget groups
  showLayers: false,
  showRuler: false,
  livePreview: true,
  canvasBg: null, // background image
  history: [], // visual history
  arrangeMode: false // runtime arrange mode
};
state._allowLoadingOverlay = false;

// === AUTO-SAVE / LOAD PROJECT ===
const PROJECT_STORAGE_KEY = 'microbit_remote_project';

function saveProject() {
  try {
    const titleEl = document.querySelector('#titleInput');
    const projectData = {
      widgets: state.widgets,
      nextId: state.nextId,
      title: titleEl ? titleEl.value : '',
      canvasBg: state.canvasBg,
      theme: state.theme,
      savedAt: Date.now()
    };
    localStorage.setItem(PROJECT_STORAGE_KEY, JSON.stringify(projectData));
  } catch (e) {
    console.warn('Failed to save project:', e);
  }
}

function loadSavedProject() {
  try {
    const saved = localStorage.getItem(PROJECT_STORAGE_KEY);
    if (!saved) return false;
    
    const projectData = JSON.parse(saved);
    if (!projectData.widgets || projectData.widgets.length === 0) return false;
    
    // Restore state
    state.widgets = projectData.widgets.map(w => {
      if (typeof applyWidgetDefaults === 'function') return applyWidgetDefaults({...w});
      return {...w};
    });
    state.nextId = projectData.nextId || (state.widgets.length + 1);
    state.canvasBg = projectData.canvasBg || null;
    if (projectData.theme) state.theme = projectData.theme;
    
    // Restore title after DOM is ready
    setTimeout(() => {
      const titleEl = document.querySelector('#titleInput');
      if (titleEl && projectData.title) titleEl.value = projectData.title;
      
      // Apply canvas background if saved
      if (state.canvasBg) {
        const canvas = document.querySelector('#canvas');
        if (canvas) {
          canvas.style.backgroundImage = `url(${state.canvasBg})`;
          canvas.style.backgroundSize = 'cover';
          canvas.style.backgroundPosition = 'center';
        }
      }
    }, 50);
    
    return true;
  } catch (e) {
    console.warn('Failed to load project:', e);
    return false;
  }
}

function clearSavedProject() {
  try {
    localStorage.removeItem(PROJECT_STORAGE_KEY);
  } catch (e) {}
}

// Auto-save with debounce
let _autoSaveTimer = null;
function scheduleAutoSave() {
  if (_autoSaveTimer) clearTimeout(_autoSaveTimer);
  _autoSaveTimer = setTimeout(() => {
    saveProject();
  }, 500);
}

// ---- Kid-friendly sound engine (WebAudio) ----
state.soundOn = true;
state._audio = { ctx: null, unlocked: false };
state._gaugeLast = state._gaugeLast || {};

function ensureAudio() {
  if (!state.soundOn) return null;
  if (state._audio.ctx) return state._audio.ctx;
  try {
    const Ctx = window.AudioContext || window.webkitAudioContext;
    state._audio.ctx = new Ctx();
    return state._audio.ctx;
  } catch (e) { return null; }
}

function unlockAudioOnce() {
  const ctx = ensureAudio();
  if (!ctx) return;
  if (ctx.state === 'suspended') ctx.resume().catch(()=>{});
  state._audio.unlocked = true;
}

document.addEventListener('pointerdown', () => unlockAudioOnce(), { once: true });

function beep(freq=880, dur=0.06, vol=0.05, type='sine') {
  if (!state.soundOn) return;
  const ctx = ensureAudio();
  if (!ctx) return;
  if (ctx.state === 'suspended') ctx.resume().catch(()=>{});
  const o = ctx.createOscillator();
  const g = ctx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g); g.connect(ctx.destination);
  const t = ctx.currentTime;
  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(vol, t + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
  o.start(t);
  o.stop(t + dur + 0.02);
}
// Sound patterns
function beepClick(){ beep(880, 0.05, 0.05, 'sine'); }
function beepToggle(on){ beep(on?1046:659, 0.06, 0.05, 'square'); }
function beepWarn(){ beep(523, 0.09, 0.06, 'triangle'); setTimeout(()=>beep(659,0.09,0.05,'triangle'), 110); }
function beepDanger(){ beep(330, 0.10, 0.07, 'sawtooth'); setTimeout(()=>beep(330,0.10,0.07,'sawtooth'), 130); }
function beepSuccess(){ beep(523, 0.08, 0.05, 'sine'); setTimeout(()=>beep(659,0.08,0.05,'sine'), 100); setTimeout(()=>beep(784,0.12,0.05,'sine'), 200); }

// Sound UI
function updateSoundUI(){
  const b = $('#soundBtn');
  if (!b) return;
  b.classList.toggle('connected', state.soundOn);
  b.querySelector('span:last-child').textContent = state.soundOn ? 'Sound On' : 'Sound Off';
  b.style.opacity = state.soundOn ? '1' : '0.7';
}



// Ensure older configs/templates still look good when new properties are added
function applyWidgetDefaults(w){
  if (!w || !w.t) return w;

  // Default models (3 per widget type)
  if (!w.model){
    if (w.t === 'button') w.model = 'neo';
    if (w.t === 'slider') w.model = 'track';
    if (w.t === 'toggle') w.model = 'square';
    if (w.t === 'led') w.model = 'dot';
    if (w.t === 'joystick') w.model = 'classic';
    if (w.t === 'label') w.model = 'plain';
    if (w.t === 'gauge') w.model = 'classic';
    if (w.t === 'graph') w.model = 'grid';
  }

  // Existing per-type defaults
  if (w.t === 'led'){
    if (!w.colorOn) w.colorOn = '#ff5252';
    if (!w.colorOff) w.colorOff = '#2a2a3a';
  }
  if (w.t === 'slider'){
    if (w.min == null) w.min = 0;
    if (w.max == null) w.max = 100;
    if (w.step == null) w.step = 1;
  }

  // Gauge defaults
  if (w.t === 'gauge'){
    if (w.min == null) w.min = 0;
    if (w.max == null) w.max = 100;
    if (w.decimals == null) w.decimals = 1;
    if (w.units == null) w.units = '';
    if (w.warn == null) w.warn = null;   // optional threshold
    if (w.danger == null) w.danger = null;
  }

  // Graph defaults (comma-separated multi-series values: "23.4,2.1")
  if (w.t === 'graph'){
    if (w.series == null) w.series = 1;      // 1..10
    if (w.windowSec == null) w.windowSec = 30; // visible time window
    if (w.autoScale == null) w.autoScale = true;
    if (w.min == null) w.min = 0;
    if (w.max == null) w.max = 100;
    if (w.showLegend == null) w.showLegend = true;
  }

  return w;
}

function modelOptionsForType(t){
  switch(t){
    case 'button': return [
      { v:'neo',   name:'Neo (gradient)' },
      { v:'flat',  name:'Flat' },
      { v:'glass', name:'Glass' }
    ];
    case 'slider': return [
      { v:'track', name:'Track' },
      { v:'neon',  name:'Neon' },
      { v:'min',   name:'Minimal' }
    ];
    case 'toggle': return [
      { v:'square', name:'Square' },
      { v:'pill',   name:'Pill' },
      { v:'icon',   name:'Icon' }
    ];
    case 'led': return [
      { v:'dot',  name:'Dot' },
      { v:'bar',  name:'Bar' },
      { v:'ring', name:'Ring' }
    ];
    case 'joystick': return [
      { v:'classic', name:'Classic' },
      { v:'neon',    name:'Neon' },
      { v:'min',     name:'Minimal' }
    ];
    case 'label': return [
      { v:'plain', name:'Plain' },
      { v:'card',  name:'Card' },
      { v:'glow',  name:'Glow' }
    ];
    case 'gauge': return [
      { v:'classic', name:'Classic' },
      { v:'neon',    name:'Neon' },
      { v:'min',     name:'Minimal' }
    ];
    case 'graph': return [
      { v:'grid',    name:'Grid' },
      { v:'dark',    name:'Dark' },
      { v:'min',     name:'Minimal' }
    ];
    default: return null;
  }
}

// BLE Write Queue - ensures only ONE GATT operation at a time
// This prevents "GATT operation failed" errors from concurrent writes
const bleSend = {
  isWriting: false,     // Lock: true while a write is in progress
  pendingMsg: null,     // Latest message waiting to be sent (replaces previous)
  minInterval: 200,     // Minimum ms between writes for BLE stability
  lastSendTime: 0,      // Timestamp of last successful send
  retryCount: 0,        // Track consecutive failures
  maxRetries: 3         // Max retries before giving up on a message
};

// The actual low-level BLE write - MUST be awaited and serialized
async function bleWrite(msg) {
  if (!state.ble.writeChar || !state.ble.device?.gatt?.connected) {
    console.log('[BLE] Not connected, skipping:', msg);
    return false;
  }
  
  try {
    const data = encoder.encode(msg + '\n');
    
    // Use writeValueWithoutResponse (faster, but still must be serialized!)
    if (state.ble.writeChar.writeValueWithoutResponse) {
      await state.ble.writeChar.writeValueWithoutResponse(data);
    } else {
      await state.ble.writeChar.writeValue(data);
    }
    
    console.log('[BLE] Sent:', msg);
    bleSend.retryCount = 0; // Reset on success
    return true;
  } catch (err) {
    console.error('[BLE] Write failed:', err.message);
    
    // Check if it's a disconnect error
    if (err.message?.includes('disconnected') || err.message?.includes('GATT Server')) {
      onDisconnect();
      return false;
    }
    
    // For GATT operation errors, we can retry
    bleSend.retryCount++;
    if (bleSend.retryCount >= bleSend.maxRetries) {
      console.warn('[BLE] Max retries reached, dropping message');
      bleSend.retryCount = 0;
    }
    return false;
  }
}

// Process the write queue - ensures serialized GATT operations
async function processWriteQueue() {
  // If already writing, exit - the current write will pick up pending
  if (bleSend.isWriting) return;
  
  // Nothing to send
  if (!bleSend.pendingMsg) return;
  
  // Check minimum interval
  const now = Date.now();
  const timeSinceLastSend = now - bleSend.lastSendTime;
  if (timeSinceLastSend < bleSend.minInterval) {
    // Schedule next attempt
    setTimeout(processWriteQueue, bleSend.minInterval - timeSinceLastSend + 5);
    return;
  }
  
  // Lock, grab message, clear pending
  bleSend.isWriting = true;
  const msg = bleSend.pendingMsg;
  bleSend.pendingMsg = null;
  
  try {
    await bleWrite(msg);
    bleSend.lastSendTime = Date.now();
  } finally {
    // Always unlock
    bleSend.isWriting = false;
    
    // If new message arrived while we were writing, process it
    if (bleSend.pendingMsg) {
      // Small delay to respect minimum interval
      setTimeout(processWriteQueue, bleSend.minInterval);
    }
  }
}

// Public send function - queues message and triggers processing
function send(msg) {
  if (!state.ble.connected) return;
  
  // Sanitize
  msg = String(msg || '').replace(/[\r\n]+/g, '').trim();
  if (!msg) return;
  
  // Always update pending (latest value wins for continuous controls like joystick)
  bleSend.pendingMsg = msg;
  
  // Trigger queue processing (will respect lock and interval)
  processWriteQueue();
}

// One-click Demo - creates full showcase with all widgets
function showDemo() {
  // Create a demo with ALL widget types
  state.widgets = [
    { id: 'btn_jump', t: 'button', x: 20, y: 20, w: 100, h: 100, label: 'Jump!', model:'neo' },
    { id: 'btn_fire', t: 'button', x: 140, y: 20, w: 100, h: 100, label: 'Fire!', model:'glass' },
    { id: 'slider_speed', t: 'slider', x: 260, y: 20, w: 90, h: 180, label: 'Speed', model:'track', min:0, max:100, step:1 },
    { id: 'slider_power', t: 'slider', x: 370, y: 20, w: 90, h: 180, label: 'Power', model:'neon', min:0, max:100, step:1 },
    { id: 'toggle_turbo', t: 'toggle', x: 20, y: 140, w: 100, h: 100, label: 'Turbo', model:'pill' },
    { id: 'toggle_shield', t: 'toggle', x: 140, y: 140, w: 100, h: 100, label: 'Shield', model:'icon' },
    { id: 'joy_move', t: 'joystick', x: 20, y: 260, w: 140, h: 140, label: 'Move', model:'ring' },
    { id: 'led_status', t: 'led', x: 180, y: 260, w: 100, h: 100, label: 'Status', model:'dot', colorOn:'#00e676', colorOff:'#1b2a3a' },
    { id: 'led_alert', t: 'led', x: 300, y: 260, w: 100, h: 100, label: 'Alert', model:'ring', colorOn:'#ff5252', colorOff:'#1b2a3a' },
    { id: 'label_score', t: 'label', x: 180, y: 380, w: 220, h: 50, label: 'Score: 0', model:'chip' },

    { id: 'gauge_temp', t: 'gauge', x: 20, y: 430, w: 150, h: 170, label: 'Temp', min: 0, max: 50, units: 'Â°C', decimals: 1, model:'classic' },
    { id: 'gauge_level', t: 'gauge', x: 190, y: 430, w: 150, h: 170, label: 'Level', min: 0, max: 100, units: '%', decimals: 0, model:'neon' },
    { id: 'graph_env', t: 'graph', x: 20, y: 610, w: 370, h: 170, label: 'Online Graph', series: 2, windowSec: 30, autoScale: true, model:'grid' }
  ];
  state.widgets = state.widgets.map(applyWidgetDefaults);
  state.nextId = 20;
  state.selected = null;
  $('#titleInput').value = 'Super Demo Remote';
  renderWidgets();
  renderPropsPanel();
  
  // Show the code modal with demo code
  const cfg = { title: 'Super Demo Remote', widgets: state.widgets };
  // Load demo into runtime immediately (no micro:bit required)
  state.config = cfg;
  state.values = state.values || {};
  renderRuntime();
  startDemoSim();
  
  // Show arrange button in demo mode
  const arrangeBtn = $('#arrangeModeBtn');
  if (arrangeBtn) arrangeBtn.classList.add('visible');
  
  // Show fullscreen button in demo mode
  const fullscreenBtn = $('#fullscreenBtn');
  if (fullscreenBtn) fullscreenBtn.classList.add('visible');
  
  // Show runtime content
  $('#connectPrompt').style.display = 'none';
  $('#runtimeContent').style.display = 'flex';
  
  $('#modalTitle').textContent = 'Demo Ready! Copy this code to MakeCode:';
  $('#modalCode').textContent = generateDemoCode(cfg);
  $('#modalBg').classList.add('show');
  
  toast('Demo loaded with ALL widgets!', 'success');
}

function generateDemoCode(cfg) {
  // Unicode-safe base64 encoding (handles emojis!)
  const b64 = btoa(unescape(encodeURIComponent(JSON.stringify(cfg))));
  
  // Group widgets by type
  const buttons = cfg.widgets.filter(w => w.t === 'button');
  const sliders = cfg.widgets.filter(w => w.t === 'slider');
  const toggles = cfg.widgets.filter(w => w.t === 'toggle');
  const joysticks = cfg.widgets.filter(w => w.t === 'joystick');
  const dpads = cfg.widgets.filter(w => w.t === 'dpad');
  const xypads = cfg.widgets.filter(w => w.t === 'xypad');
  const timers = cfg.widgets.filter(w => w.t === 'timer');
  const leds = cfg.widgets.filter(w => w.t === 'led');
  const labels = cfg.widgets.filter(w => w.t === 'label');
  const gauges = cfg.widgets.filter(w => w.t === 'gauge');
  const graphs = cfg.widgets.filter(w => w.t === 'graph');
  
  // Generate handler code for each widget
  let buttonCode = buttons.map(w => `    // Button: ${w.label || w.id}
    if (id == "${w.id}" && val == "1") {
        basic.showIcon(IconNames.Heart)
        // Add your code here!
    }`).join('\n');
  
  let sliderCode = sliders.map(w => `    // Slider: ${w.label || w.id} (val = 0-100)
    if (id == "${w.id}") {
        let value = parseInt(val)
        led.plotBarGraph(value, 100)
        // Use value for motors, sounds, etc!
    }`).join('\n');
  
  let toggleCode = toggles.map(w => `    // Toggle: ${w.label || w.id} (val = "1" or "0")
    if (id == "${w.id}") {
        if (val == "1") {
            basic.showIcon(IconNames.Yes)
        } else {
            basic.showIcon(IconNames.No)
        }
    }`).join('\n');
  
  let joystickCode = joysticks.map(w => `    // Joystick: ${w.label || w.id} (val = "angle distance", angle 0-360, distance 0-100)
    if (id == "${w.id}") {
        let parts = val.split(" ")
        let angle = parseInt(parts[0])  // 0-360 degrees (0=right, 90=down, 180=left, 270=up)
        let dist = parseInt(parts[1])   // 0-100 (0=center, 100=edge)
        // Use for steering, movement, etc!
        if (dist > 10) {
            if (angle < 45 || angle >= 315) basic.showArrow(ArrowNames.East)
            else if (angle < 135) basic.showArrow(ArrowNames.South)
            else if (angle < 225) basic.showArrow(ArrowNames.West)
            else basic.showArrow(ArrowNames.North)
        } else {
            basic.showIcon(IconNames.SmallDiamond)
        }
    }`).join('\n');

  let dpadCode = dpads.map(w => `    // D-Pad: ${w.label || w.id} (val = "direction state", direction: up/down/left/right, state: 1=pressed, 0=released)
    if (id == "${w.id}") {
        let parts = val.split(" ")
        let dir = parts[0]
        let pressed = parts[1] == "1"
        if (pressed) {
            if (dir == "up") basic.showArrow(ArrowNames.North)
            else if (dir == "down") basic.showArrow(ArrowNames.South)
            else if (dir == "left") basic.showArrow(ArrowNames.West)
            else if (dir == "right") basic.showArrow(ArrowNames.East)
        }
    }`).join('\n');

  let xypadCode = xypads.map(w => `    // XY Pad: ${w.label || w.id} (val = "x y", both 0-100)
    if (id == "${w.id}") {
        let parts = val.split(" ")
        let x = parseInt(parts[0])  // 0-100 (0=left, 100=right)
        let y = parseInt(parts[1])  // 0-100 (0=top, 100=bottom)
        // Plot position on LED matrix
        led.plot(Math.floor(x / 25), Math.floor(y / 25))
        basic.pause(100)
        basic.clearScreen()
    }`).join('\n');

  let timerCode = timers.map(w => `    // Timer: ${w.label || w.id} (val = seconds elapsed)
    if (id == "${w.id}") {
        let secs = parseInt(val)
        // Do something with timer value
        serial.writeLine("Timer: " + secs + "s")
    }`).join('\n');

  let ledList = leds.map(w => `//   sendValue("${w.id}", "1")  // Turn ON ${w.label || 'LED'}
//   sendValue("${w.id}", "0")  // Turn OFF`).join('\n');

  let labelList = labels.map(w => `//   sendValue("${w.id}", "Hello!")  // Update ${w.label || 'label'}`).join('\n');

  return `// ${cfg.title} - micro:bit Remote
// Copy this to MakeCode: https://makecode.microbit.org
// Then flash it to your micro:bit!

bluetooth.startUartService()
let cfgSent = false
let blinkState = false
const CFG = "${b64}"

// This sends the remote layout to the app
bluetooth.onUartDataReceived(serial.delimiters(Delimiters.NewLine), function() {
    let cmd = bluetooth.uartReadUntil(serial.delimiters(Delimiters.NewLine))
    
    if (cmd == "GETCFG") {
        bluetooth.uartWriteLine("CFGBEGIN")
        for (let i = 0; i < CFG.length; i += 18) {
            bluetooth.uartWriteLine("CFG " + CFG.substr(i, 18))
        }
        bluetooth.uartWriteLine("CFGEND")
        cfgSent = true
        basic.showIcon(IconNames.Yes)
    } 
    else if (cmd.indexOf("SET ") == 0) {
        let parts = cmd.substr(4).split(" ")
        let id = parts[0]
        let val = parts.slice(1).join(" ")
        handleWidget(id, val)
    }
})

// HANDLE YOUR WIDGETS HERE!
function handleWidget(id: string, val: string) {
    serial.writeLine(id + " = " + val)
    
${buttonCode || '    // No buttons in this remote'}

${sliderCode || '    // No sliders in this remote'}

${toggleCode || '    // No toggles in this remote'}

${joystickCode || '    // No joysticks in this remote'}

${dpadCode || '    // No D-Pads in this remote'}

${xypadCode || '    // No XY Pads in this remote'}

${timerCode || '    // No timers in this remote'}
}

// Send values TO the app (for LEDs and Labels)
function sendValue(id: string, val: string) {
    if (cfgSent) bluetooth.uartWriteLine("UPD " + id + " " + val)
}

// Show we are ready!
basic.showIcon(IconNames.Heart)

// BLINK THE APP LEDs! This runs forever in background
basic.forever(function() {
    if (cfgSent) {
        blinkState = !blinkState
        ${leds.length > 0 ? leds.map(l => `sendValue("${l.id}", blinkState ? "1" : "0")`).join('\n        ') : '// No LEDs to blink'}
        ${labels.length > 0 ? `sendValue("${labels[0].id}", blinkState ? "ON!" : "OFF")` : ''}
        // Demo updates for Gauges (single value) and Graphs (comma-separated)
        let t = input.runningTime()
        ${gauges.length > 0 ? gauges.map((g,i)=>`sendValue("${g.id}", "" + (Math.round((Math.sin((t/1000)+${i}) + 1) * 25)))`).join("\n        ") : "// No gauges to update"}
        ${graphs.length > 0 ? graphs.map((g,i)=>`sendValue("${g.id}", "" + (Math.round((Math.sin((t/900)+${i}) + 1) * 50)) + "," + (Math.round((Math.cos((t/1100)+${i}) + 1) * 50)))`).join("\n        ") : "// No graphs to update"}
    }
    basic.pause(200)
})

// BONUS: Use micro:bit buttons too!
input.onButtonPressed(Button.A, function() {
    basic.showString("A")
    ${leds.length > 0 ? `sendValue("${leds[0].id}", "1")` : '// Add an LED to control it here!'}
})
input.onButtonPressed(Button.B, function() {
    basic.showString("B")
    ${leds.length > 0 ? `sendValue("${leds[0].id}", "0")` : '// Add an LED to control it here!'}
})`;
}

function init() {
  try{ ensureCanvasToolbar(); }catch(e){}

  try{ placeToolbarWhereHintWas(); }catch(e){}
try{ placeToolbarWhereHintWas(); }catch(e){}
// keep controls at top-right
  try{ moveBuildPlayNameTopRight(); }catch(e){}

  const builderHeader = document.querySelector('.builder-header');
  if (builderHeader && builderHeader.children.length === 0) {
    builderHeader.style.display = 'none';
  }

  state._allowLoadingOverlay = false;
  if (typeof hideLoading === 'function') hideLoading();
  
  // Mobile props panel handling
  const propsPanel = $('#propsPanel');
  const propsPanelClose = $('#propsPanelClose');
  const isMobile = () => window.innerWidth <= 600;
  
  window.showMobilePropsPanel = function() {
    if (isMobile() && propsPanel) {
      propsPanel.classList.add('show-mobile');
    }
  };
  window.hideMobilePropsPanel = function() {
    if (propsPanel) {
      propsPanel.classList.remove('show-mobile');
    }
  };
  
  if (propsPanelClose) {
    propsPanelClose.onclick = (e) => {
      e.stopPropagation();
      hideMobilePropsPanel();
      state.selected = null;
      state.multiSelect = [];
      renderWidgets();
    };
  }
  
  // Tabs
  $$('.tab').forEach(t => t.onclick = () => switchTab(t.dataset.tab));
  
  // Templates
  $$('.template-card').forEach(c => c.onclick = () => selectTemplate(c.dataset.tpl));
  
  // Palette - tap to select
  $$('.palette-item').forEach(p => {
    p.onclick = () => {
      $$('.palette-item').forEach(x => x.classList.remove('selected'));
      p.classList.add('selected');
      state.selectedType = p.dataset.type;
      toast(`âœ… ${ICONS[state.selectedType]} selected! Tap canvas to place`, 'success');
    };
  });

  // Collapsible cards
  function setupCollapsibleCard(cardSel, toggleSel, bodySel, storageKey, opts = {}) {
    const card = $(cardSel);
    const toggle = $(toggleSel);
    const body = $(bodySel);
    if (!card || !toggle || !body) return;

    const setCollapsed = (collapsed) => {
      card.classList.toggle('collapsed', collapsed);
      toggle.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
      body.setAttribute('aria-hidden', collapsed ? 'true' : 'false');
    };

    let collapsed = !!opts.defaultCollapsed;
    try{
      const saved = localStorage.getItem(storageKey);
      if (saved !== null) collapsed = saved === '1';
    }catch(e){}
    setCollapsed(collapsed);

    toggle.onclick = () => {
      if (opts.disableOnMobile && window.innerWidth <= 600) return;
      const next = !card.classList.contains('collapsed');
      setCollapsed(next);
      try{ localStorage.setItem(storageKey, next ? '1' : '0'); }catch(e){}
    };
  }

  setupCollapsibleCard('#actionsCard', '#actionsToggle', '#actionsBody', 'actionsCollapsed');
  setupCollapsibleCard('#paletteCard', '#paletteToggle', '#paletteBody', 'paletteCollapsed');

  // Properties panel collapse (desktop)
  const propsCollapseBtn = $('#propsCollapseBtn');
  if (propsPanel && propsCollapseBtn) {
    const setPropsCollapsed = (collapsed) => {
      propsPanel.classList.toggle('collapsed', collapsed);
      propsCollapseBtn.textContent = collapsed ? '+' : 'â€“';
      propsCollapseBtn.title = collapsed ? 'Expand' : 'Collapse';
    };
    try{
      const saved = localStorage.getItem('propsCollapsed');
      if (saved !== null) setPropsCollapsed(saved === '1');
    }catch(e){}
    propsCollapseBtn.onclick = () => {
      const next = !propsPanel.classList.contains('collapsed');
      setPropsCollapsed(next);
      try{ localStorage.setItem('propsCollapsed', next ? '1' : '0'); }catch(e){}
    };
  }
  
  // Canvas - tap to place + selection box
  const canvas = $('#canvas');
  let isDrawingSelBox = false;
  
  canvas.onmousedown = e => {
    if (e.target.closest('.widget') || e.target.closest('.canvas-tool-btn') || e.target.closest('.zoom-btn')) return;
    if (e.shiftKey) {
      isDrawingSelBox = true;
      startSelectionBox(e);
    }
  };
  
  canvas.onmousemove = e => {
    if (isDrawingSelBox) updateSelectionBox(e);
  };
  
  canvas.onmouseup = e => {
    if (isDrawingSelBox) {
      endSelectionBox();
      isDrawingSelBox = false;
    }
  };
  
  canvas.onclick = e => {
    if (e.target.closest('.widget') || e.target.closest('.canvas-tool-btn') || e.target.closest('.zoom-btn') || e.target.closest('.minimap')) return;
    if (state.selectedType) {
      saveUndoState();
      const rect = canvas.getBoundingClientRect();
      const [w, h] = SIZES[state.selectedType];
      let x = Math.max(0, Math.min(e.clientX - rect.left - w/2, rect.width - w));
      let y = Math.max(0, Math.min(e.clientY - rect.top - h/2, rect.height - h));
      if (state.gridSnap) { x = snapToGrid(x); y = snapToGrid(y); }
      const base = applyWidgetDefaults({ id: `${state.selectedType}${state.nextId++}`, t: state.selectedType, x, y, w, h, label: '' });
      state.widgets.push(base);
      renderWidgets();
      toast(`âœ¨ ${ICONS[state.selectedType]} added!`, 'success');
    } else {
      state.selected = null;
      state.multiSelect = [];
      renderWidgets();
      renderPropsPanel();
    }
  };
  
  // Keyboard shortcuts
  document.addEventListener('keydown', e => {
    const target = e.target;
    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.tagName === 'SELECT') return;
    
    const ctrl = e.ctrlKey || e.metaKey;
    const shift = e.shiftKey;
    
    // Undo: Ctrl+Z
    if (ctrl && e.key === 'z' && !shift) { e.preventDefault(); undo(); return; }
    // Redo: Ctrl+Shift+Z or Ctrl+Y
    if ((ctrl && shift && e.key === 'z') || (ctrl && e.key === 'y')) { e.preventDefault(); redo(); return; }
    // Copy: Ctrl+C
    if (ctrl && e.key === 'c') { e.preventDefault(); copySelected(); return; }
    // Paste: Ctrl+V
    if (ctrl && e.key === 'v') { e.preventDefault(); pasteWidgets(); return; }
    // Duplicate: Ctrl+D
    if (ctrl && e.key === 'd') { e.preventDefault(); duplicateSelected(); return; }
    // Group: Ctrl+G
    if (ctrl && e.key === 'g') { e.preventDefault(); groupSelected(); return; }
    // Save template: Ctrl+S
    if (ctrl && e.key === 's') { e.preventDefault(); saveWidgetTemplate(); return; }
    // Toggle grid: G
    if (e.key === 'g' && !ctrl) { 
      state.gridSnap = !state.gridSnap;
      const btn = $('#gridToggle');
      if (btn) btn.classList.toggle('active', state.gridSnap);
      $('#canvas')?.classList.toggle('show-grid', state.gridSnap);
      toast(state.gridSnap ? 'âŠž Grid ON' : 'âŠž Grid OFF', 'success');
      return;
    }
    // Toggle layers: L
    if (e.key === 'l' && !ctrl) { toggleLayers(); return; }
    // Theme cycle: T
    if (e.key === 't' && !ctrl) { cycleTheme(); return; }
    // Delete: Delete or Backspace
    if (e.key === 'Delete' || e.key === 'Backspace') { 
      e.preventDefault(); 
      if (state.multiSelect.length) {
        saveUndoState();
        state.widgets = state.widgets.filter(w => !state.multiSelect.includes(w.id));
        state.multiSelect = [];
        state.selected = null;
        renderWidgets();
        renderPropsPanel();
        toast('ðŸ—‘ï¸ Deleted widgets', 'success');
      } else {
        deleteSelected(); 
      }
      return; 
    }
    // Select all: Ctrl+A
    if (ctrl && e.key === 'a') { 
      e.preventDefault(); 
      state.multiSelect = state.widgets.map(w => w.id);
      updateSelectionUI();
      toast(`Selected all ${state.widgets.length} widgets`, 'success');
      return; 
    }
    // Arrow keys: nudge
    const nudgeAmount = shift ? 10 : 1;
    if (e.key === 'ArrowLeft') { e.preventDefault(); nudgeSelected(-nudgeAmount, 0); return; }
    if (e.key === 'ArrowRight') { e.preventDefault(); nudgeSelected(nudgeAmount, 0); return; }
    if (e.key === 'ArrowUp') { e.preventDefault(); nudgeSelected(0, -nudgeAmount); return; }
    if (e.key === 'ArrowDown') { e.preventDefault(); nudgeSelected(0, nudgeAmount); return; }
    // Escape: deselect
    if (e.key === 'Escape') {
      state.selected = null;
      state.multiSelect = [];
      state.selectedType = null;
      $$('.palette-item').forEach(p => p.classList.remove('selected'));
      updateSelectionUI();
      renderPropsPanel();
    }
    // Help: ?
    if (e.key === '?' || (shift && e.key === '/')) { showHelp(); return; }
  });
  
  // Buttons
  $('#soundBtn').onclick = () => { state.soundOn = !state.soundOn; updateSoundUI(); if (state.soundOn) beepClick(); };
  updateSoundUI();
  $('#bleBtn').onclick = connectBle;
  $('#connectBtn').onclick = connectBle;
  $('#demoBtn').onclick = showDemo;
  
  // Back to Build button
  const backBtn = $('#backToBuildBtn');
  if (backBtn) backBtn.onclick = () => {
    // Exit arrange mode if active
    if (state.arrangeMode) {
      toggleArrangeMode();
    }
    switchTab('builder');
  };
  
  // Arrange mode button
  const arrangeBtn = $('#arrangeModeBtn');
  if (arrangeBtn) arrangeBtn.onclick = toggleArrangeMode;
  
  // Auto-save on title change
  const titleInput = $('#titleInput');
  if (titleInput) {
    titleInput.addEventListener('input', scheduleAutoSave);
    titleInput.addEventListener('change', scheduleAutoSave);
  }
  
    // Templates
  $('#templateBtn').onclick = () => $('#templateModal').classList.remove('hidden');
  // Language on first load
  var savedLang = loadLang();
  setLang(savedLang || state.lang || detectBrowserLang());
  
  // Try to load saved project first; only show templates if nothing saved
  const hasProject = loadSavedProject();
  if (hasProject) {
    $('#templateModal').classList.add('hidden');
    renderWidgets();
    renderPropsPanel();
    toast('ðŸ“‚ Restored your last project!', 'success');
  } else {
    $('#templateModal').classList.remove('hidden');
  }
  
  var _ov=$('#loadingOverlay');
  if (_ov) _ov.onclick = () => { state._allowLoadingOverlay=false; hideLoading(); };
  if (typeof hideLoadOverlay==='function') hideLoadOverlay();
  $('#codeBtn').onclick = showCode;
  $('#deleteBtn').onclick = deleteSelected;

  // JSON Export / Import + Language
  const jsonIn = $('#jsonFileInput');
  if (jsonIn){
    jsonIn.onchange = e => {
      const f = e.target.files && e.target.files[0];
      if (f) importLayoutJsonFile(f);
      e.target.value = '';
    };
  }
  const exp = $('#exportJsonBtn'); if (exp) exp.addEventListener('click', exportLayoutJson);
  const imp = $('#importJsonBtn'); if (imp) imp.addEventListener('click', () => $('#jsonFileInput').click());
  const lb = $('#langBtn'); if (lb) lb.addEventListener('click', cycleLang);
  $('#modalClose').onclick = () => $('#modalBg').classList.remove('show');
  $('#modalBg').onclick = e => { if (e.target === $('#modalBg')) $('#modalBg').classList.remove('show'); };
  $('#copyBtn').onclick = () => { navigator.clipboard.writeText($('#modalCode').textContent); toast('ðŸ“‹ Copied!', 'success'); };
  $('#downloadBtn').onclick = downloadCode;
  
  // Flash button - Bluetooth flashing to micro:bit
  const flashBtn = $('#flashBtn');
  if (flashBtn) {
    flashBtn.onclick = flashToMicrobit;
    // Check if Web Bluetooth is supported
    if (!navigator.bluetooth) {
      flashBtn.title = 'Web Bluetooth not supported in this browser';
      flashBtn.style.opacity = '0.5';
    }
  }
  
  // Load saved theme
  try {
    const savedTheme = localStorage.getItem('widget_theme');
    if (savedTheme && THEMES[savedTheme]) setTheme(savedTheme);
  } catch(e) {}
  
  // Load high contrast preference
  loadHighContrastPref();
  
  // Load widget templates from localStorage
  loadWidgetTemplates();
  
  // Check for URL layout parameter
  loadURLLayout();
  
  // === NEW FEATURES ===
  
  // Build toolbar buttons
  const undoBtn = $('#undoBtn');
  const redoBtn = $('#redoBtn');
  const autoArrangeBtn = $('#autoArrangeBtn');
  const magicBtn = $('#magicBtn');
  
  if (undoBtn) undoBtn.onclick = undo;
  if (redoBtn) redoBtn.onclick = redo;
  if (autoArrangeBtn) autoArrangeBtn.onclick = autoArrangeWidgets;
  if (magicBtn) magicBtn.onclick = magicStyleWidgets;
  
  // Theme dots
  $$('.theme-dot').forEach(dot => {
    dot.onclick = () => setTheme(dot.dataset.theme);
  });
  
  // Load saved theme
  try {
    const savedTheme = localStorage.getItem('app_theme');
    if (savedTheme) {
      document.body.classList.remove('theme-dark', 'theme-ocean', 'theme-space', 'theme-candy', 'theme-forest', 'theme-neon');
      if (savedTheme !== 'dark') document.body.classList.add('theme-' + savedTheme);
      $$('.theme-dot').forEach(d => d.classList.toggle('active', d.dataset.theme === savedTheme));
      state.theme = savedTheme;
    }
  } catch(e) {}
  
  // Fullscreen buttons
  const fullscreenBtn = $('#fullscreenBtn');
  const fullscreenExitBtn = $('#fullscreenExitBtn');
  if (fullscreenBtn) fullscreenBtn.onclick = toggleFullscreen;
  if (fullscreenExitBtn) fullscreenExitBtn.onclick = toggleFullscreen;
  
  // Quick actions menu
  const quickMenu = $('#quickActionsMenu');
  if (quickMenu) {
    quickMenu.querySelectorAll('.quick-action-btn').forEach(btn => {
      btn.onclick = () => handleQuickAction(btn.dataset.action);
    });
  }
  
  // Long-press for quick actions on widgets
  let longPressTimer = null;
  document.addEventListener('pointerdown', e => {
    const widget = e.target.closest('.widget');
    if (!widget) return;
    longPressTimer = setTimeout(() => {
      showQuickActions(widget.dataset.id, e.clientX, e.clientY);
    }, 500);
  });
  document.addEventListener('pointerup', () => { clearTimeout(longPressTimer); });
  document.addEventListener('pointermove', () => { clearTimeout(longPressTimer); });
  document.addEventListener('click', e => {
    if (!e.target.closest('.quick-actions-menu')) hideQuickActions();
  });
  
  // Tutorial
  const tutorialNextBtn = $('#tutorialNextBtn');
  const tutorialSkipBtn = $('#tutorialSkipBtn');
  if (tutorialNextBtn) tutorialNextBtn.onclick = nextTutorialStep;
  if (tutorialSkipBtn) tutorialSkipBtn.onclick = closeTutorial;
  
  // Show tutorial on first visit
  try {
    if (!localStorage.getItem('tutorial_done')) {
      setTimeout(showTutorial, 500);
    }
  } catch(e) {}
  
  // Setup shake detection and swipe gestures
  setupShakeDetection();
  setupSwipeGestures();
  
  // Update toolbar state
  updateBuildToolbar();
}

// === CELEBRATION ANIMATION ===
function celebrate(message = 'ðŸŽ‰ Connected!') {
  const overlay = document.createElement('div');
  overlay.className = 'celebration-overlay';
  
  // Create confetti
  const colors = ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#00e676', '#ff9100'];
  for (let i = 0; i < 50; i++) {
    const confetti = document.createElement('div');
    confetti.className = 'confetti';
    confetti.style.left = Math.random() * 100 + '%';
    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
    confetti.style.animationDelay = Math.random() * 0.5 + 's';
    confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
    overlay.appendChild(confetti);
  }
  
  // Create text
  const text = document.createElement('div');
  text.className = 'celebration-text';
  text.textContent = message;
  overlay.appendChild(text);
  
  document.body.appendChild(overlay);
  
  // Play celebration sound
  if (state.soundOn) {
    beep(523, 0.1, 0.06); // C
    setTimeout(() => beep(659, 0.1, 0.06), 100); // E
    setTimeout(() => beep(784, 0.15, 0.06), 200); // G
    setTimeout(() => beep(1047, 0.2, 0.08), 300); // High C
  }
  
  // Remove after animation
  setTimeout(() => overlay.remove(), 3000);
}

// === FULLSCREEN MODE ===
function toggleFullscreen() {
  const btn = $('#fullscreenBtn');
  const exitBtn = $('#fullscreenExitBtn');
  const isFullscreen = document.body.classList.contains('runtime-fullscreen');
  
  if (isFullscreen) {
    // Exit fullscreen
    document.body.classList.remove('runtime-fullscreen');
    if (btn) {
      btn.textContent = 'â›¶ Fullscreen';
      btn.style.display = 'block';
    }
    if (exitBtn) exitBtn.style.display = 'none';
    
    // Exit native fullscreen API
    if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement) {
      if (document.exitFullscreen) {
        document.exitFullscreen().catch(() => {});
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      }
    }
  } else {
    // Enter fullscreen
    document.body.classList.add('runtime-fullscreen');
    if (btn) btn.style.display = 'none';
    if (exitBtn) exitBtn.style.display = 'flex';
    
    // Request native fullscreen API
    const elem = document.documentElement;
    if (elem.requestFullscreen) {
      elem.requestFullscreen().catch(() => {});
    } else if (elem.webkitRequestFullscreen) {
      elem.webkitRequestFullscreen();
    } else if (elem.mozRequestFullScreen) {
      elem.mozRequestFullScreen();
    }
  }
}

// Exit fullscreen on Escape
document.addEventListener('keydown', e => {
  if (e.key === 'Escape' && document.body.classList.contains('runtime-fullscreen')) {
    toggleFullscreen();
  }
});

// Handle native fullscreen API changes (e.g., ESC key pressed)
document.addEventListener('fullscreenchange', () => {
  if (!document.fullscreenElement && document.body.classList.contains('runtime-fullscreen')) {
    toggleFullscreen();
  }
});
document.addEventListener('webkitfullscreenchange', () => {
  if (!document.webkitFullscreenElement && document.body.classList.contains('runtime-fullscreen')) {
    toggleFullscreen();
  }
});
document.addEventListener('mozfullscreenchange', () => {
  if (!document.mozFullScreenElement && document.body.classList.contains('runtime-fullscreen')) {
    toggleFullscreen();
  }
});

// === AUTO ARRANGE WIDGETS ===
function autoArrangeWidgets() {
  if (!state.widgets.length) {
    toast('No widgets to arrange!', 'error');
    return;
  }
  
  saveUndoState();
  
  const padding = 15;
  const canvas = $('#canvas');
  const canvasW = canvas?.offsetWidth || 500;
  
  // Sort by size (larger first)
  const sorted = [...state.widgets].sort((a, b) => (b.w * b.h) - (a.w * a.h));
  
  let currentX = padding;
  let currentY = padding;
  let rowHeight = 0;
  
  sorted.forEach(w => {
    // Check if widget fits in current row
    if (currentX + w.w + padding > canvasW) {
      // Move to next row
      currentX = padding;
      currentY += rowHeight + padding;
      rowHeight = 0;
    }
    
    w.x = currentX;
    w.y = currentY;
    currentX += w.w + padding;
    rowHeight = Math.max(rowHeight, w.h);
  });
  
  renderWidgets();
  toast('âœ¨ Widgets arranged!', 'success');
  if (state.soundOn) beepClick();
}

// === THEME SELECTOR ===
function showThemeSelector() {
  // Remove existing selector
  const existing = document.querySelector('.theme-modal');
  if (existing) existing.remove();
  
  const modal = document.createElement('div');
  modal.className = 'modal-bg show theme-modal';
  modal.innerHTML = `
    <div class="modal" style="max-width: 400px;">
      <div class="modal-title">ðŸŽ¨ Choose Theme</div>
      <div class="theme-selector">
        <div class="theme-chip dark ${state.theme === 'dark' ? 'active' : ''}" data-theme="dark">ðŸŒ™ Dark</div>
        <div class="theme-chip ocean ${state.theme === 'ocean' ? 'active' : ''}" data-theme="ocean">ðŸŒŠ Ocean</div>
        <div class="theme-chip space ${state.theme === 'space' ? 'active' : ''}" data-theme="space">ðŸš€ Space</div>
        <div class="theme-chip candy ${state.theme === 'candy' ? 'active' : ''}" data-theme="candy">ðŸ¬ Candy</div>
        <div class="theme-chip forest ${state.theme === 'forest' ? 'active' : ''}" data-theme="forest">ðŸŒ² Forest</div>
        <div class="theme-chip sunset ${state.theme === 'sunset' ? 'active' : ''}" data-theme="sunset">ðŸŒ… Sunset</div>
      </div>
      <div style="margin-top: 16px;">
        <button class="modal-btn secondary" onclick="this.closest('.modal-bg').remove()">âœ• Close</button>
      </div>
    </div>
  `;
  
  modal.querySelectorAll('.theme-chip').forEach(chip => {
    chip.onclick = () => {
      const theme = chip.dataset.theme;
      setAppTheme(theme);
      modal.querySelectorAll('.theme-chip').forEach(c => c.classList.remove('active'));
      chip.classList.add('active');
      if (state.soundOn) beepClick();
    };
  });
  
  modal.onclick = e => { if (e.target === modal) modal.remove(); };
  document.body.appendChild(modal);
}

function setAppTheme(theme) {
  // Remove all theme classes
  document.body.classList.remove('theme-dark', 'theme-ocean', 'theme-space', 'theme-candy', 'theme-forest', 'theme-sunset', 'theme-light', 'theme-neon', 'theme-nature');
  
  if (theme && theme !== 'dark') {
    document.body.classList.add('theme-' + theme);
  }
  
  state.theme = theme;
  try { localStorage.setItem('app_theme', theme); } catch(e) {}
  toast(`ðŸŽ¨ Theme: ${theme.charAt(0).toUpperCase() + theme.slice(1)}`, 'success');
}

// Load saved theme on startup
try {
  const savedTheme = localStorage.getItem('app_theme');
  if (savedTheme) setAppTheme(savedTheme);
} catch(e) {}

// === SHARE VIA QR CODE ===
function showShareQR() {
  const titleEl = $('#titleInput');
  const data = {
    title: titleEl?.value || 'My Remote',
    widgets: state.widgets
  };
  
  // Create simple URL-safe layout string
  const layoutStr = btoa(unescape(encodeURIComponent(JSON.stringify(data))));
  const url = location.origin + location.pathname + '?layout=' + layoutStr;
  
  // Create QR modal
  const modal = document.createElement('div');
  modal.className = 'modal-bg show';
  modal.innerHTML = `
    <div class="modal qr-modal" style="max-width: 350px;">
      <div class="modal-title">ðŸ“± Share Your Remote</div>
      <div class="qr-code-container">
        <canvas id="qrCanvas"></canvas>
      </div>
      <p style="color: var(--text-dim); font-size: 0.85rem; margin-bottom: 16px;">Scan this code to load your layout!</p>
      <div class="modal-buttons">
        <button class="modal-btn primary" onclick="navigator.clipboard.writeText('${url}'); toast('ðŸ“‹ Link copied!', 'success');">ðŸ“‹ Copy Link</button>
        <button class="modal-btn secondary" onclick="this.closest('.modal-bg').remove()">âœ• Close</button>
      </div>
    </div>
  `;
  
  modal.onclick = e => { if (e.target === modal) modal.remove(); };
  document.body.appendChild(modal);
  
  // Generate QR code
  generateQRCode('qrCanvas', url);
}

// Simple QR code generator (basic version)
function generateQRCode(canvasId, text) {
  const canvas = document.getElementById(canvasId);
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const size = 200;
  canvas.width = size;
  canvas.height = size;
  
  // Simple placeholder - in production you'd use a QR library
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, size, size);
  
  ctx.fillStyle = '#000';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('QR Code', size/2, size/2 - 20);
  ctx.font = '11px sans-serif';
  ctx.fillText('(Add qrcode.js library', size/2, size/2 + 10);
  ctx.fillText('for real QR codes)', size/2, size/2 + 25);
  
  // Draw simple pattern to indicate it's a QR placeholder
  ctx.fillStyle = '#000';
  const patternSize = 30;
  // Top-left corner
  ctx.fillRect(10, 10, patternSize, patternSize);
  ctx.fillStyle = '#fff';
  ctx.fillRect(15, 15, patternSize - 10, patternSize - 10);
  ctx.fillStyle = '#000';
  ctx.fillRect(20, 20, patternSize - 20, patternSize - 20);
  
  // Top-right corner
  ctx.fillStyle = '#000';
  ctx.fillRect(size - 10 - patternSize, 10, patternSize, patternSize);
  ctx.fillStyle = '#fff';
  ctx.fillRect(size - 15 - patternSize + 5, 15, patternSize - 10, patternSize - 10);
  ctx.fillStyle = '#000';
  ctx.fillRect(size - 20 - patternSize + 10, 20, patternSize - 20, patternSize - 20);
  
  // Bottom-left corner
  ctx.fillStyle = '#000';
  ctx.fillRect(10, size - 10 - patternSize, patternSize, patternSize);
  ctx.fillStyle = '#fff';
  ctx.fillRect(15, size - 15 - patternSize + 5, patternSize - 10, patternSize - 10);
  ctx.fillStyle = '#000';
  ctx.fillRect(20, size - 20 - patternSize + 10, patternSize - 20, patternSize - 20);
}

// === SCREENSHOT ===
function takeScreenshot() {
  const canvas = $('#canvas') || $('#runtimeGrid');
  if (!canvas) {
    toast('Nothing to capture!', 'error');
    return;
  }
  
  // Use html2canvas if available
  if (typeof html2canvas !== 'undefined') {
    html2canvas(canvas).then(c => {
      const link = document.createElement('a');
      link.download = 'my-remote.png';
      link.href = c.toDataURL();
      link.click();
      toast('ðŸ“¸ Screenshot saved!', 'success');
    }).catch(() => toast('Screenshot failed', 'error'));
  } else {
    toast('ðŸ“¸ Screenshot requires html2canvas library', 'error');
  }
}

// === LONG PRESS QUICK ACTIONS ===
function setupLongPressActions() {
  let longPressTimer = null;
  let longPressTarget = null;
  
  const showQuickMenu = (widget, x, y) => {
    // Remove existing menu
    document.querySelectorAll('.quick-action-menu').forEach(m => m.remove());
    
    const menu = document.createElement('div');
    menu.className = 'quick-action-menu';
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';
    menu.innerHTML = `
      <button class="quick-action-btn" data-action="duplicate" title="Duplicate">ðŸ“‹</button>
      <button class="quick-action-btn" data-action="color" title="Change color">ðŸŽ¨</button>
      <button class="quick-action-btn" data-action="lock" title="Lock/Unlock">ðŸ”’</button>
      <button class="quick-action-btn" data-action="front" title="Bring to front">â¬†ï¸</button>
      <button class="quick-action-btn" data-action="back" title="Send to back">â¬‡ï¸</button>
      <button class="quick-action-btn danger" data-action="delete" title="Delete">ðŸ—‘ï¸</button>
    `;
    
    menu.querySelectorAll('.quick-action-btn').forEach(btn => {
      btn.onclick = (e) => {
        e.stopPropagation();
        const action = btn.dataset.action;
        const w = state.widgets.find(w => w.id === widget.dataset.id);
        
        if (action === 'duplicate') {
          duplicateWidget(w);
        } else if (action === 'color') {
          randomizeWidgetColor(w);
        } else if (action === 'lock') {
          w.locked = !w.locked;
          toast(w.locked ? 'ðŸ”’ Locked' : 'ðŸ”“ Unlocked', 'success');
          renderWidgets();
        } else if (action === 'front') {
          bringToFront(w);
        } else if (action === 'back') {
          sendToBack(w);
        } else if (action === 'delete') {
          saveUndoState();
          state.widgets = state.widgets.filter(x => x.id !== w.id);
          state.selected = null;
          renderWidgets();
          renderPropsPanel();
          toast('ðŸ—‘ï¸ Deleted', 'success');
        }
        
        menu.remove();
        if (state.soundOn) beepClick();
      };
    });
    
    document.body.appendChild(menu);
    
    // Close menu on click elsewhere
    const closeMenu = (e) => {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }
    };
    setTimeout(() => document.addEventListener('click', closeMenu), 10);
  };
  
  document.addEventListener('pointerdown', e => {
    const widget = e.target.closest('.widget');
    if (!widget) return;
    
    longPressTarget = widget;
    longPressTimer = setTimeout(() => {
      // Vibrate if supported
      if (navigator.vibrate) navigator.vibrate(50);
      showQuickMenu(widget, e.clientX, e.clientY);
    }, 500);
  });
  
  document.addEventListener('pointerup', () => {
    if (longPressTimer) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }
  });
  
  document.addEventListener('pointermove', e => {
    if (longPressTimer && longPressTarget) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }
  });
}

function duplicateWidget(w) {
  if (!w) return;
  saveUndoState();
  const newW = { ...w, id: `${w.t}${state.nextId++}`, x: w.x + 20, y: w.y + 20 };
  state.widgets.push(newW);
  state.selected = newW.id;
  renderWidgets();
  toast('ðŸ“‹ Duplicated!', 'success');
}

function randomizeWidgetColor(w) {
  if (!w) return;
  const colors = ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#00e676', '#ff9100', '#b388ff'];
  w.color = colors[Math.floor(Math.random() * colors.length)];
  renderWidgets();
  renderPropsPanel();
  toast('ðŸŽ¨ New color!', 'success');
}

function bringToFront(w) {
  if (!w) return;
  const idx = state.widgets.findIndex(x => x.id === w.id);
  if (idx >= 0) {
    state.widgets.splice(idx, 1);
    state.widgets.push(w);
    renderWidgets();
    toast('â¬†ï¸ Brought to front', 'success');
  }
}

function sendToBack(w) {
  if (!w) return;
  const idx = state.widgets.findIndex(x => x.id === w.id);
  if (idx >= 0) {
    state.widgets.splice(idx, 1);
    state.widgets.unshift(w);
    renderWidgets();
    toast('â¬‡ï¸ Sent to back', 'success');
  }
}

// === UPDATE BUILD TOOLBAR STATE ===
function updateBuildToolbar() {
  const undoBtn = $('#undoBtn');
  const redoBtn = $('#redoBtn');
  
  if (undoBtn) undoBtn.disabled = !state.undoStack.length;
  if (redoBtn) redoBtn.disabled = !state.redoStack.length;
}

// === HAPTIC FEEDBACK ===
function vibrate(pattern = 10) {
  if (navigator.vibrate) navigator.vibrate(pattern);
}

// === PARTICLE EFFECTS ON BUTTON PRESS ===
function createParticles(x, y, count = 8) {
  const colors = ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff'];
  
  for (let i = 0; i < count; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    const size = 4 + Math.random() * 8;
    const angle = (Math.PI * 2 / count) * i;
    const distance = 20 + Math.random() * 30;
    
    particle.style.width = size + 'px';
    particle.style.height = size + 'px';
    particle.style.background = colors[Math.floor(Math.random() * colors.length)];
    particle.style.left = x + 'px';
    particle.style.top = y + 'px';
    particle.style.transform = `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px)`;
    
    document.body.appendChild(particle);
    setTimeout(() => particle.remove(), 600);
  }
}

function selectTemplate(name) {
  const t = templates[name];
  if (!t) return;

  // Kids-friendly loading overlay while building a template
  if (typeof showLoadOverlay === 'function') {
    const titles = {
      gamepad: 'ðŸŽ® Building Game Pad...',
      robot: 'ðŸ¤– Building Robot Remote...',
      mixer: 'ðŸŽµ Building DJ Mixer...',
      racing: 'ðŸŽï¸ Building Race Car...',
      lights: 'ðŸ’¡ Building Lights Panel...',
      blank: 'âœ¨ Preparing Blank Canvas...'
    };
    showBuildOverlay(titles[name] || 'âœ¨ Building...');
  }

  // Small delay so the overlay is visible and feels animated
  setTimeout(() => {
    state.widgets = t.map((w, i) => ({ id: `${w.t}${state.nextId + i}`, ...w }));
    state.nextId += t.length || 1;

    // Apply defaults for new widget types / models
    if (typeof applyWidgetDefaults === 'function') {
      state.widgets.forEach(applyWidgetDefaults);
    }

    state.selected = null;
    $('#templateModal').classList.add('hidden');
    renderWidgets();
    renderPropsPanel();

    if (typeof hideLoadOverlay === 'function') hideLoadOverlay();

    if (name === 'blank') toast('âœ¨ Canvas ready! Pick a widget below', 'success');
    else toast('âœ… Template loaded!', 'success');
  }, 250);
}

// === FULLSCREEN MODE ===
function toggleFullscreen() {
  const isFullscreen = document.body.classList.contains('runtime-fullscreen');
  if (isFullscreen) {
    document.body.classList.remove('runtime-fullscreen');
    if (document.exitFullscreen) document.exitFullscreen().catch(() => {});
  } else {
    document.body.classList.add('runtime-fullscreen');
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen().catch(() => {});
    }
  }
}

// === CELEBRATION ANIMATION ===
function celebrate(message = 'ðŸŽ‰ Connected!') {
  const overlay = document.createElement('div');
  overlay.className = 'celebration-overlay';
  
  const colors = ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#00e676'];
  for (let i = 0; i < 60; i++) {
    const c = document.createElement('div');
    c.className = 'confetti';
    c.style.left = Math.random() * 100 + '%';
    c.style.background = colors[Math.floor(Math.random() * colors.length)];
    c.style.animationDelay = Math.random() * 0.5 + 's';
    c.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
    overlay.appendChild(c);
  }
  
  document.body.appendChild(overlay);
  if (state.soundOn) {
    beep(523, 0.1, 0.05);
    setTimeout(() => beep(659, 0.1, 0.05), 100);
    setTimeout(() => beep(784, 0.15, 0.05), 200);
  }
  setTimeout(() => overlay.remove(), 3500);
  toast(message, 'success');
}

// === QUICK ACTIONS MENU ===
function showQuickActions(widgetId, x, y) {
  const menu = $('#quickActionsMenu');
  if (!menu) return;
  
  state._quickActionTarget = widgetId;
  menu.style.left = Math.min(x, window.innerWidth - 160) + 'px';
  menu.style.top = Math.min(y, window.innerHeight - 250) + 'px';
  menu.classList.add('show');
  
  if (navigator.vibrate) navigator.vibrate(30);
}

function hideQuickActions() {
  const menu = $('#quickActionsMenu');
  if (menu) menu.classList.remove('show');
}

function handleQuickAction(action) {
  const w = state.widgets.find(w => w.id === state._quickActionTarget);
  if (!w) return;
  
  switch(action) {
    case 'duplicate':
      saveUndoState();
      const newW = { ...w, id: `${w.t}${state.nextId++}`, x: w.x + 20, y: w.y + 20 };
      state.widgets.push(newW);
      state.selected = newW.id;
      renderWidgets();
      toast('ðŸ“‹ Duplicated!', 'success');
      break;
    case 'color':
      const colors = ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#00e676', '#ff9100', '#b388ff'];
      w.color = colors[Math.floor(Math.random() * colors.length)];
      renderWidgets();
      toast('ðŸŽ¨ New color!', 'success');
      break;
    case 'lock':
      w.locked = !w.locked;
      renderWidgets();
      toast(w.locked ? 'ðŸ”’ Locked' : 'ðŸ”“ Unlocked', 'success');
      break;
    case 'front':
      const idx = state.widgets.indexOf(w);
      state.widgets.splice(idx, 1);
      state.widgets.push(w);
      renderWidgets();
      toast('â¬†ï¸ Brought to front', 'success');
      break;
    case 'back':
      const idx2 = state.widgets.indexOf(w);
      state.widgets.splice(idx2, 1);
      state.widgets.unshift(w);
      renderWidgets();
      toast('â¬‡ï¸ Sent to back', 'success');
      break;
    case 'delete':
      saveUndoState();
      state.widgets = state.widgets.filter(x => x.id !== w.id);
      state.selected = null;
      renderWidgets();
      renderPropsPanel();
      toast('ðŸ—‘ï¸ Deleted', 'success');
      break;
  }
  
  hideQuickActions();
  if (state.soundOn) beepClick();
}

// === TUTORIAL ===
const tutorialSteps = [
  { icon: 'ðŸ‘‹', title: 'Welcome!', text: 'Let\'s build your first micro:bit remote control! It\'s easy and fun!' },
  { icon: 'ðŸ‘†', title: 'Pick a Widget', text: 'Tap any widget below (like Button or Slider) to select it.' },
  { icon: 'ðŸ“±', title: 'Place It', text: 'Then tap on the canvas to place your widget. You can drag it around!' },
  { icon: 'ðŸ”—', title: 'Connect & Play!', text: 'When ready, go to Play mode and connect your micro:bit. Have fun!' }
];
let tutorialStep = 0;

function showTutorial() {
  tutorialStep = 0;
  updateTutorialStep();
  $('#tutorialOverlay')?.classList.remove('hidden');
}

function updateTutorialStep() {
  const step = tutorialSteps[tutorialStep];
  if (!step) {
    closeTutorial();
    return;
  }
  
  $('#tutorialIcon').textContent = step.icon;
  $('#tutorialTitle').textContent = step.title;
  $('#tutorialText').textContent = step.text;
  
  const btn = $('#tutorialNextBtn');
  btn.textContent = tutorialStep === tutorialSteps.length - 1 ? 'Start Building! ðŸš€' : 'Next â†’';
  
  $$('.tutorial-dot').forEach((dot, i) => {
    dot.classList.toggle('active', i === tutorialStep);
  });
}

function nextTutorialStep() {
  tutorialStep++;
  if (tutorialStep >= tutorialSteps.length) {
    closeTutorial();
  } else {
    updateTutorialStep();
  }
  if (state.soundOn) beepClick();
}

function closeTutorial() {
  $('#tutorialOverlay')?.classList.add('hidden');
  try { localStorage.setItem('tutorial_done', '1'); } catch(e) {}
}

// === THEME SWITCHING ===
function setTheme(theme) {
  document.body.classList.remove('theme-dark', 'theme-ocean', 'theme-space', 'theme-candy', 'theme-forest', 'theme-neon');
  if (theme !== 'dark') {
    document.body.classList.add('theme-' + theme);
  }
  state.theme = theme;
  
  $$('.theme-dot').forEach(d => d.classList.toggle('active', d.dataset.theme === theme));
  
  try { localStorage.setItem('app_theme', theme); } catch(e) {}
  toast('ðŸŽ¨ Theme: ' + theme.charAt(0).toUpperCase() + theme.slice(1), 'success');
  if (state.soundOn) beepClick();
}

// === AUTO ARRANGE ===
function autoArrangeWidgets() {
  if (!state.widgets.length) {
    toast('No widgets to arrange!', 'error');
    return;
  }
  
  saveUndoState();
  
  const padding = 15;
  const canvas = $('#canvas');
  const canvasW = canvas?.offsetWidth || 500;
  
  const sorted = [...state.widgets].sort((a, b) => (b.w * b.h) - (a.w * a.h));
  
  let currentX = padding;
  let currentY = padding;
  let rowHeight = 0;
  
  sorted.forEach(w => {
    if (currentX + w.w + padding > canvasW) {
      currentX = padding;
      currentY += rowHeight + padding;
      rowHeight = 0;
    }
    
    w.x = currentX;
    w.y = currentY;
    currentX += w.w + padding;
    rowHeight = Math.max(rowHeight, w.h);
  });
  
  renderWidgets();
  toast('âœ¨ Widgets tidied up!', 'success');
  if (state.soundOn) beepClick();
}

// === MAGIC WAND - Random Style All Widgets ===
function magicStyleWidgets() {
  if (!state.widgets.length) {
    toast('Add some widgets first!', 'error');
    return;
  }
  
  saveUndoState();
  
  const colors = ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#00e676', '#ff9100', '#b388ff', '#00d4ff'];
  const models = {
    button: ['neo', 'glass', 'pill', 'flat'],
    slider: ['track', 'neon', 'min'],
    toggle: ['square', 'pill', 'icon'],
    joystick: ['classic', 'ring', 'min'],
    gauge: ['classic', 'neon', 'minimal'],
    led: ['dot', 'ring', 'bar']
  };
  
  state.widgets.forEach(w => {
    w.color = colors[Math.floor(Math.random() * colors.length)];
    if (models[w.t]) {
      w.model = models[w.t][Math.floor(Math.random() * models[w.t].length)];
    }
  });
  
  renderWidgets();
  renderPropsPanel();
  
  // Fun particle explosion
  const canvas = $('#canvas');
  if (canvas) {
    const rect = canvas.getBoundingClientRect();
    createParticles(rect.left + rect.width/2, rect.top + rect.height/2, 20);
  }
  
  toast('ðŸª„ Magic applied!', 'success');
  if (state.soundOn) {
    beep(440, 0.1, 0.05);
    setTimeout(() => beep(554, 0.1, 0.05), 80);
    setTimeout(() => beep(659, 0.1, 0.05), 160);
    setTimeout(() => beep(880, 0.15, 0.05), 240);
  }
}

// === SHAKE TO RANDOMIZE ===
let lastShakeTime = 0;
function setupShakeDetection() {
  if (!window.DeviceMotionEvent) return;
  
  let shakeThreshold = 15;
  let lastX = 0, lastY = 0, lastZ = 0;
  
  window.addEventListener('devicemotion', (e) => {
    const acc = e.accelerationIncludingGravity;
    if (!acc) return;
    
    const deltaX = Math.abs(acc.x - lastX);
    const deltaY = Math.abs(acc.y - lastY);
    const deltaZ = Math.abs(acc.z - lastZ);
    
    if ((deltaX > shakeThreshold || deltaY > shakeThreshold || deltaZ > shakeThreshold)) {
      const now = Date.now();
      if (now - lastShakeTime > 1000) { // Debounce 1 second
        lastShakeTime = now;
        onShake();
      }
    }
    
    lastX = acc.x;
    lastY = acc.y;
    lastZ = acc.z;
  });
}

function onShake() {
  if (navigator.vibrate) navigator.vibrate([50, 50, 50]);
  magicStyleWidgets();
}

// === SWIPE GESTURES ===
function setupSwipeGestures() {
  let touchStartY = 0;
  let touchStartX = 0;
  
  document.addEventListener('touchstart', e => {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
  }, { passive: true });
  
  document.addEventListener('touchend', e => {
    const touchEndX = e.changedTouches[0].clientX;
    const touchEndY = e.changedTouches[0].clientY;
    
    const deltaX = touchEndX - touchStartX;
    const deltaY = touchEndY - touchStartY;
    
    // Only trigger if swipe is significant and more vertical than horizontal
    if (Math.abs(deltaY) > 100 && Math.abs(deltaY) > Math.abs(deltaX)) {
      const runtimeView = $('.runtime-view.active');
      if (runtimeView) {
        if (deltaY < -100) { // Swipe up
          if (!document.body.classList.contains('runtime-fullscreen')) {
            toggleFullscreen();
          }
        } else if (deltaY > 100) { // Swipe down
          if (document.body.classList.contains('runtime-fullscreen')) {
            toggleFullscreen();
          }
        }
      }
    }
  }, { passive: true });
}

function switchTab(tab) {
  $$('.tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
  $$('.view').forEach(v => v.classList.remove('active'));
  
  const builderView = $('.builder-view');
  const runtimeView = $('.runtime-view');
  const fullscreenBtn = $('#fullscreenBtn');
  
  if (tab === 'builder') {
    builderView.classList.add('active');
    runtimeView.classList.remove('active');
    stopDemoSim();
    
    // Hide fullscreen button
    if (fullscreenBtn) fullscreenBtn.classList.remove('visible');
    
    // Exit fullscreen mode if active
    if (document.body.classList.contains('runtime-fullscreen')) {
      document.body.classList.remove('runtime-fullscreen');
      if (document.exitFullscreen) document.exitFullscreen().catch(() => {});
    }
    
    // Exit arrange mode when switching to build
    if (state.arrangeMode) {
      state.arrangeMode = false;
      const arrangeBtn = $('#arrangeModeBtn');
      if (arrangeBtn) {
        arrangeBtn.classList.remove('active');
        arrangeBtn.textContent = 'ðŸ“ Arrange';
      }
      const grid = $('#runtimeGrid');
      if (grid) grid.classList.remove('arrange-mode');
      const hint = $('#arrangeHint');
      if (hint) hint.style.display = 'none';
      
      // Sync any changes made
      syncRuntimeToBuild();
    }
  } else {
    // Runtime tab
    builderView.classList.remove('active');
    runtimeView.classList.add('active');
    startDemoSim();
    
    // If connected via BLE, runtime is already set up
    if (state.ble.connected) {
      // Already handled by updateBleUI
    }
    // If we have a config (from demo), show it
    else if (state.config && state.config.widgets && state.config.widgets.length > 0) {
      $('#connectPrompt').style.display = 'none';
      $('#runtimeContent').style.display = 'flex';
      const arrangeBtn = $('#arrangeModeBtn');
      if (arrangeBtn) arrangeBtn.classList.add('visible');
      if (fullscreenBtn) fullscreenBtn.classList.add('visible');
    }
    // Otherwise show connect prompt for kids
    else {
      $('#connectPrompt').style.display = 'block';
      $('#runtimeContent').style.display = 'none';
      const arrangeBtn = $('#arrangeModeBtn');
      if (arrangeBtn) arrangeBtn.classList.remove('visible');
      if (fullscreenBtn) fullscreenBtn.classList.remove('visible');
    }
  }
}

// Collision detection helpers
function rectsOverlap(a, b, gap = 4) {
  return !(a.x + a.w + gap <= b.x || b.x + b.w + gap <= a.x || 
           a.y + a.h + gap <= b.y || b.y + b.h + gap <= a.y);
}

function resolveOverlaps(moved) {
  const GAP = 6;
  for (let iter = 0; iter < 20; iter++) {
    let anyOverlap = false;
    for (let i = 0; i < state.widgets.length; i++) {
      for (let j = i + 1; j < state.widgets.length; j++) {
        const a = state.widgets[i], b = state.widgets[j];
        if (a.locked && b.locked) continue;
        if (!rectsOverlap(a, b, GAP)) continue;
        anyOverlap = true;
        const pushed = (moved && a.id === moved.id) ? b : (moved && b.id === moved.id) ? a : (a.locked ? b : a);
        const fixed = pushed === b ? a : b;
        if (pushed.locked) continue;
        const overlapX = (fixed.w/2 + pushed.w/2 + GAP) - Math.abs((fixed.x + fixed.w/2) - (pushed.x + pushed.w/2));
        const overlapY = (fixed.h/2 + pushed.h/2 + GAP) - Math.abs((fixed.y + fixed.h/2) - (pushed.y + pushed.h/2));
        if (overlapX < overlapY) {
          pushed.x = (pushed.x > fixed.x) ? fixed.x + fixed.w + GAP : fixed.x - pushed.w - GAP;
        } else {
          pushed.y = (pushed.y > fixed.y) ? fixed.y + fixed.h + GAP : fixed.y - pushed.h - GAP;
        }
        pushed.x = Math.max(0, pushed.x);
        pushed.y = Math.max(0, pushed.y);
      }
    }
    if (!anyOverlap) break;
  }
  state.widgets.forEach(w => {
    const el = $(`.widget[data-id="${w.id}"]`);
    if (el) { el.style.left = w.x + 'px'; el.style.top = w.y + 'px'; }
  });
  updateCanvasSize();
  updateMinimap();
}

// Undo/Redo system
function saveUndoState() {
  const snapshot = JSON.stringify(state.widgets);
  if (state.undoStack.length && state.undoStack[state.undoStack.length-1] === snapshot) return;
  state.undoStack.push(snapshot);
  if (state.undoStack.length > state.maxUndo) state.undoStack.shift();
  state.redoStack = [];
}

function undo() {
  if (state.undoStack.length < 2) { toast('Nothing to undo', 'error'); return; }
  state.redoStack.push(state.undoStack.pop());
  state.widgets = JSON.parse(state.undoStack[state.undoStack.length-1]);
  state.selected = null;
  state.multiSelect = [];
  renderWidgets();
  renderPropsPanel();
  toast('â†©ï¸ Undo', 'success');
}

function redo() {
  if (!state.redoStack.length) { toast('Nothing to redo', 'error'); return; }
  const snapshot = state.redoStack.pop();
  state.undoStack.push(snapshot);
  state.widgets = JSON.parse(snapshot);
  state.selected = null;
  state.multiSelect = [];
  renderWidgets();
  renderPropsPanel();
  toast('â†ªï¸ Redo', 'success');
}

// Copy/Paste/Duplicate
function copySelected() {
  const ids = state.multiSelect.length ? state.multiSelect : (state.selected ? [state.selected] : []);
  if (!ids.length) { toast('Select widgets first', 'error'); return; }
  state.clipboard = state.widgets.filter(w => ids.includes(w.id)).map(w => ({...w}));
  toast(`ðŸ“‹ Copied ${state.clipboard.length} widget(s)`, 'success');
}

function pasteWidgets() {
  if (!state.clipboard.length) { toast('Nothing to paste', 'error'); return; }
  saveUndoState();
  const offset = 20;
  state.clipboard.forEach(w => {
    const newW = {...w, id: `${w.t}${state.nextId++}`, x: w.x + offset, y: w.y + offset};
    state.widgets.push(newW);
  });
  resolveOverlaps(null);
  renderWidgets();
  toast(`ðŸ“‹ Pasted ${state.clipboard.length} widget(s)`, 'success');
  saveUndoState();
}

function duplicateSelected() {
  const ids = state.multiSelect.length ? state.multiSelect : (state.selected ? [state.selected] : []);
  if (!ids.length) { toast('Select widgets first', 'error'); return; }
  saveUndoState();
  const toDupe = state.widgets.filter(w => ids.includes(w.id));
  toDupe.forEach(w => {
    const newW = {...w, id: `${w.t}${state.nextId++}`, x: w.x + 20, y: w.y + 20};
    state.widgets.push(newW);
  });
  resolveOverlaps(null);
  renderWidgets();
  toast(`âœ¨ Duplicated ${toDupe.length} widget(s)`, 'success');
  saveUndoState();
}

// === SMART LAYOUT FUNCTIONS ===

// Auto-arrange in grid
function autoArrangeGrid() {
  if (!state.widgets.length) return;
  saveUndoState();
  const cols = Math.ceil(Math.sqrt(state.widgets.length));
  const gap = 10;
  let maxW = 0, maxH = 0;
  state.widgets.forEach(w => { maxW = Math.max(maxW, w.w); maxH = Math.max(maxH, w.h); });
  state.widgets.forEach((w, i) => {
    w.x = (i % cols) * (maxW + gap) + gap;
    w.y = Math.floor(i / cols) * (maxH + gap) + gap;
  });
  renderWidgets();
  toast('âŠž Arranged in grid', 'success');
  saveUndoState();
}

// Auto-arrange in rows
function autoArrangeRows() {
  if (!state.widgets.length) return;
  saveUndoState();
  const gap = 10;
  let y = gap;
  state.widgets.forEach(w => {
    w.x = gap;
    w.y = y;
    y += w.h + gap;
  });
  renderWidgets();
  toast('â‰¡ Arranged in rows', 'success');
  saveUndoState();
}

// Auto-arrange in columns
function autoArrangeCols() {
  if (!state.widgets.length) return;
  saveUndoState();
  const gap = 10;
  let x = gap;
  state.widgets.forEach(w => {
    w.x = x;
    w.y = gap;
    x += w.w + gap;
  });
  renderWidgets();
  toast('â«¾ Arranged in columns', 'success');
  saveUndoState();
}

// Distribute horizontally
function distributeH() {
  const ids = state.multiSelect.length ? state.multiSelect : state.widgets.map(w => w.id);
  const ws = state.widgets.filter(w => ids.includes(w.id)).sort((a,b) => a.x - b.x);
  if (ws.length < 3) { toast('Need 3+ widgets', 'error'); return; }
  saveUndoState();
  const first = ws[0], last = ws[ws.length-1];
  const totalSpace = last.x - first.x - first.w;
  const gap = totalSpace / (ws.length - 1);
  let x = first.x + first.w;
  ws.slice(1, -1).forEach(w => { w.x = x + gap - w.w/2 + first.w/2; x += gap; });
  renderWidgets();
  toast('â†” Distributed horizontally', 'success');
  saveUndoState();
}

// Distribute vertically
function distributeV() {
  const ids = state.multiSelect.length ? state.multiSelect : state.widgets.map(w => w.id);
  const ws = state.widgets.filter(w => ids.includes(w.id)).sort((a,b) => a.y - b.y);
  if (ws.length < 3) { toast('Need 3+ widgets', 'error'); return; }
  saveUndoState();
  const first = ws[0], last = ws[ws.length-1];
  const totalSpace = last.y - first.y - first.h;
  const gap = totalSpace / (ws.length - 1);
  let y = first.y + first.h;
  ws.slice(1, -1).forEach(w => { w.y = y + gap - w.h/2 + first.h/2; y += gap; });
  renderWidgets();
  toast('â†• Distributed vertically', 'success');
  saveUndoState();
}

// Align functions
function alignLeft() {
  const ids = state.multiSelect.length ? state.multiSelect : [state.selected];
  const ws = state.widgets.filter(w => ids.includes(w.id));
  if (ws.length < 2) return;
  saveUndoState();
  const minX = Math.min(...ws.map(w => w.x));
  ws.forEach(w => w.x = minX);
  renderWidgets();
  toast('â«· Aligned left', 'success');
}

function alignRight() {
  const ids = state.multiSelect.length ? state.multiSelect : [state.selected];
  const ws = state.widgets.filter(w => ids.includes(w.id));
  if (ws.length < 2) return;
  saveUndoState();
  const maxX = Math.max(...ws.map(w => w.x + w.w));
  ws.forEach(w => w.x = maxX - w.w);
  renderWidgets();
  toast('â«¸ Aligned right', 'success');
}

function alignTop() {
  const ids = state.multiSelect.length ? state.multiSelect : [state.selected];
  const ws = state.widgets.filter(w => ids.includes(w.id));
  if (ws.length < 2) return;
  saveUndoState();
  const minY = Math.min(...ws.map(w => w.y));
  ws.forEach(w => w.y = minY);
  renderWidgets();
  toast('â«  Aligned top', 'success');
}

function alignBottom() {
  const ids = state.multiSelect.length ? state.multiSelect : [state.selected];
  const ws = state.widgets.filter(w => ids.includes(w.id));
  if (ws.length < 2) return;
  saveUndoState();
  const maxY = Math.max(...ws.map(w => w.y + w.h));
  ws.forEach(w => w.y = maxY - w.h);
  renderWidgets();
  toast('â«Ÿ Aligned bottom', 'success');
}

function alignCenterH() {
  const ids = state.multiSelect.length ? state.multiSelect : [state.selected];
  const ws = state.widgets.filter(w => ids.includes(w.id));
  if (ws.length < 2) return;
  saveUndoState();
  const avgX = ws.reduce((s, w) => s + w.x + w.w/2, 0) / ws.length;
  ws.forEach(w => w.x = avgX - w.w/2);
  renderWidgets();
  toast('â«¿ Aligned center H', 'success');
}

function alignCenterV() {
  const ids = state.multiSelect.length ? state.multiSelect : [state.selected];
  const ws = state.widgets.filter(w => ids.includes(w.id));
  if (ws.length < 2) return;
  saveUndoState();
  const avgY = ws.reduce((s, w) => s + w.y + w.h/2, 0) / ws.length;
  ws.forEach(w => w.y = avgY - w.h/2);
  renderWidgets();
  toast('â«¿ Aligned center V', 'success');
}

// === THEME FUNCTIONS ===
function setTheme(name) {
  state.theme = name;
  document.body.className = document.body.className.replace(/theme-\w+/g, '');
  if (name !== 'dark') document.body.classList.add('theme-' + name);
  toast(`ðŸŽ¨ Theme: ${name}`, 'success');
  try { localStorage.setItem('widget_theme', name); } catch(e) {}
}

function cycleTheme() {
  const themes = Object.keys(THEMES);
  const idx = (themes.indexOf(state.theme) + 1) % themes.length;
  setTheme(themes[idx]);
}

// === GROUPING ===
function groupSelected() {
  if (state.multiSelect.length < 2) { toast('Select 2+ widgets', 'error'); return; }
  const groupId = 'g' + Date.now();
  state.groups[groupId] = [...state.multiSelect];
  state.widgets.filter(w => state.multiSelect.includes(w.id)).forEach(w => w.groupId = groupId);
  renderWidgets();
  toast(`âš­ Grouped ${state.multiSelect.length} widgets`, 'success');
}

function ungroupSelected() {
  const w = getSelectedWidget();
  if (!w || !w.groupId) { toast('Select a grouped widget', 'error'); return; }
  const gid = w.groupId;
  state.widgets.filter(x => x.groupId === gid).forEach(x => delete x.groupId);
  delete state.groups[gid];
  renderWidgets();
  toast('âš¯ Ungrouped', 'success');
}

// === LAYERS ===
function toggleLayers() {
  state.showLayers = !state.showLayers;
  let panel = $('#layersPanel');
  if (!panel) {
    panel = document.createElement('div');
    panel.id = 'layersPanel';
    panel.className = 'layers-panel';
    document.body.appendChild(panel);
  }
  panel.classList.toggle('show', state.showLayers);
  if (state.showLayers) renderLayersPanel();
}

function renderLayersPanel() {
  const panel = $('#layersPanel');
  if (!panel) return;
  panel.innerHTML = `
    <div class="layers-header">Layers <button onclick="toggleLayers()" style="background:none;border:none;color:white;cursor:pointer">âœ•</button></div>
    <div class="layers-list">${state.widgets.map((w, i) => `
      <div class="layer-item ${w.id === state.selected ? 'selected' : ''}" onclick="state.selected='${w.id}';updateSelectionUI();renderLayersPanel()">
        <span class="layer-icon">${ICONS[w.t]}</span>
        <span>${w.label || w.id}</span>
        <span class="layer-vis visible" onclick="event.stopPropagation();toggleWidgetVis('${w.id}')">ðŸ‘</span>
      </div>
    `).reverse().join('')}</div>
  `;
}

function toggleWidgetVis(id) {
  const w = state.widgets.find(x => x.id === id);
  if (w) { w.hidden = !w.hidden; renderWidgets(); renderLayersPanel(); }
}

function moveLayerUp() {
  if (!state.selected) return;
  const idx = state.widgets.findIndex(w => w.id === state.selected);
  if (idx < state.widgets.length - 1) {
    [state.widgets[idx], state.widgets[idx+1]] = [state.widgets[idx+1], state.widgets[idx]];
    renderWidgets();
  }
}

function moveLayerDown() {
  if (!state.selected) return;
  const idx = state.widgets.findIndex(w => w.id === state.selected);
  if (idx > 0) {
    [state.widgets[idx], state.widgets[idx-1]] = [state.widgets[idx-1], state.widgets[idx]];
    renderWidgets();
  }
}

// === SHARE/EXPORT ===
function shareURL() {
  const data = { title: $('#titleInput')?.value || 'Remote', widgets: state.widgets };
  const encoded = btoa(unescape(encodeURIComponent(JSON.stringify(data))));
  const url = location.origin + location.pathname + '?layout=' + encoded;
  navigator.clipboard.writeText(url).then(() => toast('ðŸ”— Link copied!', 'success'));
}

function generateQR() {
  const data = { title: $('#titleInput')?.value || 'Remote', widgets: state.widgets };
  const encoded = btoa(unescape(encodeURIComponent(JSON.stringify(data))));
  const url = location.origin + location.pathname + '?layout=' + encoded;
  // Using QR code API
  const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(url)}`;
  
  let modal = $('#shareModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'shareModal';
    modal.className = 'share-modal';
    modal.innerHTML = `<div class="share-content">
      <h3>ðŸ“± Scan to Share</h3>
      <img class="share-qr" src="" alt="QR Code">
      <input class="share-link" readonly>
      <button onclick="navigator.clipboard.writeText(this.previousElementSibling.value);toast('Copied!','success')" style="padding:10px 20px;border:none;border-radius:8px;background:var(--accent);cursor:pointer">ðŸ“‹ Copy Link</button>
      <button onclick="this.closest('.share-modal').classList.remove('show')" style="padding:10px 20px;border:none;border-radius:8px;background:rgba(255,255,255,0.1);color:white;cursor:pointer;margin-left:8px">Close</button>
    </div>`;
    document.body.appendChild(modal);
  }
  modal.querySelector('.share-qr').src = qrUrl;
  modal.querySelector('.share-link').value = url;
  modal.classList.add('show');
}

function exportScreenshot() {
  const canvas = $('#canvas');
  if (!canvas) return;
  // Use html2canvas if available, otherwise simple approach
  toast('ðŸ“¸ Preparing screenshot...', 'success');
  import('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.esm.min.js')
    .then(mod => mod.default(canvas))
    .then(c => {
      const link = document.createElement('a');
      link.download = 'remote-layout.png';
      link.href = c.toDataURL();
      link.click();
      toast('ðŸ“¸ Screenshot saved!', 'success');
    })
    .catch(() => toast('Screenshot requires html2canvas', 'error'));
}

// === WIDGET TEMPLATES ===
function saveWidgetTemplate() {
  const ids = state.multiSelect.length ? state.multiSelect : (state.selected ? [state.selected] : []);
  if (!ids.length) { toast('Select widgets first', 'error'); return; }
  const name = prompt('Template name:');
  if (!name) return;
  const widgets = state.widgets.filter(w => ids.includes(w.id)).map(w => ({...w}));
  // Normalize positions
  const minX = Math.min(...widgets.map(w => w.x));
  const minY = Math.min(...widgets.map(w => w.y));
  widgets.forEach(w => { w.x -= minX; w.y -= minY; delete w.id; });
  state.widgetTemplates.push({ name, widgets });
  try { localStorage.setItem('widget_templates', JSON.stringify(state.widgetTemplates)); } catch(e) {}
  toast(`ðŸ’¾ Template "${name}" saved`, 'success');
}

function loadWidgetTemplates() {
  try {
    state.widgetTemplates = JSON.parse(localStorage.getItem('widget_templates') || '[]');
  } catch(e) { state.widgetTemplates = []; }
}

function showTemplateMenu() {
  if (!state.widgetTemplates.length) { toast('No saved templates', 'error'); return; }
  const name = prompt('Templates:\n' + state.widgetTemplates.map((t,i) => `${i+1}. ${t.name}`).join('\n') + '\n\nEnter number:');
  const idx = parseInt(name) - 1;
  if (isNaN(idx) || !state.widgetTemplates[idx]) return;
  saveUndoState();
  const tpl = state.widgetTemplates[idx];
  tpl.widgets.forEach(w => {
    state.widgets.push({ ...w, id: `${w.t}${state.nextId++}`, x: w.x + 20, y: w.y + 20 });
  });
  renderWidgets();
  toast(`ðŸ“‚ Loaded "${tpl.name}"`, 'success');
}

// === RULER ===
function toggleRuler() {
  state.showRuler = !state.showRuler;
  const canvas = $('#canvas');
  let rulerH = canvas.querySelector('.ruler-h');
  let rulerV = canvas.querySelector('.ruler-v');
  
  if (state.showRuler) {
    if (!rulerH) {
      rulerH = document.createElement('div');
      rulerH.className = 'ruler ruler-h';
      canvas.appendChild(rulerH);
    }
    if (!rulerV) {
      rulerV = document.createElement('div');
      rulerV.className = 'ruler ruler-v';
      canvas.appendChild(rulerV);
    }
    // Add marks
    for (let i = 0; i <= 1000; i += 50) {
      const mh = document.createElement('span');
      mh.className = 'ruler-mark';
      mh.style.left = i + 'px';
      mh.textContent = i;
      rulerH.appendChild(mh);
      const mv = document.createElement('span');
      mv.className = 'ruler-mark';
      mv.style.top = i + 'px';
      mv.textContent = i;
      rulerV.appendChild(mv);
    }
    toast('ðŸ“ Ruler ON', 'success');
  } else {
    if (rulerH) rulerH.remove();
    if (rulerV) rulerV.remove();
    toast('ðŸ“ Ruler OFF', 'success');
  }
}

// === SENSOR SIMULATOR ===
function toggleSensorSim() {
  let sim = $('#sensorSim');
  if (!sim) {
    sim = document.createElement('div');
    sim.id = 'sensorSim';
    sim.className = 'sensor-sim';
    sim.innerHTML = `
      <div class="sensor-group">
        <div class="sensor-label">Accel X</div>
        <input type="range" class="sensor-slider" min="-1024" max="1024" value="0" oninput="simSensor('accelX', this.value)">
        <div class="sensor-value" id="simAccelX">0</div>
      </div>
      <div class="sensor-group">
        <div class="sensor-label">Accel Y</div>
        <input type="range" class="sensor-slider" min="-1024" max="1024" value="0" oninput="simSensor('accelY', this.value)">
        <div class="sensor-value" id="simAccelY">0</div>
      </div>
      <div class="sensor-group">
        <div class="sensor-label">Light</div>
        <input type="range" class="sensor-slider" min="0" max="255" value="128" oninput="simSensor('light', this.value)">
        <div class="sensor-value" id="simLight">128</div>
      </div>
      <div class="sensor-group">
        <div class="sensor-label">Temp</div>
        <input type="range" class="sensor-slider" min="-10" max="50" value="25" oninput="simSensor('temp', this.value)">
        <div class="sensor-value" id="simTemp">25Â°</div>
      </div>
      <button onclick="$('#sensorSim').classList.remove('show')" style="padding:8px;border:none;border-radius:8px;background:rgba(255,255,255,0.1);color:white;cursor:pointer">âœ•</button>
    `;
    document.body.appendChild(sim);
  }
  sim.classList.toggle('show');
}

function simSensor(type, value) {
  const el = $(`#sim${type.charAt(0).toUpperCase() + type.slice(1)}`);
  if (el) el.textContent = value + (type === 'temp' ? 'Â°' : '');
  // Could send to widgets that listen to sensors
}

// === LOAD URL LAYOUT ===
function loadURLLayout() {
  const params = new URLSearchParams(location.search);
  const layout = params.get('layout');
  if (layout) {
    try {
      const data = JSON.parse(decodeURIComponent(escape(atob(layout))));
      if (data.widgets) {
        state.widgets = data.widgets.map(w => ({ ...w, id: w.id || `${w.t}${state.nextId++}` }));
        if (data.title && $('#titleInput')) $('#titleInput').value = data.title;
        renderWidgets();
        toast('ðŸ“‚ Layout loaded from URL', 'success');
      }
    } catch(e) { console.error('Failed to load URL layout', e); }
  }
}

// === CANVAS BACKGROUND ===
function setCanvasBackground() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  input.onchange = e => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = ev => {
        state.canvasBg = ev.target.result;
        const canvas = $('#canvas');
        if (canvas) {
          canvas.style.backgroundImage = `url(${state.canvasBg})`;
          canvas.style.backgroundSize = 'cover';
          canvas.style.backgroundPosition = 'center';
        }
        toast('ðŸ–¼ï¸ Background set', 'success');
      };
      reader.readAsDataURL(file);
    }
  };
  input.click();
}

function clearCanvasBackground() {
  state.canvasBg = null;
  const canvas = $('#canvas');
  if (canvas) {
    canvas.style.backgroundImage = '';
  }
  toast('ðŸ–¼ï¸ Background cleared', 'success');
}

// === HIGH CONTRAST MODE ===
function toggleHighContrast() {
  document.body.classList.toggle('high-contrast');
  const isHC = document.body.classList.contains('high-contrast');
  toast(isHC ? 'â— High Contrast ON' : 'â— High Contrast OFF', 'success');
  try { localStorage.setItem('high_contrast', isHC ? '1' : '0'); } catch(e) {}
}

// Load high contrast preference
function loadHighContrastPref() {
  try {
    if (localStorage.getItem('high_contrast') === '1') {
      document.body.classList.add('high-contrast');
    }
  } catch(e) {}
}

// === HELP/SHORTCUTS MODAL ===
function showHelp() {
  let modal = $('#helpModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'helpModal';
    modal.className = 'share-modal';
    modal.innerHTML = `<div class="share-content" style="max-width:500px;text-align:left;">
      <h3>âŒ¨ï¸ Keyboard Shortcuts</h3>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:13px;margin:16px 0;">
        <div><kbd>Ctrl+Z</kbd> Undo</div>
        <div><kbd>Ctrl+Shift+Z</kbd> Redo</div>
        <div><kbd>Ctrl+C</kbd> Copy</div>
        <div><kbd>Ctrl+V</kbd> Paste</div>
        <div><kbd>Ctrl+D</kbd> Duplicate</div>
        <div><kbd>Ctrl+G</kbd> Group</div>
        <div><kbd>Ctrl+S</kbd> Save Template</div>
        <div><kbd>Ctrl+A</kbd> Select All</div>
        <div><kbd>Delete</kbd> Delete</div>
        <div><kbd>Escape</kbd> Deselect</div>
        <div><kbd>G</kbd> Toggle Grid</div>
        <div><kbd>L</kbd> Toggle Layers</div>
        <div><kbd>T</kbd> Cycle Theme</div>
        <div><kbd>Arrow Keys</kbd> Nudge 1px</div>
        <div><kbd>Shift+Arrow</kbd> Nudge 10px</div>
        <div><kbd>Shift+Click</kbd> Multi-select</div>
      </div>
      <h3>ðŸ–±ï¸ Mouse Actions</h3>
      <div style="font-size:13px;margin:16px 0;">
        <div>â€¢ Shift+Drag on canvas: Selection box</div>
        <div>â€¢ Drag widget corner: Resize</div>
        <div>â€¢ Click canvas: Place selected widget type</div>
      </div>
      <button onclick="this.closest('.share-modal').classList.remove('show')" style="padding:10px 20px;border:none;border-radius:8px;background:var(--accent);cursor:pointer;width:100%">Got it!</button>
    </div>`;
    document.body.appendChild(modal);
  }
  modal.classList.add('show');
}

// === PIN MAPPING HELPER ===
function showPinMapping() {
  let modal = $('#pinModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'pinModal';
    modal.className = 'share-modal';
    modal.innerHTML = `<div class="share-content" style="max-width:450px;text-align:left;">
      <h3>ðŸ“Œ micro:bit Pin Reference</h3>
      <div style="font-size:13px;margin:16px 0;line-height:1.6;">
        <div><b>P0, P1, P2</b> - Large pins (touch, analog, digital)</div>
        <div><b>P3-P10</b> - LED matrix (shared)</div>
        <div><b>P11</b> - Button B (shared)</div>
        <div><b>P12</b> - Reserved</div>
        <div><b>P13-P15</b> - SPI (SCK, MISO, MOSI)</div>
        <div><b>P16</b> - General purpose</div>
        <div><b>P19, P20</b> - I2C (SCL, SDA)</div>
      </div>
      <h4>Common Uses:</h4>
      <div style="font-size:12px;margin:8px 0;opacity:0.8;">
        â€¢ Servo: P0, P1, P2 (PWM)<br>
        â€¢ LED Strip: P0 (NeoPixels)<br>
        â€¢ Sensor: P0-P2 (analog read)<br>
        â€¢ Motor: P0+P8 or P1+P12 (H-bridge)
      </div>
      <button onclick="this.closest('.share-modal').classList.remove('show')" style="padding:10px 20px;border:none;border-radius:8px;background:var(--accent);cursor:pointer;width:100%">Close</button>
    </div>`;
    document.body.appendChild(modal);
  }
  modal.classList.add('show');
}

// Grid snapping
function snapToGrid(val) {
  if (!state.gridSnap) return val;
  return Math.round(val / state.gridSize) * state.gridSize;
}

// Alignment guides
function showAlignGuides(w) {
  removeAlignGuides();
  if (!state.showGuides) return;
  const canvas = $('#canvas');
  const guides = [];
  const SNAP_DIST = 5;
  
  state.widgets.forEach(other => {
    if (other.id === w.id) return;
    // Vertical guides (left, center, right alignment)
    if (Math.abs(w.x - other.x) < SNAP_DIST) guides.push({type:'v', pos: other.x});
    if (Math.abs(w.x + w.w - other.x - other.w) < SNAP_DIST) guides.push({type:'v', pos: other.x + other.w});
    if (Math.abs(w.x + w.w/2 - other.x - other.w/2) < SNAP_DIST) guides.push({type:'v', pos: other.x + other.w/2});
    // Horizontal guides
    if (Math.abs(w.y - other.y) < SNAP_DIST) guides.push({type:'h', pos: other.y});
    if (Math.abs(w.y + w.h - other.y - other.h) < SNAP_DIST) guides.push({type:'h', pos: other.y + other.h});
    if (Math.abs(w.y + w.h/2 - other.y - other.h/2) < SNAP_DIST) guides.push({type:'h', pos: other.y + other.h/2});
  });
  
  guides.forEach(g => {
    const el = document.createElement('div');
    el.className = 'align-guide ' + (g.type === 'h' ? 'horizontal' : 'vertical');
    el.style[g.type === 'h' ? 'top' : 'left'] = g.pos + 'px';
    canvas.appendChild(el);
  });
}

function removeAlignGuides() {
  $$('.align-guide').forEach(el => el.remove());
}

// Canvas auto-expand
function updateCanvasSize() {
  const canvas = $('#canvas');
  if (!canvas) return;
  let maxX = 400, maxY = 300;
  state.widgets.forEach(w => {
    maxX = Math.max(maxX, w.x + w.w + 40);
    maxY = Math.max(maxY, w.y + w.h + 40);
  });
  canvas.style.minWidth = maxX + 'px';
  canvas.style.minHeight = maxY + 'px';
}

// Minimap
function updateMinimap() {
  const minimap = $('#minimap');
  if (!minimap) return;
  const canvas = $('#canvas');
  if (!canvas) return;
  
  const scale = 0.1;
  minimap.innerHTML = '';
  
  state.widgets.forEach(w => {
    const el = document.createElement('div');
    el.className = 'minimap-widget';
    el.style.cssText = `left:${w.x*scale}px;top:${w.y*scale}px;width:${Math.max(4,w.w*scale)}px;height:${Math.max(4,w.h*scale)}px;background:${w.color || 'var(--accent)'}`;
    minimap.appendChild(el);
  });
}

// Zoom
function setZoom(z) {
  state.zoom = Math.max(0.5, Math.min(2, z));
  const layer = $('#widgetsLayer');
  if (layer) layer.style.transform = `scale(${state.zoom})`;
  const zoomEl = $('#zoomLevel');
  if (zoomEl) zoomEl.textContent = Math.round(state.zoom * 100) + '%';
}

// Nudge with arrow keys
function nudgeSelected(dx, dy) {
  const ids = state.multiSelect.length ? state.multiSelect : (state.selected ? [state.selected] : []);
  if (!ids.length) return;
  saveUndoState();
  state.widgets.filter(w => ids.includes(w.id) && !w.locked).forEach(w => {
    w.x = Math.max(0, w.x + dx);
    w.y = Math.max(0, w.y + dy);
  });
  resolveOverlaps(null);
  renderWidgets();
}

// Setup canvas tools UI
function setupCanvasTools() {
  const canvas = $('#canvas');
  if (!canvas) return;

  // Our helper tools live in the draggable Helper Panel UI
  try { ensureHelperUI(); } catch(e) {}
}

function startSelectionBox(e) {
  const canvas = $('#canvas');
  const rect = canvas.getBoundingClientRect();
  selBoxStart = { x: e.clientX - rect.left, y: e.clientY - rect.top };
  selectionBox = document.createElement('div');
  selectionBox.className = 'selection-box';
  canvas.appendChild(selectionBox);
}

function updateSelectionBox(e) {
  if (!selectionBox || !selBoxStart) return;
  const canvas = $('#canvas');
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const left = Math.min(x, selBoxStart.x);
  const top = Math.min(y, selBoxStart.y);
  const width = Math.abs(x - selBoxStart.x);
  const height = Math.abs(y - selBoxStart.y);
  selectionBox.style.cssText = `left:${left}px;top:${top}px;width:${width}px;height:${height}px`;
}

function endSelectionBox() {
  if (!selectionBox || !selBoxStart) return;
  const box = selectionBox.getBoundingClientRect();
  const canvas = $('#canvas');
  const cRect = canvas.getBoundingClientRect();
  
  const boxLeft = box.left - cRect.left;
  const boxTop = box.top - cRect.top;
  const boxRight = boxLeft + box.width;
  const boxBottom = boxTop + box.height;
  
  state.multiSelect = state.widgets.filter(w => {
    return w.x < boxRight && w.x + w.w > boxLeft && w.y < boxBottom && w.y + w.h > boxTop;
  }).map(w => w.id);
  
  selectionBox.remove();
  selectionBox = null;
  selBoxStart = null;
  updateSelectionUI();
  if (state.multiSelect.length) toast(`Selected ${state.multiSelect.length} widgets`, 'success');
}

// Auto-resize canvas based on widget positions
function autoResizeCanvas() {
  const canvas = $('#canvas');
  if (!canvas || !state.widgets.length) return;
  
  // Calculate needed size based on widget positions
  let maxX = 0, maxY = 0;
  state.widgets.forEach(w => {
    maxX = Math.max(maxX, w.x + w.w + 15);
    maxY = Math.max(maxY, w.y + w.h + 15);
  });
  
  // Strict limits
  const minH = 280;
  const maxH = 500;
  
  const newH = Math.max(minH, Math.min(maxH, maxY));
  canvas.style.minHeight = newH + 'px';
}

function renderWidgets() {
  const layer = $('#widgetsLayer');
  layer.innerHTML = '';
  
  setupCanvasTools();
  
  state.widgets.forEach(w => {
    const el = document.createElement('div');
    const isMulti = state.multiSelect.includes(w.id);
    el.className = 'widget' + (state.selected === w.id ? ' selected' : '') + (isMulti ? ' multi-selected' : '') + (w.locked ? ' locked' : '') + (w.hidden ? ' hidden' : '') + (w.groupId ? ' grouped' : '');
    el.dataset.id = w.id;
    
    // Build style with all properties
    let styles = `left:${w.x}px;top:${w.y}px;width:${w.w}px;height:${w.h}px`;
    if (w.borderStyle) styles += `;border-style:${w.borderStyle}`;
    if (w.borderRadius !== undefined) styles += `;border-radius:${w.borderRadius}px`;
    if (w.shadow === 'soft') styles += `;box-shadow:0 10px 30px rgba(0,0,0,0.3)`;
    else if (w.shadow === 'glow') styles += `;box-shadow:0 0 30px ${w.color || 'var(--accent)'}`;
    else if (w.shadow === 'neon') styles += `;box-shadow:0 0 20px ${w.color || '#ff00ff'}, 0 0 40px ${w.color || '#ff00ff'}`;
    if (w.hidden) styles += `;display:none`;
    el.style.cssText = styles;
    
    let colorDot = w.color ? `<div class="widget-color-dot" style="background:${w.color}"></div>` : '';
    // Add orientation indicator for sliders
    let orientIndicator = '';
    if (w.t === 'slider') {
      const isVertical = (w.h || 100) > (w.w || 100);
      orientIndicator = `<div class="widget-orient-badge">${isVertical ? 'â†•' : 'â†”'}</div>`;
    }
    const resizeHandles = `
      <div class="resize-handle handle-n"></div>
      <div class="resize-handle handle-s"></div>
      <div class="resize-handle handle-e"></div>
      <div class="resize-handle handle-w"></div>
      <div class="resize-handle handle-ne"></div>
      <div class="resize-handle handle-nw"></div>
      <div class="resize-handle handle-se"></div>
      <div class="resize-handle handle-sw"></div>
    `;
    el.innerHTML = `${colorDot}<div class="widget-icon">${ICONS[w.t]}</div><div class="widget-label">${esc(w.label) || w.t}</div>${orientIndicator}${resizeHandles}`;
    layer.appendChild(el);
    
    if (!w.locked) {
      interact(el).draggable({
        inertia: false,
        listeners: {
          start() { 
            saveUndoState();
            state.selected = w.id; 
            updateSelectionUI(); 
          },
          move(e) {
            state.justDragged = true;
            clearTimeout(state._dragT);
            state._dragT = setTimeout(() => state.justDragged = false, 50);
            
            let newX = w.x + e.dx;
            let newY = w.y + e.dy;
            
            if (state.gridSnap) {
              newX = snapToGrid(newX);
              newY = snapToGrid(newY);
            }
            
            // Clamp to canvas bounds
            const canvas = $('#canvas');
            const maxX = (canvas?.offsetWidth || 500) - w.w - 10;
            const maxY = (canvas?.offsetHeight || 400) - w.h - 10;
            
            w.x = Math.max(0, Math.min(maxX, newX));
            w.y = Math.max(0, Math.min(maxY, newY));
            e.target.style.left = w.x + 'px';
            e.target.style.top = w.y + 'px';
            
            showAlignGuides(w);
            resolveOverlaps(w);
            autoResizeCanvas();
          },
          end() {
            removeAlignGuides();
            autoResizeCanvas();
            scheduleAutoSave();
          }
        }
      }).resizable({
        edges: { 
          top: '.handle-n, .handle-ne, .handle-nw',
          bottom: '.handle-s, .handle-se, .handle-sw',
          left: '.handle-w, .handle-nw, .handle-sw',
          right: '.handle-e, .handle-ne, .handle-se'
        },
        modifiers: [interact.modifiers.restrictSize({ min: { width: 60, height: 60 } })],
        listeners: {
          start() { saveUndoState(); },
          move(e) {
            // Handle position changes from top/left edges
            let newX = w.x + (e.deltaRect.left || 0);
            let newY = w.y + (e.deltaRect.top || 0);
            let newW = state.gridSnap ? snapToGrid(e.rect.width) : e.rect.width;
            let newH = state.gridSnap ? snapToGrid(e.rect.height) : e.rect.height;
            
            // Clamp to canvas
            const canvas = $('#canvas');
            const canvasW = canvas?.offsetWidth || 500;
            const canvasH = canvas?.offsetHeight || 400;
            
            // Ensure widget stays in bounds
            newX = Math.max(0, Math.min(canvasW - 60, newX));
            newY = Math.max(0, Math.min(canvasH - 60, newY));
            newW = Math.max(60, Math.min(canvasW - newX - 5, newW));
            newH = Math.max(60, Math.min(canvasH - newY - 5, newH));
            
            w.x = newX;
            w.y = newY;
            w.w = newW;
            w.h = newH;
            
            e.target.style.left = w.x + 'px';
            e.target.style.top = w.y + 'px';
            e.target.style.width = w.w + 'px';
            e.target.style.height = w.h + 'px';
            resolveOverlaps(w);
          },
          end() { autoResizeCanvas(); scheduleAutoSave(); }
        }
      });
    }
    
    el.onclick = e => { 
      e.stopPropagation(); 
      if (e.shiftKey) {
        // Multi-select with shift
        if (state.multiSelect.includes(w.id)) {
          state.multiSelect = state.multiSelect.filter(id => id !== w.id);
        } else {
          state.multiSelect.push(w.id);
        }
      } else {
        state.multiSelect = [];
        state.selected = w.id; 
      }
      updateSelectionUI(); 
    };
  });
  
  resolveOverlaps(null);
  updateMinimap();
  saveUndoState();
  
  // Auto-save project
  scheduleAutoSave();
}


function updateSelectionUI() {
  $$('.widget').forEach(el => {
    const id = el.dataset.id;
    el.classList.toggle('selected', id === state.selected);
    el.classList.toggle('multi-selected', state.multiSelect.includes(id));
  });
  renderPropsPanel();
}

function getSelectedWidget(){
  return state.widgets.find(w => w.id === state.selected);
}

function renderPropsPanel(){
  const form = $('#propsForm');
  const empty = $('#propsEmpty');
  const w = getSelectedWidget();

  if (!form || !empty) return;

  if (!w){
    empty.style.display = 'block';
    form.style.display = 'none';
    form.innerHTML = '';
    // Hide mobile panel when no widget selected
    if (typeof hideMobilePropsPanel === 'function') hideMobilePropsPanel();
    return;
  }

  empty.style.display = 'none';
  form.style.display = 'block';
  
  // Show mobile panel when widget is selected
  if (typeof showMobilePropsPanel === 'function') showMobilePropsPanel();

  // Common fields
  let html = `
    <label>Widget ID</label>
    <input id="prop_id" value="${esc(w.id)}" />

    <label>Label</label>
    <input id="prop_label" value="${esc(w.label || '')}" />

    <label>Widget Color</label>
    <input id="prop_color" type="color" value="${w.color || '#00d4ff'}" />

    <label>Lock Position</label>
    <select id="prop_locked">
      <option value="0" ${!w.locked ? 'selected' : ''}>Unlocked</option>
      <option value="1" ${w.locked ? 'selected' : ''}>Locked ðŸ”’</option>
    </select>

    <label>Border Style</label>
    <select id="prop_borderStyle">
      <option value="solid" ${(w.borderStyle || 'solid') === 'solid' ? 'selected' : ''}>Solid</option>
      <option value="dashed" ${w.borderStyle === 'dashed' ? 'selected' : ''}>Dashed</option>
      <option value="dotted" ${w.borderStyle === 'dotted' ? 'selected' : ''}>Dotted</option>
      <option value="none" ${w.borderStyle === 'none' ? 'selected' : ''}>None</option>
    </select>

    <label>Shadow/Glow</label>
    <select id="prop_shadow">
      <option value="none" ${!w.shadow ? 'selected' : ''}>None</option>
      <option value="soft" ${w.shadow === 'soft' ? 'selected' : ''}>Soft Shadow</option>
      <option value="glow" ${w.shadow === 'glow' ? 'selected' : ''}>Glow âœ¨</option>
      <option value="neon" ${w.shadow === 'neon' ? 'selected' : ''}>Neon ðŸŒˆ</option>
    </select>

    <label>Border Radius</label>
    <input id="prop_radius" type="range" min="0" max="50" value="${w.borderRadius ?? 16}" />

    <label>ðŸ“ Size & Orientation</label>
    <div class="props-row" style="gap:8px; margin-top:6px;">
      <div style="flex:1;">
        <label style="font-size:0.7rem; margin:0;">Width</label>
        <input id="prop_width" type="number" min="40" max="600" value="${w.w || 100}" style="width:100%;" />
      </div>
      <div style="flex:1;">
        <label style="font-size:0.7rem; margin:0;">Height</label>
        <input id="prop_height" type="number" min="40" max="600" value="${w.h || 100}" style="width:100%;" />
      </div>
    </div>
    <div class="props-row" style="gap:8px; margin-top:8px;">
      <button class="props-apply" id="prop_swapOrientation" style="flex:1; margin:0;">ðŸ”„ Swap Wâ†”H</button>
      <button class="props-apply" id="prop_resetSize" style="flex:1; margin:0;">â†©ï¸ Reset</button>
    </div>
    <div class="props-row" style="gap:4px; margin-top:8px; flex-wrap:wrap;">
      <button class="props-apply prop-preset-size" data-w="80" data-h="80" style="flex:1; margin:0; min-width:60px; padding:8px 4px; font-size:0.75rem;">S</button>
      <button class="props-apply prop-preset-size" data-w="120" data-h="120" style="flex:1; margin:0; min-width:60px; padding:8px 4px; font-size:0.75rem;">M</button>
      <button class="props-apply prop-preset-size" data-w="180" data-h="180" style="flex:1; margin:0; min-width:60px; padding:8px 4px; font-size:0.75rem;">L</button>
      <button class="props-apply prop-preset-size" data-w="250" data-h="250" style="flex:1; margin:0; min-width:60px; padding:8px 4px; font-size:0.75rem;">XL</button>
    </div>
  `;

  // Model selector (3 presets per widget type)
  const opts = modelOptionsForType(w.t);
  if (opts){
    html += `
      <label>Model</label>
      <select id="prop_model">
        ${opts.map(o => `<option value="${o.v}" ${w.model === o.v ? 'selected' : ''}>${o.name}</option>`).join('')}
      </select>
      <button class="props-apply" id="prop_applyAll">Apply this model to ALL ${w.t}s</button>
    `;
  }

  // Type-specific fields
  if (w.t === 'led'){
    html += `
      <label>LED On Color</label>
      <input id="prop_colorOn" type="color" value="${w.colorOn || '#ff5252'}" />

      <label>LED Off Color</label>
      <input id="prop_colorOff" type="color" value="${w.colorOff || '#2a2a3a'}" />
    `;
  }

  if (w.t === 'slider'){
    const isVertical = (w.h || 100) > (w.w || 100);
    html += `
      <label>ðŸ”„ Orientation</label>
      <select id="prop_sliderOrient">
        <option value="horizontal" ${!isVertical ? 'selected' : ''}>â†” Horizontal</option>
        <option value="vertical" ${isVertical ? 'selected' : ''}>â†• Vertical</option>
      </select>

      <label>Min</label>
      <input id="prop_min" type="number" value="${w.min ?? 0}" />

      <label>Max</label>
      <input id="prop_max" type="number" value="${w.max ?? 100}" />

      <label>Step</label>
      <input id="prop_step" type="number" value="${w.step ?? 1}" />
    `;
  }

  
  if (w.t === 'gauge'){
    html += `
      <label>Min</label>
      <input id="prop_gmin" type="number" value="${w.min ?? 0}" />

      <label>Max</label>
      <input id="prop_gmax" type="number" value="${w.max ?? 100}" />

      <label>Decimals</label>
      <input id="prop_gdec" type="number" value="${w.decimals ?? 0}" />

      <label>Units (optional)</label>
      <input id="prop_gunits" value="${esc(w.units || '')}" />

      <label>Warn (optional)</label>
      <input id="prop_gwarn" type="number" value="${w.warn ?? ''}" />

      <label>Danger (optional)</label>
      <input id="prop_gdanger" type="number" value="${w.danger ?? ''}" />
    `;
  }

  if (w.t === 'graph'){
    html += `
      <label>Series (1-10)</label>
      <input id="prop_series" type="number" min="1" max="10" value="${w.series ?? 1}" />

      <label>Window (seconds)</label>
      <input id="prop_window" type="number" min="5" max="120" value="${w.windowSec ?? 30}" />

      <label>Auto scale</label>
      <select id="prop_autoscale">
        <option value="1" ${w.autoScale !== false ? 'selected' : ''}>Yes</option>
        <option value="0" ${w.autoScale === false ? 'selected' : ''}>No</option>
      </select>

      <label>Fixed Min (when auto off)</label>
      <input id="prop_ymin" type="number" value="${w.yMin ?? 0}" />

      <label>Fixed Max (when auto off)</label>
      <input id="prop_ymax" type="number" value="${w.yMax ?? 100}" />

      <label>Series Names (comma separated)</label>
      <input id="prop_names" value="${esc((w.seriesNames || '').toString())}" placeholder="Temp,Level,Power" />

      <label>Y Axis Label (optional)</label>
      <input id="prop_ylabel" value="${esc(w.yLabel || '')}" placeholder="Â°C / % / rpm" />
    `;
  }

  if (w.t === 'image'){
    html += `
      <label>Image URL</label>
      <input id="prop_imageSrc" value="${esc(w.imageSrc || '')}" placeholder="https://..." />
      <button class="props-apply" id="prop_uploadImg">ðŸ“ Upload Image</button>
    `;
  }

  if (w.t === 'battery'){
    html += `
      <label>Initial Level (%)</label>
      <input id="prop_batteryLevel" type="number" min="0" max="100" value="${w.level ?? 100}" />
    `;
  }

  if (w.t === 'timer'){
    html += `
      <label>Count Direction</label>
      <select id="prop_timerDir">
        <option value="up" ${(w.timerDir || 'up') === 'up' ? 'selected' : ''}>Count Up â±ï¸</option>
        <option value="down" ${w.timerDir === 'down' ? 'selected' : ''}>Countdown â³</option>
      </select>
      <label>Initial Seconds (for countdown)</label>
      <input id="prop_timerStart" type="number" min="0" value="${w.timerStart ?? 60}" />
    `;
  }

form.innerHTML = html;

  // Wire events
  $('#prop_label').oninput = e => {
    w.label = e.target.value;
    const el = $(`.widget[data-id="${w.id}"] .widget-label`);
    if (el) el.textContent = w.label || w.t;
  };

  $('#prop_color').oninput = e => {
    w.color = e.target.value;
    const dot = $(`.widget[data-id="${w.id}"] .widget-color-dot`);
    if (dot) dot.style.background = w.color;
    else renderWidgets();
    updateMinimap();
  };

  $('#prop_locked').onchange = e => {
    w.locked = e.target.value === '1';
    renderWidgets();
    toast(w.locked ? 'ðŸ”’ Widget locked' : 'ðŸ”“ Widget unlocked', 'success');
  };

  $('#prop_borderStyle').onchange = e => {
    w.borderStyle = e.target.value;
    const el = $(`.widget[data-id="${w.id}"]`);
    if (el) el.style.borderStyle = w.borderStyle;
  };

  $('#prop_shadow').onchange = e => {
    w.shadow = e.target.value;
    const el = $(`.widget[data-id="${w.id}"]`);
    if (el) {
      if (w.shadow === 'soft') el.style.boxShadow = '0 10px 30px rgba(0,0,0,0.3)';
      else if (w.shadow === 'glow') el.style.boxShadow = `0 0 30px ${w.color || 'var(--accent)'}`;
      else if (w.shadow === 'neon') el.style.boxShadow = `0 0 20px ${w.color || '#ff00ff'}, 0 0 40px ${w.color || '#ff00ff'}`;
      else el.style.boxShadow = '';
    }
  };

  $('#prop_radius').oninput = e => {
    w.borderRadius = parseInt(e.target.value);
    const el = $(`.widget[data-id="${w.id}"]`);
    if (el) el.style.borderRadius = w.borderRadius + 'px';
  };

  // Size and orientation controls
  const widthInput = $('#prop_width');
  const heightInput = $('#prop_height');
  
  if (widthInput) {
    widthInput.oninput = e => {
      const newW = Math.max(40, Math.min(600, parseInt(e.target.value) || 100));
      w.w = newW;
      const el = $(`.widget[data-id="${w.id}"]`);
      if (el) el.style.width = w.w + 'px';
      resolveOverlaps(w);
      updateMinimap();
    };
  }
  
  if (heightInput) {
    heightInput.oninput = e => {
      const newH = Math.max(40, Math.min(600, parseInt(e.target.value) || 100));
      w.h = newH;
      const el = $(`.widget[data-id="${w.id}"]`);
      if (el) el.style.height = w.h + 'px';
      resolveOverlaps(w);
      updateMinimap();
    };
  }
  
  const swapBtn = $('#prop_swapOrientation');
  if (swapBtn) {
    swapBtn.onclick = () => {
      saveUndoState();
      const oldW = w.w;
      const oldH = w.h;
      w.w = oldH;
      w.h = oldW;
      // Update inputs
      if (widthInput) widthInput.value = w.w;
      if (heightInput) heightInput.value = w.h;
      // Update widget visual
      const el = $(`.widget[data-id="${w.id}"]`);
      if (el) {
        el.style.width = w.w + 'px';
        el.style.height = w.h + 'px';
      }
      resolveOverlaps(w);
      updateMinimap();
      toast('ðŸ”„ Orientation swapped!', 'success');
    };
  }
  
  const resetBtn = $('#prop_resetSize');
  if (resetBtn) {
    resetBtn.onclick = () => {
      saveUndoState();
      const defaults = SIZES[w.t] || [100, 100];
      w.w = defaults[0];
      w.h = defaults[1];
      // Update inputs
      if (widthInput) widthInput.value = w.w;
      if (heightInput) heightInput.value = w.h;
      // Update widget visual
      const el = $(`.widget[data-id="${w.id}"]`);
      if (el) {
        el.style.width = w.w + 'px';
        el.style.height = w.h + 'px';
      }
      resolveOverlaps(w);
      updateMinimap();
      toast('â†©ï¸ Size reset to default!', 'success');
    };
  }
  
  // Preset size buttons
  $$('.prop-preset-size').forEach(btn => {
    btn.onclick = () => {
      saveUndoState();
      const presetW = parseInt(btn.dataset.w) || 100;
      const presetH = parseInt(btn.dataset.h) || 100;
      w.w = presetW;
      w.h = presetH;
      // Update inputs
      if (widthInput) widthInput.value = w.w;
      if (heightInput) heightInput.value = w.h;
      // Update widget visual
      const el = $(`.widget[data-id="${w.id}"]`);
      if (el) {
        el.style.width = w.w + 'px';
        el.style.height = w.h + 'px';
      }
      resolveOverlaps(w);
      updateMinimap();
      toast(`ðŸ“ Size set to ${presetW}Ã—${presetH}`, 'success');
    };
  });

  $('#prop_id').onchange = e => {
    const newId = e.target.value.trim();
    if (!newId || state.widgets.some(x => x.id === newId && x !== w)){
      toast('âŒ ID must be unique', 'error');
      e.target.value = w.id;
      return;
    }
    const oldId = w.id;
    w.id = newId;

    const root = $(`.widget[data-id="${oldId}"]`);
    if (root) root.dataset.id = newId;

    if (state.values[oldId] != null){
      state.values[newId] = state.values[oldId];
      delete state.values[oldId];
    }

    state.selected = newId;
    updateSelectionUI();
    toast('âœ… ID updated', 'success');
  };

  // Model wiring (and quick apply to all widgets of same type)
  const modelSel = $('#prop_model');
  if (modelSel){
    modelSel.onchange = e => { w.model = e.target.value; toast('âœ… Model updated', 'success'); };
  }
  const applyBtn = $('#prop_applyAll');
  if (applyBtn){
    applyBtn.onclick = () => {
      const val = w.model;
      state.widgets.forEach(x => { if (x.t === w.t) x.model = val; });
      if (state.config?.widgets) state.config.widgets.forEach(x => { if (x.t === w.t) x.model = val; });
      renderWidgets();
      if (state.config) renderRuntime();
      toast(`âœ¨ Applied model to all ${w.t}s`, 'success');
    };
  }


  if (w.t === 'led'){
    $('#prop_colorOn').oninput = e => { w.colorOn = e.target.value; };
    $('#prop_colorOff').oninput = e => { w.colorOff = e.target.value; };
  }

  if (w.t === 'slider'){
    const orientSel = $('#prop_sliderOrient');
    if (orientSel) {
      orientSel.onchange = e => {
        saveUndoState();
        const isVertical = e.target.value === 'vertical';
        const currentW = w.w || 100;
        const currentH = w.h || 100;
        
        // If orientation doesn't match current dimensions, swap them
        const currentIsVertical = currentH > currentW;
        if (isVertical !== currentIsVertical) {
          w.w = currentH;
          w.h = currentW;
          // Update the width/height inputs
          const widthInput = $('#prop_width');
          const heightInput = $('#prop_height');
          if (widthInput) widthInput.value = w.w;
          if (heightInput) heightInput.value = w.h;
        }
        
        renderWidgets();
        updateMinimap();
        toast(isVertical ? 'â†• Slider set to vertical' : 'â†” Slider set to horizontal', 'success');
      };
    }
    $('#prop_min').oninput = e => { w.min = parseFloat(e.target.value); };
    $('#prop_max').oninput = e => { w.max = parseFloat(e.target.value); };
    $('#prop_step').oninput = e => { w.step = parseFloat(e.target.value); };
  }

  if (w.t === 'gauge'){
    $('#prop_gmin').oninput = e => { w.min = parseFloat(e.target.value); if (state.config) renderRuntime(); };
    $('#prop_gmax').oninput = e => { w.max = parseFloat(e.target.value); if (state.config) renderRuntime(); };
    $('#prop_gdec').oninput = e => { w.decimals = parseInt(e.target.value, 10); if (state.config) renderRuntime(); };
    $('#prop_gunits').oninput = e => { w.units = e.target.value; if (state.config) renderRuntime(); };
    $('#prop_gwarn').oninput = e => { w.warn = e.target.value === '' ? null : parseFloat(e.target.value); };
    $('#prop_gdanger').oninput = e => { w.danger = e.target.value === '' ? null : parseFloat(e.target.value); };
  }

  if (w.t === 'graph'){
    $('#prop_series').oninput = e => { w.series = Math.max(1, Math.min(10, parseInt(e.target.value, 10) || 1)); if (state.config) renderRuntime(); };
    $('#prop_window').oninput = e => { w.windowSec = Math.max(5, parseInt(e.target.value, 10) || 30); };
    $('#prop_autoscale').onchange = e => { w.autoScale = (e.target.value === '1'); };
    $('#prop_ymin').oninput = e => { w.yMin = parseFloat(e.target.value); };
    $('#prop_ymax').oninput = e => { w.yMax = parseFloat(e.target.value); };
    $('#prop_names').oninput = e => { w.seriesNames = e.target.value; if (state.config) renderRuntime(); };
    $('#prop_ylabel').oninput = e => { w.yLabel = e.target.value; };
  }

  if (w.t === 'image'){
    $('#prop_imageSrc').oninput = e => { w.imageSrc = e.target.value; renderWidgets(); };
    const uploadBtn = $('#prop_uploadImg');
    if (uploadBtn) {
      uploadBtn.onclick = () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.onchange = e => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = ev => {
              w.imageSrc = ev.target.result;
              $('#prop_imageSrc').value = '[Uploaded Image]';
              renderWidgets();
              toast('ðŸ–¼ï¸ Image uploaded', 'success');
            };
            reader.readAsDataURL(file);
          }
        };
        input.click();
      };
    }
  }

  if (w.t === 'battery'){
    const battInput = $('#prop_batteryLevel');
    if (battInput) battInput.oninput = e => { w.level = parseInt(e.target.value); };
  }

  if (w.t === 'timer'){
    const timerDir = $('#prop_timerDir');
    if (timerDir) timerDir.onchange = e => { w.timerDir = e.target.value; };
    const timerStart = $('#prop_timerStart');
    if (timerStart) timerStart.oninput = e => { w.timerStart = parseInt(e.target.value); };
  }

}


function deleteSelected() {
  if (!state.selected) { toast('ðŸ‘† Select a widget first!', 'error'); return; }
  saveUndoState();
  state.widgets = state.widgets.filter(w => w.id !== state.selected);
  state.selected = null;
  renderWidgets();
  renderPropsPanel();
  toast('ðŸ—‘ï¸ Deleted!', 'success');
  saveUndoState();
}

function showCode() {
  if (state.widgets.length === 0) {
    toast('ðŸ‘† Add some widgets first!', 'error');
    return;
  }
  const cfg = { title: $('#titleInput').value || 'My Remote', widgets: state.widgets };
  $('#modalTitle').innerHTML = 'ðŸ“„ Your micro:bit Code <small style="display:block;font-size:0.7rem;font-weight:400;opacity:0.7;margin-top:4px;">Copy to MakeCode or click âš¡Flash to send directly to micro:bit via Bluetooth</small>';
  $('#modalCode').textContent = generateDemoCode(cfg);
  // Reset flash progress
  const progressEl = $('#flashProgress');
  if (progressEl) progressEl.style.display = 'none';
  $('#modalBg').classList.add('show');
}

function downloadCode() {
  const blob = new Blob([$('#modalCode').textContent], { type: 'text/plain' });
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = 'microbit-remote.ts'; a.click();
  toast('ðŸ’¾ Downloaded!', 'success');
}

function toast(msg, type = '') {
  const t = $('#toast'); t.textContent = msg;
  t.className = `toast ${type} show`;
  setTimeout(() => t.classList.remove('show'), 2500);
}



function showBuildOverlay(sub='âœ¨ Building...'){
  const ov = $('#loadingOverlay');
  if (!ov) return;
  ov.classList.add('show');
  ov.setAttribute('aria-hidden','false');
  const subEl = $('#loadingSub'); if (subEl) subEl.textContent = sub;
  const pctEl = $('#loadingPct'); if (pctEl) pctEl.textContent = '';
  const bar = $('#loadingBarFill'); if (bar) bar.style.width = '100%';
}

// Loading overlay helpers
let _loadingIndeterminate = null;
function showLoading(title = 'ðŸ§© Loading your remote...', sub = 'Getting layout from micro:bit'){
  if (!state._allowLoadingOverlay) return;
  const ov = $('#loadingOverlay');
  if (!ov) return;
  ov.classList.add('show');
  ov.setAttribute('aria-hidden','false');
  const subEl = $('#loadingSub'); if (subEl) subEl.textContent = sub;
  const pctEl = $('#loadingPct'); if (pctEl) pctEl.textContent = '0%';
  const bar = $('#loadingBarFill'); if (bar) bar.style.width = '8%';

  clearInterval(_loadingIndeterminate);
  // fun, kid-friendly "wiggle" while chunks arrive
  let p = 8; let dir = 1;
  _loadingIndeterminate = setInterval(() => {
    p += dir * 3;
    if (p > 22) { p = 22; dir = -1; }
    if (p < 8)  { p = 8;  dir = 1; }
    if (bar) bar.style.width = p + '%';
  }, 220);
}

function setLoadingProgress(pct, sub){
  const bar = $('#loadingBarFill');
  const pctEl = $('#loadingPct');
  const subEl = $('#loadingSub');
  if (subEl && sub) subEl.textContent = sub;
  const clamped = Math.max(0, Math.min(100, pct));
  if (bar) bar.style.width = clamped + '%';
  if (pctEl) pctEl.textContent = Math.round(clamped) + '%';
}

function hideLoading(){
  const ov = $('#loadingOverlay');
  if (!ov) return;
  clearInterval(_loadingIndeterminate);
  _loadingIndeterminate = null;
  ov.classList.remove('show');
  ov.setAttribute('aria-hidden','true');
}

// BLE Connection
async function connectBle() {
  console.log('[BLE] Starting connection...');
  state._allowLoadingOverlay = true;
  try {
    console.log('[BLE] Requesting device...');
    const device = await navigator.bluetooth.requestDevice({
      filters: [{ namePrefix: 'BBC micro:bit' }],
      optionalServices: [UART_SERVICE]
    });
    console.log('[BLE] Device selected:', device.name);
    
    device.addEventListener('gattserverdisconnected', () => {
      console.log('[BLE] GATT server disconnected event');
      onDisconnect();
    });
    
    console.log('[BLE] Connecting to GATT server...');
    const server = await device.gatt.connect();
    console.log('[BLE] GATT connected');
    
    console.log('[BLE] Getting UART service...');
    const service = await server.getPrimaryService(UART_SERVICE);
    console.log('[BLE] UART service found');
    
    console.log('[BLE] Getting TX characteristic...');
    const notifyChar = await service.getCharacteristic(UART_TX_CHAR);
    console.log('[BLE] TX characteristic found');
    
    console.log('[BLE] Getting RX characteristic...');
    const writeChar = await service.getCharacteristic(UART_RX_CHAR);
    console.log('[BLE] RX characteristic found');
    
    console.log('[BLE] Starting notifications...');
    await notifyChar.startNotifications();
    notifyChar.addEventListener('characteristicvaluechanged', onNotify);
    console.log('[BLE] Notifications started');
    
    state.ble = { device, server, service, notifyChar, writeChar, connected: true };
    state.rxBuffer = '';
    updateBleUI();
    toast('Connected!', 'success');
    
    console.log('[BLE] Waiting 500ms then sending GETCFG...');
    showLoading('ðŸ§© Loading your remote...', 'Requesting layout (GETCFG)â€¦');
    setTimeout(() => { 
      console.log('[BLE] Sending GETCFG now');
      state.rxBuffer = ''; 
      send('GETCFG'); 
    }, 500);
  } catch (err) {
    console.error('[BLE] Connection error:', err);
    toast('Connection failed', 'error');
  }
}

function onDisconnect() {
  console.log('[BLE] Disconnected!');
  state._allowLoadingOverlay = false;
  if (typeof hideLoading==='function') hideLoading();
  state.ble = { device:null, server:null, service:null, notifyChar:null, writeChar:null, connected:false };
  updateBleUI();
  hideLoading();
  beepDanger();
  toast('Disconnected', 'error');
}

function updateBleUI() {
  const btn = $('#bleBtn');
  const arrangeBtn = $('#arrangeModeBtn');
  const fullscreenBtn = $('#fullscreenBtn');
  if (state.ble.connected) {
    btn.classList.add('connected');
    btn.querySelector('span:last-child').textContent = (I18N[state.lang]||I18N.en).connected;
    $('#connectPrompt').style.display = 'none';
    $('#runtimeContent').style.display = 'flex';
    if (arrangeBtn) arrangeBtn.classList.add('visible');
    if (fullscreenBtn) fullscreenBtn.classList.add('visible');
    
    // Celebrate connection!
    if (!state._celebrated) {
      state._celebrated = true;
      celebrate('ðŸŽ‰ Connected!');
    }
  } else {
    btn.classList.remove('connected');
    btn.querySelector('span:last-child').textContent = (I18N[state.lang]||I18N.en).connect;
    $('#connectPrompt').style.display = 'block';
    $('#runtimeContent').style.display = 'none';
    state._celebrated = false;
    if (arrangeBtn) {
      arrangeBtn.classList.remove('visible');
      // Also exit arrange mode if disconnected
      if (state.arrangeMode) {
        state.arrangeMode = false;
        arrangeBtn.classList.remove('active');
        arrangeBtn.textContent = 'ðŸ“ Arrange';
        const grid = $('#runtimeGrid');
        if (grid) grid.classList.remove('arrange-mode');
        const hint = $('#arrangeHint');
        if (hint) hint.style.display = 'none';
      }
    }
    if (fullscreenBtn) fullscreenBtn.classList.remove('visible');
  }
}

let configBuffer = '';
    configChunks = 0;
    showLoading('ðŸ§© Loading your remote...', 'Receiving layoutâ€¦');
    setLoadingProgress(12, 'Receiving layoutâ€¦');
var configChunks = 0;
function onNotify(event) {
  const value = event.target.value;
  let str = '';
  for (let i = 0; i < value.byteLength; i++) {
    const byte = value.getUint8(i);
    if (byte !== 13) str += String.fromCharCode(byte);
  }
  console.log('[BLE RX] Received:', str.replace(/\n/g, '\\n'));
  state.rxBuffer += str;
  let nl;
  while ((nl = state.rxBuffer.indexOf('\n')) !== -1) {
    const line = state.rxBuffer.slice(0, nl).trim();
    state.rxBuffer = state.rxBuffer.slice(nl + 1);
    if (line) processLine(line);
  }
}

function processLine(line) {
  console.log('[BLE] Processing line:', line);
  if (line.startsWith('CFGBEGIN')) {
    console.log('[BLE] Config begin');
    configBuffer = '';
  }
  else if (line.startsWith('CFG ')) {
    configBuffer += line.substring(4);
    configChunks++;
    setLoadingProgress(Math.min(90, 12 + configChunks * 4), `Receiving layoutâ€¦ (${configChunks} chunks)`);
    console.log('[BLE] Config chunk, total length:', configBuffer.length);
  }
  else if (line === 'CFGEND') {
    console.log('[BLE] Config end, decoding...');
    setLoadingProgress(96, 'Decoding layoutâ€¦');
    try { 
      // Unicode-safe base64 decoding (handles emojis!)
      state.config = JSON.parse(decodeURIComponent(escape(atob(configBuffer))));
      if (state.config?.widgets) state.config.widgets.forEach(applyWidgetDefaults); 
      console.log('[BLE] Config decoded:', state.config);
      renderRuntime();
      setLoadingProgress(100, 'Ready!');
      setTimeout(hideLoading, 250);
      state._allowLoadingOverlay = false;
      hideLoading();
      toast('Remote loaded!', 'success'); 
    }
    catch(e) { console.error('[BLE] Config parse error:', e); hideLoading();
      toast('Config error', 'error'); }
  } else if (line.startsWith('UPD ')) {
    const parts = line.substring(4).split(' ');
    const id = parts[0];
    const val = parts.slice(1).join(' ');
    console.log('[BLE] Update widget:', id, '=', val);
    state.values[id] = val;
    updateRuntimeWidget(id, val);
  }
}

function renderRuntime() {
  if (!state.config) return;
  const cfg = state.config;
  $('#runtimeTitle').textContent = cfg.title || 'My Remote';
  const grid = $('#runtimeGrid');
  let maxX = 0, maxY = 0;
  cfg.widgets.forEach(w => { maxX = Math.max(maxX, w.x + w.w); maxY = Math.max(maxY, w.y + w.h); });
  
  // Use saved canvas size or calculate from widgets - with reasonable limits
  const canvasW = state.runtimeCanvasSize?.w || Math.max(350, maxX + 20);
  const canvasH = state.runtimeCanvasSize?.h || Math.max(300, maxY + 20);
  grid.style.width = `${canvasW}px`;
  grid.style.height = `${canvasH}px`;
  grid.innerHTML = '';
  
  // Add canvas resize handle and size badge
  const resizeHandle = document.createElement('div');
  resizeHandle.className = 'canvas-resize-handle';
  grid.appendChild(resizeHandle);
  
  const sizeBadge = document.createElement('div');
  sizeBadge.className = 'runtime-size-badge';
  sizeBadge.textContent = `${canvasW} Ã— ${canvasH}`;
  grid.appendChild(sizeBadge);
  
  cfg.widgets.forEach(w => {
    const el = document.createElement('div');
    el.className = 'rt-widget'; el.dataset.id = w.id;
    el.style.cssText = `left:${w.x}px;top:${w.y}px;width:${w.w}px;height:${w.h}px`;
    el.innerHTML = createRuntimeWidget(w) + '<div class="rt-resize-handle" style="display:none;"></div>';
    grid.appendChild(el);
    bindRuntimeWidget(el, w);
  });

  // Initial draw for graphs & gauges
  cfg.widgets.forEach(w => {
    applyWidgetDefaults(w);
    if (w.t === 'graph') drawGraphWidget(w);
    if (w.t === 'gauge') updateGaugeWidget(w, state.values[w.id] || '0');
  });
  
  // Re-apply arrange mode if it was active
  if (state.arrangeMode) {
    setupArrangeMode();
  }
}

// === RUNTIME ARRANGE MODE ===
function toggleArrangeMode() {
  state.arrangeMode = !state.arrangeMode;
  const btn = $('#arrangeModeBtn');
  const grid = $('#runtimeGrid');
  const hint = $('#arrangeHint');
  
  if (state.arrangeMode) {
    btn.classList.add('active');
    btn.textContent = 'âœ“ Done';
    grid.classList.add('arrange-mode');
    hint.style.display = 'block';
    
    // Show resize handles
    grid.querySelectorAll('.rt-resize-handle').forEach(h => h.style.display = 'block');
    
    setupArrangeMode();
    toast('ðŸ“ Arrange mode ON - drag widgets to move', 'success');
  } else {
    btn.classList.remove('active');
    btn.textContent = 'ðŸ“ Arrange';
    grid.classList.remove('arrange-mode');
    hint.style.display = 'none';
    
    // Hide resize handles
    grid.querySelectorAll('.rt-resize-handle').forEach(h => h.style.display = 'none');
    
    teardownArrangeMode();
    
    // Sync changes back to build mode widgets
    syncRuntimeToBuild();
    
    toast('âœ… Layout saved!', 'success');
  }
}

function setupArrangeMode() {
  const grid = $('#runtimeGrid');
  if (!grid) return;
  
  // Setup canvas resize
  const canvasHandle = grid.querySelector('.canvas-resize-handle');
  if (canvasHandle && !canvasHandle._resizeSetup) {
    canvasHandle._resizeSetup = true;
    let isResizingCanvas = false;
    let canvasStartX, canvasStartY, canvasStartW, canvasStartH;
    
    const onCanvasResizeStart = (e) => {
      if (!state.arrangeMode) return;
      e.preventDefault();
      e.stopPropagation();
      isResizingCanvas = true;
      
      const touch = e.touches ? e.touches[0] : e;
      canvasStartX = touch.clientX;
      canvasStartY = touch.clientY;
      canvasStartW = parseInt(grid.style.width) || 400;
      canvasStartH = parseInt(grid.style.height) || 320;
    };
    
    const onCanvasResizeMove = (e) => {
      if (!isResizingCanvas || !state.arrangeMode) return;
      e.preventDefault();
      
      const touch = e.touches ? e.touches[0] : e;
      const dx = touch.clientX - canvasStartX;
      const dy = touch.clientY - canvasStartY;
      
      const newW = Math.max(300, canvasStartW + dx);
      const newH = Math.max(200, canvasStartH + dy);
      
      grid.style.width = newW + 'px';
      grid.style.height = newH + 'px';
      
      // Update size badge
      const badge = grid.querySelector('.runtime-size-badge');
      if (badge) badge.textContent = `${newW} Ã— ${newH}`;
    };
    
    const onCanvasResizeEnd = () => {
      if (!isResizingCanvas) return;
      isResizingCanvas = false;
      
      // Save canvas size
      state.runtimeCanvasSize = {
        w: parseInt(grid.style.width) || 400,
        h: parseInt(grid.style.height) || 320
      };
    };
    
    canvasHandle.addEventListener('mousedown', onCanvasResizeStart);
    canvasHandle.addEventListener('touchstart', onCanvasResizeStart, { passive: false });
    document.addEventListener('mousemove', onCanvasResizeMove);
    document.addEventListener('touchmove', onCanvasResizeMove, { passive: false });
    document.addEventListener('mouseup', onCanvasResizeEnd);
    document.addEventListener('touchend', onCanvasResizeEnd);
    
    canvasHandle._cleanup = () => {
      canvasHandle.removeEventListener('mousedown', onCanvasResizeStart);
      canvasHandle.removeEventListener('touchstart', onCanvasResizeStart);
      document.removeEventListener('mousemove', onCanvasResizeMove);
      document.removeEventListener('touchmove', onCanvasResizeMove);
      document.removeEventListener('mouseup', onCanvasResizeEnd);
      document.removeEventListener('touchend', onCanvasResizeEnd);
    };
  }
  
  grid.querySelectorAll('.rt-widget').forEach(el => {
    // Skip if already set up
    if (el._arrangeSetup) return;
    el._arrangeSetup = true;
    
    const wid = el.dataset.id;
    let startX, startY, startLeft, startTop;
    let isDragging = false;
    
    // Touch/Mouse drag
    const onStart = (e) => {
      if (!state.arrangeMode) return;
      if (e.target.closest('.rt-resize-handle')) return;
      
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      el.classList.add('dragging');
      
      const touch = e.touches ? e.touches[0] : e;
      startX = touch.clientX;
      startY = touch.clientY;
      startLeft = parseInt(el.style.left) || 0;
      startTop = parseInt(el.style.top) || 0;
    };
    
    const onMove = (e) => {
      if (!isDragging || !state.arrangeMode) return;
      e.preventDefault();
      
      const touch = e.touches ? e.touches[0] : e;
      const dx = touch.clientX - startX;
      const dy = touch.clientY - startY;
      
      const newLeft = Math.max(0, startLeft + dx);
      const newTop = Math.max(0, startTop + dy);
      
      el.style.left = newLeft + 'px';
      el.style.top = newTop + 'px';
    };
    
    const onEnd = (e) => {
      if (!isDragging) return;
      isDragging = false;
      el.classList.remove('dragging');
      
      // Update config
      if (state.config) {
        const w = state.config.widgets.find(w => w.id === wid);
        if (w) {
          w.x = parseInt(el.style.left) || 0;
          w.y = parseInt(el.style.top) || 0;
        }
      }
      
      // Update grid size if widget moved outside
      updateRuntimeGridSize();
    };
    
    el.addEventListener('mousedown', onStart);
    el.addEventListener('touchstart', onStart, { passive: false });
    document.addEventListener('mousemove', onMove);
    document.addEventListener('touchmove', onMove, { passive: false });
    document.addEventListener('mouseup', onEnd);
    document.addEventListener('touchend', onEnd);
    
    // Store cleanup functions
    el._arrangeCleanup = () => {
      el.removeEventListener('mousedown', onStart);
      el.removeEventListener('touchstart', onStart);
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('touchmove', onMove);
      document.removeEventListener('mouseup', onEnd);
      document.removeEventListener('touchend', onEnd);
    };
    
    // Resize handle
    const handle = el.querySelector('.rt-resize-handle');
    if (handle) {
      let isResizing = false;
      let resizeStartX, resizeStartY, resizeStartW, resizeStartH;
      
      const onResizeStart = (e) => {
        if (!state.arrangeMode) return;
        e.preventDefault();
        e.stopPropagation();
        isResizing = true;
        
        const touch = e.touches ? e.touches[0] : e;
        resizeStartX = touch.clientX;
        resizeStartY = touch.clientY;
        resizeStartW = parseInt(el.style.width) || 100;
        resizeStartH = parseInt(el.style.height) || 100;
      };
      
      const onResizeMove = (e) => {
        if (!isResizing || !state.arrangeMode) return;
        e.preventDefault();
        
        const touch = e.touches ? e.touches[0] : e;
        const dx = touch.clientX - resizeStartX;
        const dy = touch.clientY - resizeStartY;
        
        const newW = Math.max(50, resizeStartW + dx);
        const newH = Math.max(50, resizeStartH + dy);
        
        el.style.width = newW + 'px';
        el.style.height = newH + 'px';
      };
      
      const onResizeEnd = () => {
        if (!isResizing) return;
        isResizing = false;
        
        // Update config
        if (state.config) {
          const w = state.config.widgets.find(w => w.id === wid);
          if (w) {
            w.w = parseInt(el.style.width) || 100;
            w.h = parseInt(el.style.height) || 100;
          }
        }
        
        updateRuntimeGridSize();
      };
      
      handle.addEventListener('mousedown', onResizeStart);
      handle.addEventListener('touchstart', onResizeStart, { passive: false });
      document.addEventListener('mousemove', onResizeMove);
      document.addEventListener('touchmove', onResizeMove, { passive: false });
      document.addEventListener('mouseup', onResizeEnd);
      document.addEventListener('touchend', onResizeEnd);
      
      handle._resizeCleanup = () => {
        handle.removeEventListener('mousedown', onResizeStart);
        handle.removeEventListener('touchstart', onResizeStart);
        document.removeEventListener('mousemove', onResizeMove);
        document.removeEventListener('touchmove', onResizeMove);
        document.removeEventListener('mouseup', onResizeEnd);
        document.removeEventListener('touchend', onResizeEnd);
      };
    }
  });
}

function teardownArrangeMode() {
  const grid = $('#runtimeGrid');
  if (!grid) return;
  
  // Cleanup canvas resize
  const canvasHandle = grid.querySelector('.canvas-resize-handle');
  if (canvasHandle && canvasHandle._cleanup) {
    canvasHandle._cleanup();
    canvasHandle._cleanup = null;
    canvasHandle._resizeSetup = false;
  }
  
  grid.querySelectorAll('.rt-widget').forEach(el => {
    if (el._arrangeCleanup) {
      el._arrangeCleanup();
      el._arrangeCleanup = null;
    }
    el._arrangeSetup = false;
    
    const handle = el.querySelector('.rt-resize-handle');
    if (handle && handle._resizeCleanup) {
      handle._resizeCleanup();
      handle._resizeCleanup = null;
    }
  });
}

function updateRuntimeGridSize() {
  const grid = $('#runtimeGrid');
  if (!grid || !state.config) return;
  
  let maxX = 0, maxY = 0;
  state.config.widgets.forEach(w => {
    maxX = Math.max(maxX, w.x + w.w);
    maxY = Math.max(maxY, w.y + w.h);
  });
  
  grid.style.width = `${Math.max(400, maxX + 20)}px`;
  grid.style.height = `${Math.max(320, maxY + 20)}px`;
}

function syncRuntimeToBuild() {
  if (!state.config || !state.config.widgets) return;
  
  // Update state.widgets with new positions from runtime config
  state.config.widgets.forEach(rtW => {
    const buildW = state.widgets.find(w => w.id === rtW.id);
    if (buildW) {
      buildW.x = rtW.x;
      buildW.y = rtW.y;
      buildW.w = rtW.w;
      buildW.h = rtW.h;
    }
  });
  
  // Re-render build view with updated positions
  renderWidgets();
  
  // Auto-save
  scheduleAutoSave();
}


function createRuntimeWidget(w) {
  const val = esc(state.values[w.id] || '0');
  const label = esc(w.label || w.t);
  const rawVal = state.values[w.id] || '0';
  const model = (w.model || '').trim();

  switch (w.t) {
    case 'button': {
      const m = model || 'neo';
      const icons = ['ðŸŽ¯', 'âš¡', 'ðŸš€', 'ðŸ’¥', 'âœ¨', 'ðŸŽ®', 'ðŸ”¥', 'ðŸ’«'];
      const icon = icons[Math.abs(w.id.charCodeAt(w.id.length-1) || 0) % icons.length];
      return `<button class="rt-button model-${m}"><span class="icon">${icon}</span><span>${label}</span></button>`;
    }

    case 'slider': {
      const m = model || 'track';
      const min = (w.min ?? 0);
      const max = (w.max ?? 100);
      const step = (w.step ?? 1);
      const clamped = Math.max(min, Math.min(max, parseFloat(rawVal) || min));
      const isVertical = (w.h || 100) > (w.w || 100);
      const orientClass = isVertical ? ' vertical' : '';
      return `<div class="rt-slider-wrap${orientClass}">
        <div class="rt-slider-label">${label}</div>
        <input type="range" class="rt-slider model-${m}" min="${min}" max="${max}" step="${step}" value="${clamped}"${isVertical ? ' orient="vertical"' : ''}>
        <div class="rt-slider-val">${esc(String(clamped))}</div>
      </div>`;
    }

    case 'toggle': {
      const m = model || 'square';
      const on = rawVal === '1';
      const glyph = m === 'icon' ? (on ? 'â»' : 'â­˜') : (on ? 'ðŸ˜ƒ' : 'ðŸ˜´');
      return `<div class="rt-toggle-wrap">
        <button class="rt-toggle model-${m}${on ? ' on' : ''}">${glyph}</button>
        <span>${label}</span>
      </div>`;
    }

    case 'led': {
      const m = model || 'dot';
      const on = rawVal === '1';
      const onColor = w.colorOn || '#ff5252';
      const offColor = w.colorOff || '#333';
      // Create dynamic styles for the bulb effect
      const offStyle = `background: radial-gradient(circle at 30% 30%, #666, #333 40%, #222 70%, #111);`;
      const onStyle = `background: radial-gradient(circle at 30% 30%, ${onColor}99, ${onColor} 30%, ${onColor}cc 60%, ${onColor}88); border-color: ${onColor}88;`;
      const style = on ? onStyle : offStyle;
      const shadow = on 
        ? `box-shadow: inset 0 -8px 15px rgba(0,0,0,0.3), inset 0 8px 15px rgba(255,255,255,0.3), 0 0 30px ${onColor}, 0 0 60px ${onColor}88, 0 0 90px ${onColor}44;`
        : `box-shadow: inset 0 -8px 15px rgba(0,0,0,0.6), inset 0 8px 15px rgba(255,255,255,0.1), 0 4px 10px rgba(0,0,0,0.5);`;

      return `<div class="rt-led-wrap">
        <div class="rt-led model-${m}${on ? ' on' : ''}" style="${style}${shadow}" data-color="${onColor}"></div>
        <span>${label}</span>
      </div>`;
    }

    case 'joystick': {
      const m = model || 'classic';
      const stickM = m === 'min' ? 'min' : 'classic';
      return `<div class="rt-joystick-wrap">
        <div class="rt-joystick-base model-${m}"><div class="rt-joystick-stick model-${stickM}"></div></div>
        <span>${label}</span>
      </div>`;
    }

    case 'label': {
      const m = model || 'plain';
      return `<div class="rt-label-text model-${m}">${val || label}</div>`;
    }

    case 'gauge': {
      const m = model || 'classic';
      const units = esc(w.units || '');
      const decimals = (w.decimals ?? 0);
      // 11 tick marks across the arc
      const ticks = Array.from({length: 11}, (_, i) => {
        const a = (-180 + (180 * (i/10))) * Math.PI/180; // -180..0
        const cx = 60, cy = 70;
        const r1 = 42, r2 = 50;
        const x1 = cx + Math.cos(a) * r1;
        const y1 = cy + Math.sin(a) * r1;
        const x2 = cx + Math.cos(a) * r2;
        const y2 = cy + Math.sin(a) * r2;
        return `<line x1="${x1.toFixed(1)}" y1="${y1.toFixed(1)}" x2="${x2.toFixed(1)}" y2="${y2.toFixed(1)}" />`;
      }).join('');
      return `<div class="rt-gauge-wrap model-${m}">
        <div class="rt-gauge-svg">
          <svg viewBox="0 0 120 80" width="100%" height="100%">
            <g class="rt-gauge-ticks">${ticks}</g>
            <path class="rt-gauge-bg" d="M10,70 A50,50 0 0 1 110,70" />
            <path class="rt-gauge-fg" data-role="gaugeArc" d="M10,70 A50,50 0 0 1 110,70" />
          </svg>
        </div>
        <div class="rt-gauge-center">
          <div class="rt-gauge-emoji" data-role="gaugeEmoji">ðŸ˜ƒ</div>
          <div class="rt-gauge-value" data-role="gaugeValue">${esc((parseFloat(rawVal)||0).toFixed(decimals))}</div>
          <div class="rt-gauge-label">${label}${units ? ' ' + units : ''}</div>
        </div>
      </div>`;
    }
    
    case 'graph': {
      const m = model || 'grid';
      const win = parseInt(w.windowSec ?? 30, 10) || 30;
      const auto = (w.autoScale !== false);
      const series = Math.max(1, Math.min(10, parseInt(w.series ?? 1, 10) || 1));
      return `<div class="rt-graph-wrap model-${m}">
        <div class="rt-graph-head">
          <span>${label}</span>
          <span data-role="graphLast"></span>
        </div>
        <div class="rt-graph-sub" data-role="graphLegend"></div>
        <canvas class="rt-graph-canvas" data-role="graphCanvas"></canvas>
        <div class="rt-graph-sub">Win:${win}s&nbsp;&nbsp;${auto ? 'Auto' : 'Fixed'}&nbsp;&nbsp;Series:${series}</div>
      </div>`;
    }

    case 'dpad': {
      return `<div class="rt-dpad">
        <div></div>
        <button class="dpad-btn" data-dir="up">â–²</button>
        <div></div>
        <button class="dpad-btn" data-dir="left">â—€</button>
        <div class="dpad-btn dpad-center"></div>
        <button class="dpad-btn" data-dir="right">â–¶</button>
        <div></div>
        <button class="dpad-btn" data-dir="down">â–¼</button>
        <div></div>
      </div>`;
    }

    case 'xypad': {
      return `<div class="rt-xypad">
        <div class="xypad-crosshair"></div>
        <div class="xypad-dot" style="left:50%;top:50%"></div>
        <div class="xypad-label">${label}</div>
      </div>`;
    }

    case 'battery': {
      const level = parseInt(rawVal) || 100;
      const levelClass = level < 20 ? 'critical' : level < 40 ? 'low' : '';
      const emoji = level < 20 ? 'ðŸ˜±' : level < 40 ? 'ðŸ˜°' : level < 60 ? 'ðŸ˜Š' : level < 80 ? 'ðŸ˜„' : 'ðŸ¤©';
      return `<div class="rt-battery">
        <div class="battery-tip"></div>
        <div class="battery-body">
          <div class="battery-level ${levelClass}" style="height:${level}%"></div>
        </div>
        <div class="battery-text">${level}%</div>
        <div class="battery-emoji">${emoji}</div>
      </div>`;
    }

    case 'timer': {
      return `<div class="rt-timer">
        <div class="timer-label">â±ï¸ ${label || 'Timer'}</div>
        <div class="timer-display" data-role="timerDisplay">00:00</div>
        <div class="timer-controls">
          <button class="timer-btn" data-action="start">â–¶ï¸ Go!</button>
          <button class="timer-btn" data-action="pause">â¸ï¸</button>
          <button class="timer-btn" data-action="reset">ðŸ”„</button>
        </div>
      </div>`;
    }

    case 'image': {
      const src = w.imageSrc || '';
      return `<div class="rt-image" style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;overflow:hidden;border-radius:8px;">
        ${src ? `<img src="${esc(src)}" style="max-width:100%;max-height:100%;object-fit:contain;">` : `<span style="opacity:0.5">${label || 'ðŸ–¼ï¸'}</span>`}
      </div>`;
    }

    default:
      return `<div>${w.t}</div>`;
  }
}


function bindRuntimeWidget(el, w) {
  switch (w.t) {
    case 'button':
      const btn = el.querySelector('.rt-button');
      let btnPressed = false;
      const press = e => { 
        e.preventDefault();
        if (btnPressed) return;
        btnPressed = true;
        beepClick();
        send(`SET ${w.id} 1`); 
        btn.style.transform = 'scale(0.9)'; 
      };
      const release = () => {
        if (!btnPressed) return;
        btn.style.transform = '';
        // Delay release message slightly
        setTimeout(() => {
          btnPressed = false;
          send(`SET ${w.id} 0`);
        }, 100);
      };
      btn.onmousedown = btn.ontouchstart = press;
      btn.onmouseup = btn.onmouseleave = btn.ontouchend = release;
      break;
    case 'slider':
      let sliderEl = el.querySelector('.rt-slider');
      // Update display during drag (no BLE send)
      sliderEl.oninput = e => {
        el.querySelector('.rt-slider-val').textContent = Math.round(e.target.value);
      };
      // Only send on release (onChange fires when user stops dragging)
      sliderEl.onchange = e => {
        const val = Math.round(parseFloat(e.target.value) || 0);
        console.log('[SLIDER] Sending final value:', val);
        send(`SET ${w.id} ${val}`);
      };
      break;
    case 'toggle':
      el.querySelector('.rt-toggle').onclick = function() {
        const on = this.classList.toggle('on');
        this.textContent = on ? 'ðŸ˜ƒ' : 'ðŸ˜´';
        beepToggle(on);
        send(`SET ${w.id} ${on ? '1' : '0'}`);
      };
      break;
    case 'joystick':
      const stick = el.querySelector('.rt-joystick-stick');
      const base = el.querySelector('.rt-joystick-base');
      let isDown = false;
      let currentAngle = 0;
      let currentDist = 0;
      let resetTimer = null; // Debounce timer for reset
      const handleMove = e => {
        if (!isDown) return;
        const rect = base.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const dx = clientX - centerX;
        const dy = -(clientY - centerY); // Invert Y so up is positive
        const maxDist = Math.min(rect.width, rect.height) / 2 - 10;
        const rawAngle = Math.atan2(dy, dx) * 180 / Math.PI;
        const distance = Math.min(maxDist, Math.hypot(dx, dy));
        currentDist = Math.round((distance / maxDist) * 100);
        // Normalize angle: 0=right, 90=up, 180=left, 270=down
        currentAngle = Math.round(((rawAngle + 360) % 360));
        // Visual position uses screen coordinates (Y not inverted)
        const visualDy = clientY - centerY;
        stick.style.transform = `translate(${(dx / Math.hypot(dx, visualDy || 1)) * distance}px, ${(visualDy / Math.hypot(dx, visualDy || 1)) * distance}px)`;
        // Don't send during drag - only on release
      };
      const resetJoystick = () => {
        if (!isDown) return;
        isDown = false;
        // Clear any pending reset timer
        if (resetTimer) { clearTimeout(resetTimer); resetTimer = null; }
        // Send final position before reset (only if moved significantly)
        const finalAngle = currentAngle;
        const finalDist = currentDist;
        stick.style.transform = '';
        currentAngle = 0;
        currentDist = 0;
        // Single combined send: final position then center, with proper delay
        if (finalDist > 5) {
          send(`SET ${w.id} ${finalAngle} ${finalDist}`);
          // Wait longer than BLE minInterval before sending center
          resetTimer = setTimeout(() => {
            resetTimer = null;
            send(`SET ${w.id} 0 0`);
          }, 200);
        } else {
          // Just send center if no significant movement
          send(`SET ${w.id} 0 0`);
        }
      };
      const startJoystick = (e) => {
        if (e.type === 'touchstart') e.preventDefault();
        if (isDown) return; // Prevent multiple starts
        isDown = true;
        if (resetTimer) { clearTimeout(resetTimer); resetTimer = null; }
      };
      base.onmousedown = startJoystick;
      base.ontouchstart = startJoystick;
      document.addEventListener('mousemove', handleMove);
      document.addEventListener('touchmove', handleMove, { passive: false });
      document.addEventListener('mouseup', resetJoystick);
      document.addEventListener('touchend', resetJoystick);
      break;
    
    case 'dpad':
      el.querySelectorAll('.dpad-btn[data-dir]').forEach(btn => {
        const dir = btn.dataset.dir;
        let dpadPressed = false;
        let releaseTimer = null;
        const press = e => { 
          e.preventDefault();
          if (dpadPressed) return;
          dpadPressed = true;
          clearTimeout(releaseTimer);
          btn.classList.add('active');
          beepClick();
          send(`SET ${w.id} ${dir} 1`); 
        };
        const release = () => {
          if (!dpadPressed) return;
          btn.classList.remove('active');
          // Debounce release to avoid rapid press/release
          clearTimeout(releaseTimer);
          releaseTimer = setTimeout(() => {
            dpadPressed = false;
            send(`SET ${w.id} ${dir} 0`);
          }, 100);
        };
        btn.onmousedown = btn.ontouchstart = press;
        btn.onmouseup = btn.onmouseleave = btn.ontouchend = release;
      });
      break;
    
    case 'xypad':
      const xypad = el.querySelector('.rt-xypad');
      const xydot = el.querySelector('.xypad-dot');
      let xyDown = false;
      let lastX = 50, lastY = 50;
      const handleXY = e => {
        if (!xyDown) return;
        e.preventDefault();
        const rect = xypad.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const x = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        const y = Math.max(0, Math.min(1, (clientY - rect.top) / rect.height));
        lastX = Math.round(x * 100);
        lastY = Math.round(y * 100);
        xydot.style.left = (x * 100) + '%';
        xydot.style.top = (y * 100) + '%';
        // Don't send during drag - only on release
      };
      const releaseXY = () => {
        if (!xyDown) return;
        xyDown = false;
        // Send final position on release
        console.log('[XYPAD] Sending final:', lastX, lastY);
        send(`SET ${w.id} ${lastX} ${lastY}`);
      };
      xypad.onmousedown = xypad.ontouchstart = e => { 
        xyDown = true; 
        handleXY(e); 
      };
      document.addEventListener('mousemove', handleXY);
      document.addEventListener('touchmove', handleXY, { passive: false });
      document.addEventListener('mouseup', releaseXY);
      document.addEventListener('touchend', releaseXY);
      break;
    
    case 'timer':
      let timerVal = 0;
      let timerInterval = null;
      let lastTimerSend = 0;
      const display = el.querySelector('[data-role="timerDisplay"]');
      const formatTime = s => {
        const m = Math.floor(s / 60);
        const sec = s % 60;
        return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
      };
      el.querySelector('[data-action="start"]').onclick = () => {
        if (timerInterval) return;
        timerInterval = setInterval(() => {
          timerVal++;
          display.textContent = formatTime(timerVal);
          // Only send every 5 seconds to avoid BLE spam
          if (timerVal - lastTimerSend >= 5) {
            lastTimerSend = timerVal;
            send(`SET ${w.id} ${timerVal}`);
          }
        }, 1000);
        beepClick();
      };
      el.querySelector('[data-action="pause"]').onclick = () => {
        clearInterval(timerInterval);
        timerInterval = null;
        // Send current value on pause
        send(`SET ${w.id} ${timerVal}`);
        beepClick();
      };
      el.querySelector('[data-action="reset"]').onclick = () => {
        clearInterval(timerInterval);
        timerInterval = null;
        timerVal = 0;
        lastTimerSend = 0;
        display.textContent = '00:00';
        send(`SET ${w.id} 0`);
        beepClick();
      };
      break;
  }
}


// --- Graph & Gauge helpers ---
state.history = state.history || {}; // { [id]: { points: Array<{t:number, v:number[]}>, colors:string[] } }

function parseCsvNumbers(s){
  return String(s ?? '').split(',').map(x => parseFloat(x.trim())).filter(x => isFinite(x));
}

function ensureGraphState(id, series){
  if (!state.history[id]) state.history[id] = { points: [], colors: [] };
  const hs = state.history[id];
  if (!hs.colors || hs.colors.length !== series){
    // generate distinct-ish hues using HSL (no hard-coded palette)
    hs.colors = Array.from({length: series}).map((_,i)=>`hsl(${(i*360/series)|0} 85% 60%)`);
  }
  return hs;
}

function pushGraphPoint(w, csvVal){
  const nums = parseCsvNumbers(csvVal);
  const series = Math.max(1, Math.min(10, parseInt(w.series ?? 1, 10)));
  const hs = ensureGraphState(w.id, series);
  const now = performance.now();
  const arr = Array.from({length: series}).map((_,i)=> (nums[i] != null ? nums[i] : NaN));
  hs.points.push({ t: now, v: arr });

  // trim window
  const winMs = Math.max(5, Math.min(300, parseFloat(w.windowSec ?? 30))) * 1000;
  const cutoff = now - winMs;
  while (hs.points.length && hs.points[0].t < cutoff) hs.points.shift();
  
  // Also limit max points for smoother rendering
  const maxPoints = 150;
  while (hs.points.length > maxPoints) hs.points.shift();
}

function resizeCanvasToDisplaySize(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(10, Math.floor(rect.width * dpr));
  const h = Math.max(10, Math.floor(rect.height * dpr));
  if (canvas.width !== w || canvas.height !== h){
    canvas.width = w; canvas.height = h;
    return true;
  }
  return false;
}

function drawGraphWidget(w){
  const root = document.querySelector(`.rt-widget[data-id="${w.id}"]`);
  if (!root) return;
  const canvas = root.querySelector('[data-role="graphCanvas"]');
  if (!canvas) return;

  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const cssW = Math.max(50, rect.width);
  const cssH = Math.max(40, rect.height);
  const W = Math.floor(cssW * dpr);
  const H = Math.floor(cssH * dpr);
  if (canvas.width !== W || canvas.height !== H){
    canvas.width = W; canvas.height = H;
  }

  const ctx = canvas.getContext('2d');
  // draw in CSS pixels for predictable fonts/line widths
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,cssW,cssH);

  const seriesCount = Math.max(1, Math.min(10, parseInt(w.series ?? 1, 10)));
  const hs = ensureGraphState(w.id, seriesCount);
  const pts = hs.points || [];


  // legend (kid-friendly)
  const legend = root.querySelector('[data-role="graphLegend"]');
  if (legend){
    const names = (w.seriesNames || '').split(',').map(s => s.trim()).filter(Boolean);
    legend.innerHTML = Array.from({length: seriesCount}).map((_,i) => {
      const nm = esc(names[i] || `S${i+1}`);
      return `<span class="legend-item"><span class="rt-graph-dot" data-s="${i}"></span>${nm}</span>`;
    }).join('');
  }

  // layout
  const mL = 36, mR = 10, mT = 10, mB = 22;
  const plotX = mL, plotY = mT;
  const plotW = Math.max(10, cssW - mL - mR);
  const plotH = Math.max(10, cssH - mT - mB);

  // background
  ctx.globalAlpha = 1;
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0,0,cssW,cssH);

  // axes + grid
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;

  // y grid + labels
  ctx.font = '10px system-ui, Segoe UI, sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.7)';

  // if no data, draw frame + hint
  ctx.strokeRect(plotX, plotY, plotW, plotH);
  if (pts.length < 2){
    ctx.fillStyle = 'rgba(255,255,255,0.55)';
    ctx.fillText('waiting for UPD...', plotX + 8, plotY + 16);
    // legend colors
    const legend2 = root.querySelector('[data-role="graphLegend"]');
    if (legend2){
      legend2.querySelectorAll('.rt-graph-dot').forEach(dot => {
        const i = parseInt(dot.getAttribute('data-s') || '0', 10);
        dot.style.background = hs.colors[i] || 'var(--accent)';
      });
    }
    return;
  }

  const t0 = pts[0].t;
  const t1 = pts[pts.length-1].t;
  const span = Math.max(0.001, t1 - t0);

  // y scale
  let yMin = Infinity, yMax = -Infinity;
  if (w.autoScale ?? true){
    pts.forEach(p => p.v.forEach(v => { if (isFinite(v)) { yMin = Math.min(yMin, v); yMax = Math.max(yMax, v); } }));
    if (!isFinite(yMin) || !isFinite(yMax)){ yMin = 0; yMax = 1; }
  } else {
    yMin = parseFloat(w.yMin ?? 0);
    yMax = parseFloat(w.yMax ?? 100);
    if (!isFinite(yMin) || !isFinite(yMax)){ yMin = 0; yMax = 1; }
  }
  if (yMin === yMax){ yMin -= 1; yMax += 1; }
  const pad = (yMax - yMin) * 0.08;
  yMin -= pad; yMax += pad;

  const xForT = t => plotX + ((t - t0) / span) * plotW;
  const yForV = v => plotY + plotH - ((v - yMin) / (yMax - yMin)) * plotH;

  // Y ticks
  const yTicks = 4;
  for (let i=0;i<=yTicks;i++){
    const p = i / yTicks;
    const y = plotY + p * plotH;
    ctx.beginPath(); ctx.moveTo(plotX, y); ctx.lineTo(plotX+plotW, y); ctx.stroke();
    const v = (yMax - (yMax - yMin) * p);
    ctx.fillText(v.toFixed(1), 4, y + 3);
  }

  
  // Y axis label
  if ((w.yLabel || '').trim()){
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    ctx.font = '11px system-ui, Segoe UI, sans-serif';
    ctx.translate(12, plotY + plotH/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(w.yLabel, 0, 0);
    ctx.restore();
  }

  // X ticks (seconds)
  const xTicks = 4;
  for (let i=0;i<=xTicks;i++){
    const p = i / xTicks;
    const x = plotX + p * plotW;
    ctx.beginPath(); ctx.moveTo(x, plotY); ctx.lineTo(x, plotY+plotH); ctx.stroke();
    const sec = ((t0 + span * p) - t1) / 1000; // negative to 0
    ctx.fillText(sec.toFixed(0) + 's', x - 10, plotY + plotH + 16);
  }

  // draw each series with smooth lines
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  
  hs.colors.forEach((c, si) => {
    // Draw glow effect first
    ctx.strokeStyle = c;
    ctx.lineWidth = 6;
    ctx.globalAlpha = 0.3;
    ctx.beginPath();
    let started = false;
    for (let i=0;i<pts.length;i++){
      const v = pts[i].v[si];
      if (!isFinite(v)) continue;
      const x = xForT(pts[i].t);
      const y = yForV(v);
      if (!started){ ctx.moveTo(x,y); started = true; }
      else { ctx.lineTo(x,y); }
    }
    if (started) ctx.stroke();
    
    // Draw main line
    ctx.globalAlpha = 1;
    ctx.lineWidth = 3;
    ctx.beginPath();
    started = false;
    for (let i=0;i<pts.length;i++){
      const v = pts[i].v[si];
      if (!isFinite(v)) continue;
      const x = xForT(pts[i].t);
      const y = yForV(v);
      if (!started){ ctx.moveTo(x,y); started = true; }
      else { ctx.lineTo(x,y); }
    }
    if (started) ctx.stroke();
  });

  // update legend dots colors
  const legend2 = root.querySelector('[data-role="graphLegend"]');
  if (legend2){
    legend2.querySelectorAll('.rt-graph-dot').forEach(dot => {
      const i = parseInt(dot.getAttribute('data-s') || '0', 10);
      dot.style.background = hs.colors[i] || 'var(--accent)';
    });
  }
}

function stopDemoSim(){
  if (state._demoTimer){
    clearInterval(state._demoTimer);
    state._demoTimer = null;
  }
}

function startDemoSim(){
  stopDemoSim();
  const hasGraph = !!document.querySelector('.rt-widget[data-id="graph_env"] [data-role="graphCanvas"]');
  const hasGauge = !!document.querySelector('.rt-widget[data-id="gauge_temp"] .rt-gauge-wrap');
  if (!hasGraph && !hasGauge) return;

  let t0 = Date.now();
  state._demoTimer = setInterval(() => {
    const t = (Date.now() - t0) / 1000;

    // Smooth sine waves for gauges
    const temp = 25 + 8 * Math.sin(t / 4);
    const level = 50 + 35 * Math.sin(t / 5);

    state.values['gauge_temp'] = temp.toFixed(1);
    state.values['gauge_level'] = level.toFixed(0);

    updateRuntimeWidget('gauge_temp', state.values['gauge_temp']);
    updateRuntimeWidget('gauge_level', state.values['gauge_level']);

    // Smooth waves for graph - slower, more gradual changes
    const s1 = 50 + 30 * Math.sin(t / 2);
    const s2 = 40 + 25 * Math.cos(t / 2.5);
    const csv = `${s1.toFixed(1)},${s2.toFixed(1)}`;
    state.values['graph_env'] = csv;
    updateRuntimeWidget('graph_env', csv);

    const scoreEl = state.config?.widgets?.find(x => x.id === 'label_score');
    if (scoreEl){
      const sc = Math.floor((t * 3) % 999);
      const txt = `Score: ${sc}`;
      state.values['label_score'] = txt;
      updateRuntimeWidget('label_score', txt);
    }
  }, 400); // Slower updates for smoother appearance
}


function updateGaugeWidget(w, valStr){
  const root = document.querySelector(`.rt-widget[data-id="${w.id}"]`);
  if (!root) return;
  const wrap = root.querySelector('.rt-gauge-wrap');
  if (!wrap) return;

  const arc = wrap.querySelector('[data-role="gaugeArc"]') || wrap.querySelector('.rt-gauge-fg');
  const txt = wrap.querySelector('[data-role="gaugeValue"]');
  const emo = wrap.querySelector('[data-role="gaugeEmoji"]');

  const min = parseFloat(w.min ?? 0);
  const max = parseFloat(w.max ?? 100);
  const dec = parseInt(w.decimals ?? 0, 10);

  let v = parseFloat(valStr);
  if (!isFinite(v)) v = min;

  const denom = (max - min) || 1;
  const t = Math.max(0, Math.min(1, (v - min) / denom));

  // Match CSS dasharray (half-ish arc). If changed in CSS, keep in sync.
  const L = 157.1;

  // Color zones (kid-friendly)
  const warn = (w.warn != null) ? parseFloat(w.warn) : null;
  const danger = (w.danger != null) ? parseFloat(w.danger) : null;

  let color = 'var(--green)';
  if (danger != null && isFinite(danger) && v >= danger) color = 'var(--red)';
  else if (warn != null && isFinite(warn) && v >= warn) color = 'var(--orange)';
  else color = 'var(--green)';

  if (arc){
    arc.style.strokeDasharray = String(L);
    arc.style.strokeDashoffset = String(L * (1 - t));
    arc.style.stroke = color;
  }

  if (txt){
    const d = isFinite(dec) ? dec : 0;
    txt.textContent = v.toFixed(d);
  }

  if (emo){
    // Cute emoji based on percent
    const pct = Math.round(t * 100);
    emo.textContent = pct < 20 ? 'ðŸ˜´' : pct < 40 ? 'ðŸ™‚' : pct < 60 ? 'ðŸ˜ƒ' : pct < 80 ? 'ðŸ¤©' : 'ðŸš€';
  }
}



function updateRuntimeWidget(id, val) {
  console.log('[UI] Updating widget:', id, 'to', val);
  const el = $(`.rt-widget[data-id="${id}"]`);
  if (!el || !state.config) {
    console.log('[UI] Widget not found or no config');
    return;
  }
  const w = state.config.widgets.find(x => x.id === id);
  if (!w) {
    console.log('[UI] Widget definition not found');
    return;
  }
  console.log('[UI] Widget type:', w.t);
  switch (w.t) {
    case 'slider': el.querySelector('.rt-slider').value = val; el.querySelector('.rt-slider-val').textContent = val; break;
    case 'toggle': el.querySelector('.rt-toggle').classList.toggle('on', val === '1'); el.querySelector('.rt-toggle').textContent = val === '1' ? 'ðŸ˜ƒ' : 'ðŸ˜´'; break;
    case 'led': {
      const ledEl = el.querySelector('.rt-led');
      const wdef = state.config.widgets.find(x => x.id === id);
      const onColor = wdef?.colorOn || '#ff5252';
      const offColor = wdef?.colorOff || '#2a2a3a';
      const model = (wdef?.model || 'dot');
      const on = val === '1';

      // Ensure model class is present (in case config changed live)
      ledEl.className = `rt-led model-${model}${on ? ' on' : ''}`;

      if (model === 'ring'){
        ledEl.style.background = 'transparent';
        ledEl.style.borderColor = on ? onColor : 'rgba(255,255,255,0.18)';
        ledEl.style.boxShadow = on ? `0 0 40px ${onColor}` : 'none';
      } else {
        ledEl.style.borderColor = '';
        ledEl.style.background = on ? onColor : offColor;
        ledEl.style.boxShadow = on ? `0 0 40px ${onColor}` : 'none';
      }

      console.log('[UI] LED', id, 'is now', on ? 'ON' : 'OFF');
      break;
    }
    case 'label': el.querySelector('.rt-label-text').textContent = val; break;
    case 'gauge': updateGaugeWidget(w, val); break;
    case 'graph': {
      // val is comma-separated numbers: "23.4,2.1"
      pushGraphPoint(w, val);
      const last = el.querySelector('[data-role="graphLast"]');
      if (last) last.textContent = val;
      drawGraphWidget(w);
      break;
    }
  }
}


// --- Move Build/Play tabs + Name input to top-right (no redesign) ---
function moveBuildPlayNameTopRight(){
  const host = document.getElementById('topRightControls');
  if (!host) return;

  const tabs = document.querySelector('.tabs');
  const title = document.getElementById('titleInput');

  // Only move if elements exist and not already inside host
  if (tabs && !host.contains(tabs)) host.appendChild(tabs);
  if (title && !host.contains(title)) host.appendChild(title);
}



// --- Place Build/Play + Name centered above the canvas (no overlap) ---

// --- Play mode UI: hide Build + Name, show a tiny Back control ---
function updateToolbarForMode(activeTab){
  const inner = document.getElementById('canvasToolbarInner') || document.querySelector('.canvas-toolbar-inner');
  if (!inner) return;

  const tabs = inner.querySelector('.tabs');
  const buildBtn = tabs ? tabs.querySelector('[data-tab="builder"]') : null;
  const playBtn  = tabs ? tabs.querySelector('[data-tab="runtime"]') : null;
  const nameInput = inner.querySelector('#titleInput');

  // Create back button once
  let back = inner.querySelector('#playBackBtn');
  if (!back){
    back = document.createElement('button');
    back.id = 'playBackBtn';
    back.className = 'tab';
    back.title = 'Back to edit';
    back.textContent = 'â¬…';
    back.style.display = 'none';
    back.addEventListener('click', () => {
      // switch to builder without using the Build label/button
      if (tabs){
        const b = tabs.querySelector('[data-tab="builder"]');
        if (b) b.click();
      }
    });
    // put it at the start
    if (tabs) tabs.insertBefore(back, tabs.firstChild);
    else inner.insertBefore(back, inner.firstChild);
  }

  if (activeTab === 'runtime'){
    if (buildBtn) buildBtn.style.display = 'none';
    if (nameInput) nameInput.style.display = 'none';
    back.style.display = '';
    // ensure play button looks active
    if (playBtn) playBtn.classList.add('active');
  }else{
    if (buildBtn) buildBtn.style.display = '';
    if (nameInput) nameInput.style.display = '';
    back.style.display = 'none';
  }
}


function ensureCanvasToolbar(){
  // Prefer the resizable wrapper if present (builder screen)
  const canvasWrap = document.querySelector('.resizable-wrap') ||
                     document.querySelector('.canvas-dropzone, .dropzone, .board-drop, .canvas-wrap, .canvas-container, .canvas-frame, .builder-canvas, .board, .canvas');
  if (!canvasWrap) return;

  // Find or create toolbar
  let toolbar = document.querySelector('.canvas-toolbar');
  if (!toolbar){
    toolbar = document.createElement('div');
    toolbar.className = 'canvas-toolbar';
    toolbar.innerHTML = '<div class="canvas-toolbar-inner" id="canvasToolbarInner"></div>';
    canvasWrap.parentElement.insertBefore(toolbar, canvasWrap);
  }
  const inner = document.getElementById('canvasToolbarInner');
  if (!inner) return;

  const tabs = document.querySelector('.tabs');
  const title = document.getElementById('titleInput');

  if (tabs && !inner.contains(tabs)) inner.appendChild(tabs);
  if (title && !inner.contains(title)) inner.appendChild(title);
}



// --- Replace "Tap a widget..." hint with the Build/Play/Name toolbar ---
function placeToolbarWhereHintWas(){
  const toolbar = document.querySelector('.canvas-toolbar');
  if (!toolbar) return;

  // Try to find the hint element by common classes
  let hint = document.querySelector('.tap-hint, .canvas-hint, .builder-hint, .tap-instruction, .hint-text, .place-hint');

  // Fallback: search for an element that contains the text "Tap a widget" (case-insensitive)
  if (!hint){
    const candidates = Array.from(document.querySelectorAll('div, p, span'))
      .filter(el => (el.textContent || '').trim().toLowerCase().includes('tap a widget'));
    hint = candidates[0] || null;
  }

  if (hint && hint.parentElement){
    // Ensure toolbar is not already in the desired parent
    if (toolbar.parentElement !== hint.parentElement){
      hint.parentElement.replaceChild(toolbar, hint);
    }else{
      // Same parent: just place before hint and remove hint
      hint.parentElement.insertBefore(toolbar, hint);
      hint.remove();
    }
    return;
  }

  // If we still didn't find it, just ensure toolbar sits right above the canvas (existing behavior)
  // (No-op)
}


document.addEventListener('DOMContentLoaded', init);

document.addEventListener('click', (e)=>{
  const btn = e.target && e.target.closest ? e.target.closest('[data-tab]') : null;
  if (!btn) return;
  const tab = btn.getAttribute('data-tab');
  try{ updateToolbarForMode(tab); }catch(e){}
});

</script>

<input type="file" id="jsonFileInput" accept="application/json" style="display:none" />



<script>
(function(){
  // --- header height -> CSS var (avoid overlap with sticky header) ---
  function updateHeaderH(){
    const hdr = document.querySelector('.hero-header, header');
    const h = hdr ? Math.ceil(hdr.getBoundingClientRect().height) : 90;
    document.documentElement.style.setProperty('--headerH', h+'px');
  }
  window.addEventListener('resize', updateHeaderH);
  window.addEventListener('load', updateHeaderH);

  // --- helper UI creation ---
  function ensureHelperUI(){
    if (document.getElementById('helperPanel')) return;

    const panel = document.createElement('div');
    panel.id = 'helperPanel';
    panel.className = 'helper-panel';
    panel.style.display = 'none'; // default: avoid overlapping anything

    panel.innerHTML = `
      <div class="helper-titlebar" id="helperDrag">
        <div class="helper-title">ðŸ§° Helper Tools</div>
        <div class="helper-actions">
          <button class="helper-action" id="helperFold" title="Fold">â€“</button>
          <button class="helper-action" id="helperClose" title="Hide">âœ•</button>
        </div>
      </div>
      <div class="helper-body">
        <details class="helper-details" open>
          <summary>ðŸ›  Edit <span>â–¾</span></summary>
          <div class="helper-content" id="helperEdit"></div>
        </details>
        <details class="helper-details">
          <summary>ðŸ“ Arrange <span>â–¾</span></summary>
          <div class="helper-content" id="helperArrange"></div>
        </details>
        <details class="helper-details">
          <summary>ðŸ”Ž View <span>â–¾</span></summary>
          <div class="helper-content" id="helperView"></div>
        </details>
        <details class="helper-details">
          <summary>ðŸ—ºï¸ Minimap <span>â–¾</span></summary>
          <div class="helper-content" id="helperMini"></div>
        </details>
      </div>
    `;
    document.body.appendChild(panel);

    const fab = document.createElement('div');
    fab.id = 'helperFab';
    fab.className = 'helper-fab';
    fab.textContent = 'ðŸ§°';
    document.body.appendChild(fab);

    // restore panel position if saved
    const saved = localStorage.getItem('helperPanelPos');
    if (saved){
      try{
        const {x,y} = JSON.parse(saved);
        if (Number.isFinite(x) && Number.isFinite(y)){
          panel.style.left = x+'px';
          panel.style.top = y+'px';
          panel.style.right = 'auto';
        }
      }catch(e){}
    }

    function isBad(el){
      if (!el) return true;
      if (el === document.documentElement || el === document.body) return false;
      if (el.closest && el.closest('.helper-panel')) return true;
      if (el.closest && el.closest('.modal, .modal-bg, .template-modal')) return true;
      // if it's a control, it's "not empty"
      if (el.closest && el.closest('button, a, input, select, textarea, .palette, .palette-card, .props-panel, .hero-header, header')) return true;
      return false;
    }
    function isGoodEmpty(el){
      if (!el) return true;
      if (el === document.documentElement || el === document.body) return true;
      // canvas area counts as "empty enough" for placing the icon (won't block clicks much)
      if (el.closest && (el.closest('#canvas') || el.closest('.canvas') || el.closest('main'))) return true;
      return false;
    }

    function pickFabSide(){
      const y = Math.max(80, window.innerHeight - 70);
      // candidate LEFT: either after left sidebar (if any) or 18px
      const leftBlock = document.querySelector('.left-panel, .sidebar-left, .side-left, .menu-left, .builder-sidebar, .palette-card, .palette');
      const leftX = leftBlock ? Math.ceil(leftBlock.getBoundingClientRect().right) + 14 : 18;

      // sample a few points in the icon area
      const sample = (x) => {
        const pts = [[x+18,y-18],[x+36,y-18],[x+18,y-36],[x+36,y-36]];
        for (const [px,py] of pts){
          const el = document.elementFromPoint(Math.min(window.innerWidth-1, px), Math.min(window.innerHeight-1, py));
          if (isBad(el)) return false;
        }
        // allow placement if area is generally background/canvas/main
        const el2 = document.elementFromPoint(Math.min(window.innerWidth-1, x+26), Math.min(window.innerHeight-1, y-26));
        return isGoodEmpty(el2);
      };

      if (sample(leftX)) return {side:'left', x:leftX};
      return {side:'right', x: null};
    }

    function placeFab(){
      const pick = pickFabSide();
      if (pick.side === 'left'){
        fab.style.left = pick.x + 'px';
        fab.style.right = 'auto';
      } else {
        fab.style.right = '18px';
        fab.style.left = 'auto';
      }
    }

    function showPanel(){
      fab.style.display = 'none';
      panel.style.display = 'block';
      updateHeaderH();
    }
    function hidePanel(){
      panel.style.display = 'none';
      placeFab();
      fab.style.display = 'flex';
    }

        // close hides; fold just collapses (does NOT hide)
    panel.querySelector('#helperClose').onclick = hidePanel;

    const foldBtn = panel.querySelector('#helperFold');
    function setFolded(on){
      panel.classList.toggle('folded', !!on);
      // icon switch: â€“ when open, + when folded
      foldBtn.textContent = on ? 'ï¼‹' : 'â€“';
      foldBtn.title = on ? 'Expand' : 'Fold';
      try{ localStorage.setItem('helperPanelFolded', on ? '1' : '0'); }catch(e){}
    }
    // restore folded state - default to folded
    try{
      const savedFold = localStorage.getItem('helperPanelFolded');
      if (savedFold !== '0') setFolded(true); // Folded unless explicitly expanded
    }catch(e){ setFolded(true); }
    foldBtn.onclick = () => setFolded(!panel.classList.contains('folded'));

    fab.onclick = showPanel;

    // Place FAB initially (panel hidden by default)
    placeFab();
    window.addEventListener('resize', placeFab);

    // Dragging (use interact.js if present, else pointer events)
    function enableDrag(){
      const handle = panel.querySelector('#helperDrag');
      if (window.interact){
        let x = panel.offsetLeft, y = panel.offsetTop;
        // if positioned by right/top, offsetLeft might be 0; derive from rect
        const r = panel.getBoundingClientRect();
        x = r.left; y = r.top;

        interact(panel).draggable({
          allowFrom: '#helperDrag',
          listeners: {
            move (event) {
              x += event.dx;
              y += event.dy;
              // clamp in viewport
              const maxX = window.innerWidth - panel.offsetWidth - 6;
              const maxY = window.innerHeight - panel.offsetHeight - 6;
              x = Math.max(6, Math.min(maxX, x));
              y = Math.max(6, Math.min(maxY, y));

              panel.style.left = x + 'px';
              panel.style.top = y + 'px';
              panel.style.right = 'auto';
              localStorage.setItem('helperPanelPos', JSON.stringify({x, y}));
            }
          }
        });
      } else {
        let dragging=false, dx=0, dy=0;
        handle.addEventListener('pointerdown', (e)=>{
          dragging=true;
          const r = panel.getBoundingClientRect();
          dx = e.clientX - r.left;
          dy = e.clientY - r.top;
          handle.setPointerCapture(e.pointerId);
        });
        handle.addEventListener('pointermove', (e)=>{
          if (!dragging) return;
          let x = e.clientX - dx;
          let y = e.clientY - dy;
          const maxX = window.innerWidth - panel.offsetWidth - 6;
          const maxY = window.innerHeight - panel.offsetHeight - 6;
          x = Math.max(6, Math.min(maxX, x));
          y = Math.max(6, Math.min(maxY, y));
          panel.style.left = x+'px';
          panel.style.top = y+'px';
          panel.style.right = 'auto';
          localStorage.setItem('helperPanelPos', JSON.stringify({x,y}));
        });
        handle.addEventListener('pointerup', ()=> dragging=false);
      }
    }
    enableDrag();

    // Move existing canvas tools into this panel when they appear
    function moveToolsOnce(){
      const canvas = document.getElementById('canvas') || document.querySelector('.canvas');
      const smart = document.querySelector('.smart-toolbar');
      const tools = document.querySelector('.canvas-tools');
      const zoom = document.querySelector('.zoom-controls');
      const mini = document.querySelector('.minimap');

      if (!smart && !tools && !zoom && !mini) return false;

      // If they are inside canvas, move them
      if (smart) document.getElementById('helperView').appendChild(smart);
      if (zoom) document.getElementById('helperView').appendChild(zoom);
      if (tools) document.getElementById('helperEdit').appendChild(tools);
      if (mini) document.getElementById('helperMini').appendChild(mini);

      // Arrange buttons sometimes were inside smart-toolbar; keep as-is.
      // If there is a second toolbar group for arrange, keep it under Arrange section if present:
      const arrangeBar = document.querySelector('.smart-toolbar.arrange, .arrange-toolbar');
      if (arrangeBar) document.getElementById('helperArrange').appendChild(arrangeBar);

      // Remove any empty leftover wrappers in canvas
      if (canvas){
        canvas.querySelectorAll('.smart-toolbar, .canvas-tools, .zoom-controls, .minimap').forEach(()=>{});
      }
      return true;
    }

    // try a few times until app builds the tools
    let tries = 0;
    const timer = setInterval(()=>{
      tries++;
      if (moveToolsOnce() || tries > 40) clearInterval(timer);
    }, 250);

    // expose for debugging
    window.__helperTools = {showPanel, hidePanel, placeFab};
  }

  // Start after DOM is ready
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureHelperUI);
  } else {
    ensureHelperUI();
  }
})();
</script>



<!-- SYNC PATCH START -->
<script>
/*
  Single Source of Truth + Prop Sync + Warnings + Export Validation
  Source of truth: state.config.widgets
  - Builder DOM widgets mirror config widgets (props + x/y/w/h)
  - Runtime builds ONLY from config widgets (existing behavior)
  - Any UI parameter change must call setProp(id,key,val)
*/
(function(){
  if (window.__SST_PATCH__) return;
  window.__SST_PATCH__ = true;

  // Expose state for debugging/tools if not already
  try { if (window.state == null && typeof state !== "undefined") window.state = state; } catch(e){}

  function deepClone(o){ try{return JSON.parse(JSON.stringify(o));}catch(e){ return o; } }

  function cfgWidgets(){ return (window.state && state.config && Array.isArray(state.config.widgets)) ? state.config.widgets : null; }

  function findCfg(id){
    const arr = cfgWidgets(); if(!arr) return null;
    return arr.find(w=>w && w.id === id) || null;
  }

  // Ensure every config widget has props object
  function ensureProps(cfg){
    if(!cfg) return;
    if(!cfg.props || typeof cfg.props !== "object") cfg.props = {};
  }

  // Apply props to builder DOM widget (visual parity)
  function applyPropsToBuilder(el, cfg){
    if(!el || !cfg) return;
    ensureProps(cfg);
    const p = cfg.props;

    // Store type for generic handling
    if (cfg.type) el.dataset.type = cfg.type;

    // Generic label
    if (p.label != null){
      const lab = el.querySelector('.widget-label');
      if(lab) lab.textContent = p.label;
      el.dataset.label = p.label;
    }

    // LED colors
    if ((cfg.type === 'led') || el.classList.contains('led') || el.dataset.type === 'led'){
      // Use onColor/offColor if present; else fallback to previous defaults
      const onC  = p.onColor  || '#ff5252';
      const offC = p.offColor || 'rgba(255,82,82,0.2)';
      el.dataset.onColor = onC;
      el.dataset.offColor = offC;
      // In builder we show "off" by default unless p.isOn
      const isOn = !!p.isOn;
      el.style.background = isOn ? onC : offC;
    }

    // Button bg color (optional)
    if (cfg.type === 'button' && p.color){
      el.style.background = p.color;
    }

    // Switch/toggle colors (optional)
    if ((cfg.type === 'toggle' || cfg.type === 'switch') && (p.onColor || p.offColor)){
      const isOn = !!p.isOn;
      if (isOn && p.onColor) el.style.background = p.onColor;
      if (!isOn && p.offColor) el.style.background = p.offColor;
    }
  }

  // Apply props to runtime element right after creation (visual parity)
  function applyPropsToRuntime(rtEl, cfg){
    if(!rtEl || !cfg) return;
    ensureProps(cfg);
    const p = cfg.props;

    // LED runtime element uses .rt-led
    if ((cfg.type === 'led') || rtEl.classList.contains('rt-led')){
      const led = rtEl.querySelector('.rt-led') || rtEl;
      const onC  = p.onColor  || '#ff5252';
      const offC = p.offColor || 'rgba(255,82,82,0.2)';
      const isOn = !!p.isOn;
      led.style.background = isOn ? onC : offC;
      if (led.classList.contains('rt-led')){
        led.classList.toggle('on', isOn);
      }
    }

    // Generic label
    if (p.label != null){
      const t = rtEl.querySelector('.rt-label-text');
      if(t) t.textContent = p.label;
    }

    // Button
    if (cfg.type === 'button' && p.color){
      const b = rtEl.querySelector('button') || rtEl;
      b.style.background = p.color;
    }
  }

  // === Single Source of Truth API ===
  window.setProp = function(id, key, val){
    const cfg = findCfg(id);
    if(!cfg) return false;
    ensureProps(cfg);
    cfg.props[key] = val;

    // Mirror to builder element if present
    const el = document.querySelector(`.widget[data-id="${CSS.escape(id)}"]`) || document.getElementById(id);
    if(el) applyPropsToBuilder(el, cfg);

    // If runtime is active, re-render (safe)
    if (state && state.mode === 'runtime' && typeof window.renderRuntime === 'function'){
      try { window.renderRuntime(); } catch(e){}
    }
    return true;
  };

  window.getProp = function(id, key){
    const cfg = findCfg(id);
    if(!cfg || !cfg.props) return undefined;
    return cfg.props[key];
  };

  // === Hook: whenever a builder widget is created/loaded, copy its visual props into config if missing ===
  function normalizeBuilderWidget(el){
    if(!el) return;
    const id = el.dataset.id || el.id;
    if(!id) return;
    const cfg = findCfg(id);
    if(!cfg) return;
    ensureProps(cfg);

    // If LED has dataset or style but props missing -> fill
    if ((cfg.type === 'led') || el.dataset.type === 'led'){
      if(!cfg.props.onColor){
        const c = el.dataset.onColor || el.style.backgroundColor || '#ff5252';
        cfg.props.onColor = c;
      }
      if(!cfg.props.offColor){
        cfg.props.offColor = el.dataset.offColor || 'rgba(255,82,82,0.2)';
      }
    }

    // Label
    const lab = el.querySelector('.widget-label');
    if(lab && cfg.props.label == null) cfg.props.label = lab.textContent;

    applyPropsToBuilder(el, cfg);
  }

  // Run once after load
  window.addEventListener('load', ()=>{
    document.querySelectorAll('.widget').forEach(normalizeBuilderWidget);
  });

  // Observe widgets layer to normalize new widgets
  const layer = document.getElementById('widgetsLayer') || document.querySelector('#widgetsLayer');
  if (layer && window.MutationObserver){
    const mo = new MutationObserver(muts=>{
      muts.forEach(m=>{
        m.addedNodes && m.addedNodes.forEach(n=>{
          if(n && n.classList && n.classList.contains('widget')) normalizeBuilderWidget(n);
          if(n && n.querySelectorAll) n.querySelectorAll('.widget').forEach(normalizeBuilderWidget);
        });
      });
    });
    mo.observe(layer, {childList:true, subtree:true});
  }

  // === Hook color inputs in properties panel (generic) ===
  // Many color pickers exist; we map by label text near it if possible, else fallback to LED onColor.
  document.addEventListener('input', (e)=>{
    const t = e.target;
    if(!t || t.type !== 'color') return;
    const sw = window.selectedWidget;
    if(!sw) return;
    const id = sw.dataset.id || sw.id;
    if(!id) return;

    // Try infer which color field it is
    let key = 'color';
    const lab = t.closest('label') || t.parentElement;
    const txt = (lab && lab.textContent) ? lab.textContent.toLowerCase() : '';
    if (txt.includes('on')) key = 'onColor';
    else if (txt.includes('off')) key = 'offColor';
    else if ((findCfg(id)||{}).type === 'led') key = 'onColor';

    window.setProp(id, key, t.value);
  }, true);

  // === Runtime creation hook: after renderRuntime finishes, apply props to runtime nodes ===
  const origRender = window.renderRuntime;
  if (typeof origRender === 'function'){
    window.renderRuntime = function(){
      const r = origRender.apply(this, arguments);
      try{
        // Attempt to map runtime nodes by data-id or id
        const arr = cfgWidgets() || [];
        arr.forEach(cfg=>{
          const rid = cfg.id;
          let rt = document.querySelector(`#runtimeGrid [data-id="${CSS.escape(rid)}"]`)
                || document.querySelector(`#runtimeGrid #${CSS.escape(rid)}`);
          // If not found, try common class container
          if(rt) applyPropsToRuntime(rt, cfg);
        });
      }catch(e){}
      return r;
    };
  }

  // === Warnings panel: visual state but no props ===
  const warn = document.createElement('div');
  warn.id = 'warnPanel';
  warn.style.cssText = `
    position:fixed; top:calc(var(--headerH, 90px) + 8px); left:10px;
    width:min(340px, 90vw); max-height:32vh; overflow:auto;
    background:rgba(255,165,0,.12); border:2px solid rgba(255,165,0,.85);
    border-radius:12px; padding:10px; z-index:160; color:#fff;
    font:12px system-ui, sans-serif; display:none;
  `;
  warn.innerHTML = `<div style="font-weight:900;letter-spacing:.08em;text-transform:uppercase;">âš  Props Warnings</div>
  <div id="warnBody" style="margin-top:6px;opacity:.95"></div>`;
  document.body.appendChild(warn);

  function scanWarnings(){
    const arr = cfgWidgets(); if(!arr) return;
    const issues = [];
    arr.forEach(w=>{
      if(!w) return;
      if(!w.props) issues.push({id:w.id, msg:'Missing props object'});
      else if (w.type === 'led'){
        if(!w.props.onColor) issues.push({id:w.id, msg:'LED missing onColor (runtime will default red)'});
        if(!w.props.offColor) issues.push({id:w.id, msg:'LED missing offColor'});
      }
    });
    const body = document.getElementById('warnBody');
    if(!body) return;
    if(issues.length===0){ warn.style.display='none'; return; }
    warn.style.display='block';
    body.innerHTML = issues.map(x=>`<div style="margin:6px 0;"><b>${x.id}</b>: ${x.msg}</div>`).join('');
  }
  setInterval(scanWarnings, 800);

  // === Export-time validation ===
  // If there is an export function, wrap it; else add a button in helper tools if found.
  function validateConfig(){
    const arr = cfgWidgets(); if(!arr) return {ok:true, issues:[]};
    const issues = [];
    arr.forEach(w=>{
      if(!w) return;
      if(!w.props) issues.push(`${w.id}: missing props`);
      if(w.type==='led' && w.props){
        if(!w.props.onColor) issues.push(`${w.id}: LED missing onColor`);
      }
    });
    return {ok: issues.length===0, issues};
  }

  function alertIssues(res){
    if(res.ok) return true;
    alert("Export blocked: fix these first\\n\\n" + res.issues.join("\\n"));
    return false;
  }

  // Try wrap exportProject if exists
  if (typeof window.exportProject === 'function'){
    const orig = window.exportProject;
    window.exportProject = function(){
      const res = validateConfig();
      if(!alertIssues(res)) return;
      return orig.apply(this, arguments);
    };
  }
})();
</script>
<!-- SYNC PATCH END -->





<!-- SELECTION PATCH START -->
<script>
(function(){
  if(window.__SEL_PATCH__) return;
  window.__SEL_PATCH__ = true;

  function cfgArr(){ return (window.state && state.config && Array.isArray(state.config.widgets)) ? state.config.widgets : []; }
  function findCfg(id){ return cfgArr().find(w=>w && w.id===id) || null; }
  function linkProps(el){
    if(!el) return;
    const id = el.dataset.id || el.id;
    if(!id) return;
    const cfg = findCfg(id);
    if(!cfg) return;
    if(!cfg.props || typeof cfg.props!=="object") cfg.props = {};
    // Single source of truth: builder widget points to cfg.props (same object)
    el.props = cfg.props;
    try{ el.dataset.type = cfg.type || el.dataset.type; }catch(e){}
  }

  // Capture clicks/taps to set selectedWidget reliably
  document.addEventListener('pointerdown', (e)=>{
    const w = e.target && e.target.closest ? e.target.closest('.widget') : null;
    if(!w) return;
    linkProps(w);
    window.selectedWidget = w;
  }, true);

  // Also sync when original code sets selection via click
  document.addEventListener('click', (e)=>{
    const w = e.target && e.target.closest ? e.target.closest('.widget') : null;
    if(!w) return;
    linkProps(w);
    window.selectedWidget = w;
  }, true);

  // Normalize existing widgets once
  window.addEventListener('load', ()=>{
    document.querySelectorAll('.widget').forEach(linkProps);
  });
})();
</script>
<!-- SELECTION PATCH END -->


<script>
/* === Helper Tools: ensure buttons actually exist (create if missing) === */
(function(){
  if (window.__HELPER_TOOLS_BUILDER__) return;
  window.__HELPER_TOOLS_BUILDER__ = true;

  function $(s){ return document.querySelector(s); }

  function buildHelperTools(){
    const panel = document.getElementById('helperPanel');
    if(!panel) return false;

    const edit = document.getElementById('helperEdit');
    const arrange = document.getElementById('helperArrange');
    const view = document.getElementById('helperView');
    const miniWrap = document.getElementById('helperMini');

    if(!edit || !arrange || !view || !miniWrap) return false;

    // If already populated, do nothing
    if (edit.children.length || arrange.children.length || view.children.length) return true;

    // --- Create toolbars (same ids as the rest of your app expects) ---
    const tools = document.createElement('div');
    tools.className = 'canvas-tools';
    tools.innerHTML = `
      <button class="canvas-tool-btn" id="duplicateBtn" title="Duplicate (Ctrl+D)">â§‰</button>
      <button class="canvas-tool-btn" id="groupBtn" title="Group (Ctrl+G)">âš­</button>
      <button class="canvas-tool-btn" id="layersBtn" title="Layers (L)">â˜°</button>
      <button class="canvas-tool-btn" id="themeBtn" title="Theme (T)">ðŸŽ¨</button>
      <button class="canvas-tool-btn" id="bgBtn" title="Canvas Background">ðŸ–¼ï¸</button>
      <button class="canvas-tool-btn" id="shareBtn" title="Share QR">ðŸ“±</button>
      <button class="canvas-tool-btn" id="screenshotBtn" title="Screenshot">ðŸ“¸</button>
      <button class="canvas-tool-btn" id="sensorBtn" title="Sensor Sim">ðŸŽ®</button>
      <button class="canvas-tool-btn" id="pinBtn" title="Pin Reference">ðŸ“Œ</button>
      <button class="canvas-tool-btn" id="contrastBtn" title="High Contrast">â—</button>
      <button class="canvas-tool-btn" id="helpBtn" title="Help (?)">â“</button>
    `;
    edit.appendChild(tools);

    const arrangeBar = document.createElement('div');
    arrangeBar.className = 'smart-toolbar arrange-toolbar';
    arrangeBar.innerHTML = `
      <div class="toolbar-group">
        <button class="canvas-tool-btn" id="arrangeGrid" title="Auto Grid">âŠž</button>
        <button class="canvas-tool-btn" id="arrangeRows" title="Rows">â‰¡</button>
        <button class="canvas-tool-btn" id="arrangeCols" title="Columns">â«¾</button>
      </div>
      <div class="toolbar-group">
        <button class="canvas-tool-btn" id="alignL" title="Align Left">â«·</button>
        <button class="canvas-tool-btn" id="alignR" title="Align Right">â«¸</button>
        <button class="canvas-tool-btn" id="alignT" title="Align Top">âŠ¤</button>
        <button class="canvas-tool-btn" id="alignB" title="Align Bottom">âŠ¥</button>
        <button class="canvas-tool-btn" id="distH" title="Distribute H">â†”</button>
        <button class="canvas-tool-btn" id="distV" title="Distribute V">â†•</button>
      </div>
    `;
    arrange.appendChild(arrangeBar);

    const viewBar = document.createElement('div');
    viewBar.className = 'smart-toolbar';
    viewBar.innerHTML = `
      <div class="toolbar-group">
        <button class="canvas-tool-btn ${window.state?.gridSnap ? 'active' : ''}" id="gridToggle" title="Grid Snap (G)">âŠž</button>
        <button class="canvas-tool-btn ${window.state?.showGuides ? 'active' : ''}" id="guidesToggle" title="Guides">â”¼</button>
        <button class="canvas-tool-btn" id="rulerToggle" title="Ruler">ðŸ“</button>
      </div>
    `;
    view.appendChild(viewBar);

    const zoom = document.createElement('div');
    zoom.className = 'zoom-controls';
    zoom.innerHTML = `
      <button class="zoom-btn" id="zoomOut">âˆ’</button>
      <div class="zoom-level" id="zoomLevel">100%</div>
      <button class="zoom-btn" id="zoomIn">+</button>
    `;
    view.appendChild(zoom);

    // Minimap container exists in panel; make sure minimap element exists
    let mini = miniWrap.querySelector('.minimap');
    if(!mini){
      mini = document.createElement('div');
      mini.className = 'minimap';
      miniWrap.appendChild(mini);
    }

    // --- Wire events (guard if functions exist) ---
    const bind = (id, fnName) => {
      const el = document.getElementById(id);
      const fn = window[fnName];
      if(el && typeof fn === 'function') el.onclick = fn;
    };

    bind('duplicateBtn','duplicateSelected');
    bind('groupBtn','groupSelected');
    bind('layersBtn','toggleLayers');
    bind('themeBtn','cycleTheme');
    bind('bgBtn','setCanvasBackground');
    bind('shareBtn','generateQR');
    bind('screenshotBtn','exportScreenshot');
    bind('sensorBtn','toggleSensorSim');
    bind('pinBtn','showPinMapping');
    bind('contrastBtn','toggleHighContrast');
    bind('helpBtn','showHelp');

    bind('arrangeGrid','autoArrangeGrid');
    bind('arrangeRows','autoArrangeRows');
    bind('arrangeCols','autoArrangeCols');
    bind('alignL','alignLeft');
    bind('alignR','alignRight');
    bind('alignT','alignTop');
    bind('alignB','alignBottom');
    bind('distH','distributeH');
    bind('distV','distributeV');

    const gridToggle = document.getElementById('gridToggle');
    if(gridToggle){
      gridToggle.onclick = () => {
        if(!window.state) return;
        state.gridSnap = !state.gridSnap;
        gridToggle.classList.toggle('active', state.gridSnap);
        const c = document.getElementById('canvas');
        if(c) c.classList.toggle('show-grid', state.gridSnap);
        if(typeof window.toast==='function') toast(state.gridSnap ? 'âŠž Grid ON' : 'âŠž Grid OFF', 'success');
      };
    }
    const guidesToggle = document.getElementById('guidesToggle');
    if(guidesToggle){
      guidesToggle.onclick = () => {
        if(!window.state) return;
        state.showGuides = !state.showGuides;
        guidesToggle.classList.toggle('active', state.showGuides);
        if(typeof window.toast==='function') toast(state.showGuides ? 'â”¼ Guides ON' : 'â”¼ Guides OFF', 'success');
      };
    }
    bind('rulerToggle','toggleRuler');

    const zoomIn = document.getElementById('zoomIn');
    const zoomOut = document.getElementById('zoomOut');
    if(zoomIn && typeof window.setZoom==='function') zoomIn.onclick = () => setZoom((state.zoom||1) + 0.1);
    if(zoomOut && typeof window.setZoom==='function') zoomOut.onclick = () => setZoom((state.zoom||1) - 0.1);

    return true;
  }

  // Make sure the helper panel exists and is populated once the app is ready
  const origEnsure = window.ensureHelperUI;
  window.ensureHelperUI = function(){
    const r = origEnsure ? origEnsure.apply(this, arguments) : undefined;
    // try populate after creation
    setTimeout(buildHelperTools, 0);
    setTimeout(buildHelperTools, 250);
    setTimeout(buildHelperTools, 800);
    return r;
  };

  // If setupCanvasTools exists, ensure it creates panel + tools
  const origSetup = window.setupCanvasTools;
  window.setupCanvasTools = function(){
    const r = origSetup ? origSetup.apply(this, arguments) : undefined;
    try{ window.ensureHelperUI(); }catch(e){}
    setTimeout(buildHelperTools, 0);
    return r;
  };

  window.addEventListener('load', ()=>{
    try{ window.ensureHelperUI(); }catch(e){}
    buildHelperTools();
  });
})();
</script>


<script>
/* === Default View Settings === */
(function(){
  try{
    if(window.state){
      state.gridSnap = false;
      state.showGrid = false;
      state.showGuides = false;
      state.showRuler = true;
    }
  }catch(e){}
})();
</script>


<script>
/* === Default View Settings (final) === */
(function(){
  try{
    if(window.state){
      state.gridSnap = false;
      state.showGrid = false;
      state.showGuides = true;   // guides ON
      state.showRuler = true;   // ruler ON
    }
  }catch(e){}
})();
</script>


<!-- === AUTO-INJECTED: Unified Logs System (card+tab+fab, TX/RX colors, filters, JSON export, silent console) === -->
<style>
/* ---- Logs UI ---- */
#logCard{
  position: fixed;
  left: 10px;
  right: 80px;
  bottom: 10px;
  z-index: 900;
  border-radius: 14px;
  border: 2px solid rgba(255,255,255,0.12);
  background: rgba(10,18,44,0.92);
  backdrop-filter: blur(12px);
  box-shadow: 0 10px 30px rgba(0,0,0,0.4);
  overflow: hidden;
  display: flex;
  flex-direction: column;
  width: auto;
  max-height: 40vh;
  pointer-events: auto;
}
#logCard.collapsed{ 
  max-height: 36px !important; 
  left: auto;
  right: 80px;
  width: auto;
  min-width: 80px;
}

#logHead{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding: 8px 10px;
  border-bottom: 1px solid rgba(255,255,255,0.10);
}
#logTitle{ font-weight: 900; letter-spacing:.12em; text-transform: uppercase; font-size: 12px; color: rgba(255,255,255,0.92); display:flex; gap:8px; align-items:center; }
#logCount{ font-weight:900; font-size:12px; color: rgba(255,255,255,0.75); padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.05); }
.log-btn, #logToggle{
  padding: 7px 10px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.06);
  color: rgba(255,255,255,0.92);
  font-weight: 850;
  cursor: pointer;
}
.log-btn:hover, #logToggle:hover{ border-color: var(--accent); }
#logToggle{ width: 34px; height: 30px; padding: 0; font-weight: 950; }

#logActions{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }

#logFilters{
  display:flex;
  gap:8px;
  align-items:center;
  flex-wrap:wrap;
  padding: 8px 10px;
  border-bottom: 1px solid rgba(255,255,255,0.08);
  background: rgba(0,0,0,0.12);
}
.log-chip{
  display:flex; align-items:center; gap:6px;
  padding: 5px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.05);
  font-size: 12px;
  font-weight: 850;
  user-select:none;
}
.log-chip input{ accent-color: var(--accent); }

#logBody{
  flex: 1 1 auto;
  min-height: 120px;
  overflow: auto;
  padding: 10px;
  font: 12px ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  color: rgba(255,255,255,0.94);
}
#logCard.collapsed #logFilters,
#logCard.collapsed #logBody{ display:none !important; }
#logCard.collapsed #logToggle{ transform: rotate(-90deg); }

/* colored rows */
.log-line{ padding:2px 0; white-space: pre-wrap; word-break: break-word; }
.log-line .ts{ color: rgba(255,255,255,0.55); margin-right:8px; }
.log-line .tag{
  display:inline-block; min-width:78px; text-align:center;
  font-weight: 950; font-size: 11px;
  padding: 2px 6px; border-radius: 999px;
  margin-right: 8px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.05);
}
.log-line.level-error{ color: rgba(255,120,120,0.98); }
.log-line.level-warn{ color: rgba(255,240,120,0.98); }
.log-line.level-ble{ color: rgba(255,255,255,0.94); }

.log-line.dir-rx{ color: rgba(96,239,255,0.96); }
.log-line.dir-tx{ color: rgba(255,145,0,0.96); }

/* FAB bottom-right */
#logFab{
  position: fixed;
  right: 16px;
  bottom: 16px;
  z-index: 99999;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background: var(--accent);
  color: #000;
  font-weight: 950;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
  user-select:none;
}

/* Right edge tab (always reachable) */
#logTab{
  position: fixed;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  z-index: 99998;
  padding: 10px 8px;
  border-radius: 14px 0 0 14px;
  background: rgba(10,18,44,0.78);
  border: 1px solid rgba(255,255,255,0.14);
  color: rgba(255,255,255,0.92);
  font-weight: 950;
  letter-spacing: .10em;
  cursor: pointer;
  user-select: none;
  writing-mode: vertical-rl;
  text-orientation: mixed;
}

/* Give canvas room so it isn't covered by logs */
.canvas-wrap{ padding-bottom: 160px; }
</style>

<div id="logFab" title="Logs (Ctrl+Shift+L)">ðŸ§¾</div>
<div id="logTab" title="Logs (Ctrl+Shift+L)">LOGS</div>

<div id="logCard" class="collapsed" aria-live="polite">
  <div id="logHead">
    <button id="logToggle" aria-expanded="false" title="Collapse / Expand">â–¸</button>
    <div id="logTitle">ðŸ§¾ LOGS <span id="logCount">0</span></div>
    <div id="logActions">
      <button class="log-btn" id="logClear">Clear</button>
      <button class="log-btn" id="logExportTxt">TXT</button>
      <button class="log-btn" id="logExportJson">JSON</button>
    </div>
  </div>
  <div id="logFilters"></div>
  <div id="logBody"></div>
</div>

<script>
(function(){
  const DEFAULT_FILTERS = { ble:true, ok:true, warn:true, error:true, info:true, debug:false, log:true };
  let filters = {...DEFAULT_FILTERS};
  let collapsed = true;
  const MAX_ITEMS = 1500;
  const items = [];
  const $ = (id)=>document.getElementById(id);

  function pad(n,w=2){ return String(n).padStart(w,'0'); }
  function stamp(){
    const d=new Date();
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}.${pad(d.getMilliseconds(),3)}`;
  }
  function safeJson(x){ try{ return JSON.stringify(x); }catch(e){ return String(x); } }
  function fmt(args){
    return args.map(x=>{
      if (x instanceof Error) return (x.stack || x.message || String(x));
      if (typeof x === 'object') return safeJson(x);
      return String(x);
    }).join(' ');
  }

  function detect(level,msg){
    const s=String(msg);
    let dir=null, out=s, lvl=level||'log';
    const rx=/^\s*\[?BLE\s*RX\]?\s*[:\-]?\s*/i;
    const tx=/^\s*\[?BLE\s*TX\]?\s*[:\-]?\s*/i;
    if (rx.test(s)){ dir='RX'; out=s.replace(rx,''); lvl='ble'; }
    else if (tx.test(s)){ dir='TX'; out=s.replace(tx,''); lvl='ble'; }
    else if (/^\s*\[BLE\]\s*/i.test(s)){ lvl='ble'; out=s.replace(/^\s*\[BLE\]\s*/i,''); }
    return {lvl,dir,out};
  }

  function push(level,msg,meta={}){
    const d=detect(level,msg);
    const it={ ts: stamp(), level: d.lvl, dir: d.dir || meta.dir || null, msg: d.out };
    items.push(it);
    while(items.length>MAX_ITEMS) items.shift();
    updateCount();
    renderSoon();
  }

  function updateCount(){
    const c=$('logCount'); if(!c) return;
    c.textContent = String(items.length);
  }

  function escapeHtml(s){
    return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'","&#039;");
  }

  let raf=0;
  function renderSoon(force=false){
    if (collapsed && !force) return;
    if (raf) return;
    raf=requestAnimationFrame(()=>{ raf=0; render(); adjustLayout(); });
  }

  function render(){
    const body=$('logBody'); if(!body) return;
    const allow=(lvl)=>!!filters[lvl];
    const html=[];
    for(const it of items){
      if(!allow(it.level)) continue;
      const cls=['log-line', `level-${it.level}`, it.dir?`dir-${it.dir.toLowerCase()}`:''].filter(Boolean).join(' ');
      const tag = it.dir ? `${it.level.toUpperCase()} ${it.dir}` : it.level.toUpperCase();
      html.push(
        `<div class="${cls}"><span class="ts">${escapeHtml(it.ts)}</span><span class="tag">${escapeHtml(tag)}</span><span class="msg">${escapeHtml(it.msg)}</span></div>`
      );
    }
    body.innerHTML = html.join('');
    body.scrollTop = body.scrollHeight;
  }

  // Expose layout adjuster for other injections
  window.__adjustLogsLayout = adjustLayout;
  function adjustLayout(){
    const card=$('logCard');
    const canvasWrap=document.querySelector('.canvas-wrap');
    const resizableWrap=document.getElementById('resizableWrap');
    if(!card) return;
    const h=card.getBoundingClientRect().height||0;
    if(canvasWrap) canvasWrap.style.paddingBottom=(h+14)+'px';
    if(resizableWrap){
      const top=resizableWrap.getBoundingClientRect().top||0;
      const maxH=Math.max(320, Math.floor(window.innerHeight - top - h - 24));
      resizableWrap.style.maxHeight=maxH+'px';
    }
  }

  // Filters UI
  function buildFilters(){
    const host=$('logFilters'); if(!host) return;
    try{
      const saved=JSON.parse(localStorage.getItem('logFilters')||'null');
      if(saved && typeof saved==='object') filters={...filters, ...saved};
    }catch(e){}
    host.innerHTML = `
      <label class="log-chip"><input type="checkbox" data-lvl="ble">BLE</label>
      <label class="log-chip"><input type="checkbox" data-lvl="ok">OK</label>
      <label class="log-chip"><input type="checkbox" data-lvl="warn">WARN</label>
      <label class="log-chip"><input type="checkbox" data-lvl="error">ERROR</label>
      <label class="log-chip"><input type="checkbox" data-lvl="info">INFO</label>
      <label class="log-chip"><input type="checkbox" data-lvl="debug">DEBUG</label>
      <label class="log-chip"><input type="checkbox" data-lvl="log">LOG</label>
    `;
    host.querySelectorAll('input[data-lvl]').forEach(inp=>{
      const lvl=inp.getAttribute('data-lvl');
      inp.checked=!!filters[lvl];
      inp.addEventListener('change', ()=>{
        filters[lvl]=inp.checked;
        localStorage.setItem('logFilters', JSON.stringify(filters));
        renderSoon(true);
      });
    });
  }

  // Export
  function exportTxt(){
    const lines = items.map(it => `[${it.ts}] ${it.level.toUpperCase()}${it.dir?(' '+it.dir):''}  ${it.msg}`);
    const blob = new Blob([lines.join('\\n')], {type:'text/plain'});
    const a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download='logs.txt';
    a.click();
    URL.revokeObjectURL(a.href);
  }
  function exportJson(){
    const blob = new Blob([JSON.stringify(items, null, 2)], {type:'application/json'});
    const a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download='logs.json';
    a.click();
    URL.revokeObjectURL(a.href);
  }

  // Toggle open/close
  function setCollapsed(next){
    collapsed = next;
    const card=$('logCard'), t=$('logToggle');
    if(card) card.classList.toggle('collapsed', collapsed);
    if(t){
      t.textContent = collapsed ? 'â–¸' : 'â–¾';
      t.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
    }
    try{ localStorage.setItem('logCardCollapsed', collapsed ? '1':'0'); }catch(e){}
    renderSoon(true);
    adjustLayout();
  }
  function toggle(){ setCollapsed(!collapsed); }

  // APPLOG API (use this for important events)
  window.APPLOG = {
    log:(...a)=>push('log',fmt(a)),
    info:(...a)=>push('info',fmt(a)),
    debug:(...a)=>push('debug',fmt(a)),
    ble:(...a)=>push('ble',fmt(a)),
    rx:(...a)=>push('ble',fmt(a),{dir:'RX'}),
    tx:(...a)=>push('ble',fmt(a),{dir:'TX'}),
    ok:(...a)=>push('ok',fmt(a)),
    warn:(...a)=>push('warn',fmt(a)),
    err:(...a)=>push('error',fmt(a)),
    clear:()=>{ items.length=0; updateCount(); renderSoon(true); },
    exportTxt, exportJson, toggle, open:()=>setCollapsed(false)
  };

  // Silence DevTools console completely, but capture into logs:
  console.log   = (...a)=>push('log',fmt(a));
  console.info  = (...a)=>push('info',fmt(a));
  console.debug = (...a)=>push('debug',fmt(a));
  console.warn  = (...a)=>push('warn',fmt(a));
  console.error = (...a)=>push('error',fmt(a));

  // Capture uncaught errors (and prevent console spam)
  window.addEventListener('error', (e)=>{ push('error', e.message || 'Uncaught error'); e.preventDefault && e.preventDefault(); }, true);
  window.addEventListener('unhandledrejection', (e)=>{ push('error', String(e.reason)); e.preventDefault && e.preventDefault(); }, true);

  // Wire UI
  window.addEventListener('DOMContentLoaded', ()=>{
    buildFilters();

    // restore collapsed state - default to collapsed
    const saved = localStorage.getItem('logCardCollapsed');
    setCollapsed(saved !== '0'); // Collapsed unless explicitly set to expanded

    $('logToggle')?.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); toggle(); }, {passive:false});
    $('logFab')?.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); toggle(); }, {passive:false});
    $('logTab')?.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); toggle(); }, {passive:false});

    $('logClear')?.addEventListener('click', ()=>window.APPLOG.clear());
    $('logExportTxt')?.addEventListener('click', exportTxt);
    $('logExportJson')?.addEventListener('click', exportJson);

    // keyboard toggle
    window.addEventListener('keydown', (e)=>{
      if(e.ctrlKey && e.shiftKey && (e.key==='L' || e.key==='l')){ e.preventDefault(); toggle(); }
    }, {passive:false});

    // initial message
    push('ok', 'Logs ready (Ctrl+Shift+L). TX=orange, RX=cyan.');
    adjustLayout();
  });

  window.addEventListener('resize', ()=>adjustLayout());

})();
</script>
<!-- === END Unified Logs System === -->

<!-- Zoom Controls -->
<div id="zoomControls" class="zoom-controls">
  <button class="zoom-btn" id="zoomInBtn" title="Zoom In">+</button>
  <div class="zoom-level" id="zoomLevel">100%</div>
  <button class="zoom-btn" id="zoomOutBtn" title="Zoom Out">âˆ’</button>
  <button class="zoom-btn" id="zoomFitBtn" title="Fit to Screen">âŠ¡</button>
  <button class="zoom-btn" id="zoomResetBtn" title="Reset to 100%">1:1</button>
</div>

<script>
(function() {
  // Zoom functionality
  let currentZoom = 1;
  const minZoom = 0.5;
  const maxZoom = 3;
  const zoomStep = 0.15;
  
  const zoomLevel = document.getElementById('zoomLevel');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const zoomFitBtn = document.getElementById('zoomFitBtn');
  const zoomResetBtn = document.getElementById('zoomResetBtn');
  
  function getZoomTarget() {
    // In fullscreen mode, zoom the runtime grid only
    if (document.body.classList.contains('runtime-fullscreen')) {
      return document.getElementById('runtimeGrid');
    }
    // In normal runtime view, still zoom the grid
    const runtimeView = document.querySelector('.runtime-view');
    if (runtimeView && runtimeView.classList.contains('active')) {
      return document.getElementById('runtimeGrid');
    }
    // Otherwise zoom the app (builder mode)
    return document.querySelector('.app');
  }
  
  function applyZoom(zoom) {
    currentZoom = Math.max(minZoom, Math.min(maxZoom, zoom));
    
    const target = getZoomTarget();
    if (target) {
      target.style.transform = `scale(${currentZoom})`;
      target.style.transformOrigin = 'center center';
    }
    
    // Update display
    if (zoomLevel) {
      zoomLevel.textContent = Math.round(currentZoom * 100) + '%';
    }
    
    // Save preference
    try { localStorage.setItem('app_zoom', currentZoom); } catch(e) {}
  }
  
  function zoomIn() {
    applyZoom(currentZoom + zoomStep);
  }
  
  function zoomOut() {
    applyZoom(currentZoom - zoomStep);
  }
  
  function zoomFit() {
    // Fit the runtime grid to screen
    const grid = document.getElementById('runtimeGrid');
    if (!grid) return;
    
    // Reset zoom first to get actual size
    grid.style.transform = '';
    
    const gridW = grid.offsetWidth;
    const gridH = grid.offsetHeight;
    const availW = window.innerWidth - 80;
    const availH = window.innerHeight - 120;
    
    const fitZoom = Math.min(availW / gridW, availH / gridH, 2);
    applyZoom(fitZoom);
  }
  
  function zoomReset() {
    applyZoom(1);
  }
  
  // Event listeners
  if (zoomInBtn) zoomInBtn.onclick = zoomIn;
  if (zoomOutBtn) zoomOutBtn.onclick = zoomOut;
  if (zoomFitBtn) zoomFitBtn.onclick = zoomFit;
  if (zoomResetBtn) zoomResetBtn.onclick = zoomReset;
  
  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Ctrl/Cmd + Plus/Minus for zoom
    if ((e.ctrlKey || e.metaKey) && !e.shiftKey) {
      if (e.key === '=' || e.key === '+') {
        e.preventDefault();
        zoomIn();
      } else if (e.key === '-') {
        e.preventDefault();
        zoomOut();
      } else if (e.key === '0') {
        e.preventDefault();
        zoomReset();
      }
    }
  });
  
  // Mouse wheel zoom with Ctrl
  document.addEventListener('wheel', (e) => {
    if (e.ctrlKey) {
      e.preventDefault();
      if (e.deltaY < 0) {
        zoomIn();
      } else {
        zoomOut();
      }
    }
  }, { passive: false });
  
  // Pinch zoom for touch devices
  let lastTouchDistance = 0;
  document.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
    }
  }, { passive: true });
  
  document.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (lastTouchDistance > 0) {
        const delta = (distance - lastTouchDistance) / 200;
        applyZoom(currentZoom + delta);
      }
      
      lastTouchDistance = distance;
    }
  }, { passive: true });
  
  document.addEventListener('touchend', () => {
    lastTouchDistance = 0;
  }, { passive: true });
  
  // Load saved zoom
  try {
    const savedZoom = localStorage.getItem('app_zoom');
    if (savedZoom) {
      applyZoom(parseFloat(savedZoom));
    }
  } catch(e) {}
  
  // Expose for other scripts
  window.appZoom = {
    zoomIn,
    zoomOut,
    zoomFit,
    zoomReset,
    getZoom: () => currentZoom,
    setZoom: applyZoom
  };
})();
</script>


<style id="logsRightOverride">
/* === FORCE LOGS TO RIGHT SIDEBAR === */
#logCard{
  left: auto !important;
  right: 10px !important;
  bottom: 10px !important;
  top: auto !important;

  width: var(--logsW, 380px) !important;
  height: var(--logsH, 420px) !important;

  max-width: min(960px, 70vw) !important;
  min-width: 260px !important;

  max-height: calc(100vh - 140px) !important;
  min-height: 220px !important;

  transform: none !important;
  overflow: hidden !important;
}

/* Keep the vertical tab on the right */
#logTab{
  position: fixed !important;
  right: 10px !important;
  top: 50% !important;
  transform: translateY(-50%) !important;
  z-index: 950 !important;
}
#logCard:not(.collapsed) + #logTab,
#logCard:not(.collapsed) ~ #logTab{ display:none !important; }

/* Collapsed = only tab */
#logCard.collapsed{
  width: 0 !important; height: 0 !important; padding:0 !important; border:none !important;
  background: transparent !important; box-shadow:none !important; overflow:hidden !important;
}
#logCard.collapsed *{ display:none !important; }

/* Resize handles */
#logResizeHandleX, #logResizeHandleY, #logResizeHandleXY{
  position:absolute;
  z-index: 5000;
  touch-action: none;
}
#logResizeHandleX{
  left:0; top:0; bottom:0; width: 18px;
  cursor: ew-resize;
  background: linear-gradient(90deg, rgba(255,255,255,0.12), rgba(255,255,255,0));
}
#logResizeHandleY{
  left:0; right:0; bottom:0; height: 14px;
  cursor: ns-resize;
  background: linear-gradient(0deg, rgba(255,255,255,0.12), rgba(255,255,255,0));
}
#logResizeHandleXY{
  right:0; bottom:0; width: 18px; height: 18px;
  cursor: nwse-resize;
  background: radial-gradient(circle at top left, rgba(255,255,255,0.16), rgba(255,255,255,0));
}
#logCard.collapsed #logResizeHandleX,
#logCard.collapsed #logResizeHandleY,
#logCard.collapsed #logResizeHandleXY{ display:none !important; }


/* v21: When collapsed, logs have zero footprint */
#logCard.collapsed{
  box-shadow: none !important;
  backdrop-filter: none !important;
  filter: none !important;
  pointer-events: none !important;
}
/* Keep LOGS tab clean */
#logTab{ box-shadow:none !important; }

</style>

<script>
(function(){
  const clamp=(n,min,max)=>Math.max(min,Math.min(max,n));
  function applyWH(w,h){
    const card=document.getElementById('logCard'); if(!card) return;
    const W=clamp(Math.floor(w||380), 260, 960);
    const H=clamp(Math.floor(h||420), 220, Math.floor(window.innerHeight-20));
    card.style.setProperty('--logsW', W+'px');
    card.style.setProperty('--logsH', H+'px');
    card.style.setProperty('width', W+'px', 'important');
    card.style.setProperty('height', H+'px', 'important');
    card.style.width=W+'px'; card.style.height=H+'px';
    try{ localStorage.setItem('logsWidth', String(W)); localStorage.setItem('logsHeight', String(H)); }catch(e){}
    try{
      const pad = card.classList.contains('collapsed') ? 0 : Math.min(740, W + 18);
      const canvasWrap=document.querySelector('.canvas-wrap');
      if(canvasWrap){ canvasWrap.style.paddingRight = pad+'px'; canvasWrap.style.paddingBottom=''; }
    }catch(e){}
  }
  function ensure(){
    const card=document.getElementById('logCard'); if(!card) return false;
    // Add handles
    if(!document.getElementById('logResizeHandleX')){
      const hx=document.createElement('div'); hx.id='logResizeHandleX'; card.appendChild(hx);
      const hy=document.createElement('div'); hy.id='logResizeHandleY'; card.appendChild(hy);
      const hxy=document.createElement('div'); hxy.id='logResizeHandleXY'; card.appendChild(hxy);
    }
    // Apply saved
    try{
      const sw=parseInt(localStorage.getItem('logsWidth')||'380',10);
      const sh=parseInt(localStorage.getItem('logsHeight')||'420',10);
      applyWH(Number.isNaN(sw)?380:sw, Number.isNaN(sh)?420:sh);
    }catch(e){ applyWH(380,420); }
    if(card.__resizerBound) return true;
    card.__resizerBound=true;

    function cx(e){ if(e.touches&&e.touches[0]) return e.touches[0].clientX; if(e.changedTouches&&e.changedTouches[0]) return e.changedTouches[0].clientX; return e.clientX; }
    function cy(e){ if(e.touches&&e.touches[0]) return e.touches[0].clientY; if(e.changedTouches&&e.changedTouches[0]) return e.changedTouches[0].clientY; return e.clientY; }

    const hx=document.getElementById('logResizeHandleX');
    const hy=document.getElementById('logResizeHandleY');
    const hxy=document.getElementById('logResizeHandleXY');

    let mode=null, startX=0, startY=0, startW=0, startH=0;

    function down(m,e){
      if(card.classList.contains('collapsed')) return;
      mode=m;
      startX=cx(e); startY=cy(e);
      const r=card.getBoundingClientRect();
      startW=r.width; startH=r.height;
      document.body.style.userSelect='none';
      document.body.style.cursor = (m==='x'?'ew-resize':m==='y'?'ns-resize':'nwse-resize');
      e.preventDefault?.();
    }
    function move(e){
      if(!mode) return;
      const dx=cx(e)-startX;
      const dy=cy(e)-startY;
      // left-edge drag for X => width increases when moving left (negative dx)
      let W=startW, H=startH;
      if(mode==='x') W = startW - dx;
      if(mode==='y') H = startH + dy; // bottom edge
      if(mode==='xy'){ W = startW - dx; H = startH + dy; }
      applyWH(W,H);
      e.preventDefault?.();
    }
    function up(){
      if(!mode) return;
      mode=null;
      document.body.style.userSelect='';
      document.body.style.cursor='';
    }

    // Bind events
    function bindHandle(el,m){
      el.addEventListener('pointerdown', down.bind(null,m), {passive:false});
      el.addEventListener('mousedown', down.bind(null,m), {passive:false});
      el.addEventListener('touchstart', down.bind(null,m), {passive:false});
    }
    bindHandle(hx,'x'); bindHandle(hy,'y'); bindHandle(hxy,'xy');

    window.addEventListener('pointermove', move, {passive:false});
    window.addEventListener('pointerup', up, {passive:true});
    window.addEventListener('pointercancel', up, {passive:true});
    window.addEventListener('mousemove', move, {passive:false});
    window.addEventListener('mouseup', up, {passive:true});
    window.addEventListener('touchmove', move, {passive:false});
    window.addEventListener('touchend', up, {passive:true});
    window.addEventListener('touchcancel', up, {passive:true});

    return true;
  }

  let tries=0;
  const timer=setInterval(()=>{ if(ensure() || ++tries>140) clearInterval(timer); }, 150);
  const obs=new MutationObserver(()=>{ ensure(); });
  obs.observe(document.documentElement, {childList:true, subtree:true});
})();
</script>

<script>
/* v21: Only the right-side LOGS tab toggles collapse/expand */
(function(){
  function $(sel, root=document){ return root.querySelector(sel); }
  function $all(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function bindOnce(){
    const card = document.getElementById('logCard');
    const tab  = document.getElementById('logTab');
    if(!card || !tab) return false;

    // Hide/remove any extra toggle controls in the header, but keep action buttons (Clear/TXT/JSON).
    const head = card.querySelector('#logHead') || card.querySelector('.logTop') || card;
    const actions = head.querySelector('#logActions') || head; // safe fallback

    // Any buttons inside head that are NOT inside #logActions are treated as toggles/UI chrome -> hide them.
    $all('button', head).forEach(btn=>{
      if(actions && actions.contains(btn)) return; // keep Clear/TXT/JSON etc.
      // keep nothing else in header
      btn.style.display = 'none';
      btn.disabled = true;
      btn.setAttribute('aria-hidden','true');
    });

    // Also disable click toggles on title area if any (some builds make LOGS title clickable)
    const title = head.querySelector('#logTitle') || head.querySelector('.logTitle');
    if(title){
      title.style.pointerEvents = 'none';
    }

    // Make sure tab toggles collapsed state
    if(!tab.__onlyToggleBound){
      tab.__onlyToggleBound = true;
      tab.addEventListener('click', ()=>{
        card.classList.toggle('collapsed');
        try{ localStorage.setItem('logsCollapsed', String(card.classList.contains('collapsed'))); }catch(e){}
        // When expanding: re-enable pointer events automatically via CSS (not collapsed).
        try{ if(typeof window.__adjustLogsLayout==='function') window.__adjustLogsLayout(); }catch(e){}
      });
    }

    // Ensure card reflects saved collapsed state
    try{
      const saved = (localStorage.getItem('logsCollapsed') ?? 'true') === 'true';
      card.classList.toggle('collapsed', saved);
    }catch(e){}

    return true;
  }

  let tries=0;
  const t=setInterval(()=>{
    if(bindOnce() || ++tries>200) clearInterval(t);
  }, 100);

  const obs=new MutationObserver(()=>{ bindOnce(); });
  obs.observe(document.documentElement, {childList:true, subtree:true});
})();
</script>

</body>
</html>
