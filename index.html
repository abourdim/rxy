<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>micro:bit Remote</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/interact.js/1.10.27/interact.min.js"></script>
<style>
:root {
  --bg: #1a1a2e;
  --surface: #16213e;
  --card: #1f3460;
  --accent: #00d4ff;
  --pink: #ff6b9d;
  --green: #00e676;
  --orange: #ff9100;
  --purple: #b388ff;
  --red: #ff5252;
  --yellow: #ffea00;
  --text: #ffffff;
  --text-dim: #8892b0;
}

* { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; overflow: hidden; touch-action: manipulation; font-family: 'Segoe UI', system-ui, sans-serif; }
body { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: var(--text); }

.app { display: flex; flex-direction: column; height: 100dvh; }

/* Header */
header {
  display: flex; align-items: center; gap: 10px;
  padding: 8px 12px; background: rgba(22,33,62,0.95);
  border-bottom: 2px solid var(--card);
}
.logo { font-size: 1.3rem; font-weight: 800; }
.logo span { background: linear-gradient(90deg, var(--accent), var(--pink)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.spacer { flex: 1; }

.tabs { display: flex; background: var(--card); border-radius: 30px; padding: 4px; }
.tab {
  padding: 10px 20px; border: none; background: none;
  color: var(--text-dim); font-weight: 700; font-size: 0.9rem;
  border-radius: 30px; cursor: pointer; transition: 0.2s;
}
.tab.active { background: linear-gradient(135deg, var(--accent), var(--purple)); color: #000; }

.ble-btn {
  display: flex; align-items: center; gap: 8px;
  padding: 10px 16px; border-radius: 30px;
  background: var(--card); border: 2px solid var(--red);
  color: var(--red); font-weight: 700; cursor: pointer;
}
.ble-btn.connected { border-color: var(--green); color: var(--green); }
.ble-dot { width: 12px; height: 12px; border-radius: 50%; background: currentColor; }

/* Main Content */
main { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
.view { display: none; flex-direction: column; height: 100%; }
.view.active { display: flex; }

/* Builder View */
.builder-header {
  display: flex; align-items: center; gap: 8px;
  padding: 10px 12px; background: var(--surface);
  flex-wrap: wrap;
}
.title-input {
  flex: 1; min-width: 120px; padding: 12px 16px;
  background: var(--card); border: 2px solid transparent;
  border-radius: 16px; color: var(--text); font-size: 1rem; font-weight: 600;
}
.title-input:focus { outline: none; border-color: var(--accent); }
.header-btn {
  padding: 12px 20px; border: none; border-radius: 16px;
  font-weight: 700; font-size: 0.85rem; cursor: pointer; transition: 0.2s;
  display: flex; align-items: center; gap: 6px;
}
.header-btn:hover { transform: scale(1.05); }
.btn-demo { background: linear-gradient(135deg, var(--yellow), var(--orange)); color: #000; }
.btn-code { background: linear-gradient(135deg, var(--accent), var(--purple)); color: #000; }
.btn-delete { background: var(--red); color: #fff; }

/* Palette - Bottom on mobile */
.palette {
  display: flex; gap: 8px; padding: 10px;
  background: var(--surface); border-top: 2px solid var(--card);
  overflow-x: auto; order: 2;
}
.palette-item {
  flex-shrink: 0; display: flex; flex-direction: column;
  align-items: center; gap: 6px; padding: 12px 16px;
  background: var(--card); border: 3px solid transparent;
  border-radius: 16px; cursor: pointer; transition: 0.2s;
  min-width: 72px;
}
.palette-item:hover, .palette-item.selected { border-color: var(--accent); transform: scale(1.05); }
.palette-item.selected { background: linear-gradient(135deg, var(--accent), var(--purple)); }
.palette-item.selected .palette-name { color: #000; }
.palette-icon { font-size: 28px; }
.palette-name { font-size: 0.7rem; font-weight: 700; color: var(--text-dim); text-transform: uppercase; }

/* Canvas */
.canvas-wrap { flex: 1; padding: 10px; overflow: hidden; order: 1; display: flex; flex-direction: column; }
.canvas-hint { text-align: center; padding: 8px; color: var(--text-dim); font-size: 0.85rem; }
.canvas-hint span { color: var(--accent); font-weight: 700; }
.canvas {
  flex: 1; position: relative; background: var(--card);
  border: 3px dashed var(--text-dim); border-radius: 20px;
  overflow: auto; min-height: 250px;
}
#widgetsLayer { position: absolute; inset: 0; }

.widget {
  position: absolute; background: var(--surface);
  border: 3px solid var(--text-dim); border-radius: 16px;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  cursor: move; touch-action: none; user-select: none; gap: 4px; padding: 8px;
}
.widget.selected { border-color: var(--accent); box-shadow: 0 0 30px rgba(0,212,255,0.5); }
.widget-icon { font-size: 2rem; pointer-events: none; }
.widget-label { font-size: 0.75rem; font-weight: 700; color: var(--text-dim); pointer-events: none; }
.widget .resize-handle {
  position: absolute; bottom: -2px; right: -2px;
  width: 24px; height: 24px; cursor: se-resize;
  background: var(--accent); border-radius: 0 0 14px 0;
  clip-path: polygon(100% 0, 100% 100%, 0 100%);
}

/* Runtime View */
.runtime-view { align-items: center; justify-content: center; padding: 20px; }
.connect-box { text-align: center; }
.connect-icon { font-size: 6rem; margin-bottom: 20px; animation: bounce 1s infinite; }
@keyframes bounce { 0%,100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
.connect-text { font-size: 1.3rem; font-weight: 700; margin-bottom: 24px; }
.connect-btn {
  padding: 18px 40px; border: none; border-radius: 30px;
  background: linear-gradient(135deg, var(--green), var(--accent));
  color: #000; font-size: 1.2rem; font-weight: 800; cursor: pointer;
}
#runtimeContent { display: none; flex-direction: column; align-items: center; width: 100%; }
#runtimeTitle { font-size: 1.6rem; font-weight: 800; color: var(--accent); margin-bottom: 20px; }
#runtimeGrid { position: relative; background: var(--card); border: 3px solid var(--surface); border-radius: 20px; }

/* Runtime Widgets */
/* Graph (Online) */
.rt-graph-wrap{
  width: 100%; height: 100%;
  display:flex; flex-direction:column; gap:8px;
  padding: 10px;
  border-radius: 16px;
}
.rt-graph-head{ display:flex; justify-content:space-between; font-weight:800; font-size:0.9rem; color: var(--text); }
.rt-graph-sub{ display:flex; gap:8px; flex-wrap:wrap; font-size:0.75rem; color: var(--text-dim); font-weight:800; }
.rt-graph-dot{ width:10px; height:10px; border-radius:999px; display:inline-block; vertical-align:middle; margin-right:6px; }
.rt-graph-canvas{
  width: 100%; flex:1;
  border-radius: 14px;
  background: rgba(0,0,0,0.14);
  border: 2px solid rgba(255,255,255,0.10);
}
.rt-graph-wrap.model-grid{
  background: linear-gradient(135deg, rgba(0,212,255,0.10), rgba(179,136,255,0.10));
}
.rt-graph-wrap.model-dark{
  background: rgba(0,0,0,0.15);
}
.rt-graph-wrap.model-min{
  background: transparent;
  border: 2px solid rgba(255,255,255,0.10);
}

/* Gauge */
.rt-gauge-wrap{
  width:100%; height:100%;
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  gap:8px; padding:10px;
  border-radius: 16px;
}
.rt-gauge-svg{ width: 100%; height: 100%; max-height: 130px; }
.rt-gauge-ticks line{ stroke: rgba(255,255,255,0.22); stroke-width: 2; stroke-linecap: round; }
.rt-gauge-bg{ fill:none; stroke: rgba(255,255,255,0.14); stroke-width: 12; stroke-linecap: round; }
.rt-gauge-fg{ fill:none; stroke: var(--green); stroke-width: 12; stroke-linecap: round;
  stroke-dasharray: 157.1; /* approx half circumference with r=50 */
  stroke-dashoffset: 157.1;
  transition: stroke-dashoffset 0.25s ease, stroke 0.25s ease;
}

.rt-gauge-label{ font-weight:800; color: var(--text-dim); font-size:0.85rem; text-align:center; }
.rt-gauge-value{ font-weight:900; font-size:1.1rem; color: var(--text); text-align:center; }
.rt-gauge-wrap.model-classic{ background: rgba(0,0,0,0.10); border: 2px solid rgba(255,255,255,0.10); }
.rt-gauge-wrap.model-neon{ background: linear-gradient(135deg, rgba(0,212,255,0.12), rgba(255,107,157,0.10)); box-shadow: 0 0 30px rgba(0,212,255,0.12); }
.rt-gauge-wrap.model-min{ background: transparent; border: 2px solid rgba(255,255,255,0.10); }

.rt-widget { position: absolute; padding: 10px; display: flex; align-items: center; justify-content: center; }
.rt-button {
  width: 100%; height: 100%; border: none; border-radius: 16px;
  background: linear-gradient(135deg, #6366f1, var(--purple));
  color: #fff; font-weight: 700; cursor: pointer;
  display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 6px;
  font-size: 1rem; transition: 0.1s;
}
.rt-button:active { transform: scale(0.9); }
.rt-button .icon { font-size: 2rem; }

.rt-slider-wrap { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; gap: 10px; }
.rt-slider-info { display: flex; justify-content: space-between; font-weight: 700; }
.rt-slider { width: 100%; height: 12px; border-radius: 6px; background: var(--surface); -webkit-appearance: none; }
.rt-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 30px; height: 30px; border-radius: 50%; background: linear-gradient(135deg, var(--purple), var(--pink)); cursor: pointer; }

.rt-toggle-wrap { display: flex; flex-direction: column; align-items: center; gap: 10px; }
.rt-toggle { width: 70px; height: 70px; border: none; border-radius: 16px; background: var(--red); color: #fff; font-size: 2rem; cursor: pointer; transition: 0.2s; }
.rt-toggle.on { background: var(--green); }

.rt-led-wrap { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 10px; }
.rt-led { width: 60px; height: 60px; border-radius: 50%; background: rgba(255,82,82,0.2); transition: 0.2s; }
.rt-led.on { background: var(--red); box-shadow: 0 0 40px var(--red); }

.rt-joystick-wrap { display: flex; flex-direction: column; align-items: center; gap: 6px; }
.rt-joystick-base { width: 100px; height: 100px; border-radius: 50%; background: var(--surface); border: 4px solid var(--accent); display: flex; align-items: center; justify-content: center; touch-action: none; }
.rt-joystick-stick { width: 50px; height: 50px; border-radius: 50%; background: linear-gradient(135deg, var(--accent), var(--purple)); pointer-events: none; }

.rt-label-text { font-weight: 700; font-size: 1.2rem; text-align: center; }

/* --- Widget Models (Runtime) --- */
/* Buttons */
.rt-button.model-neo{
  background: linear-gradient(135deg, #6366f1, var(--purple));
  box-shadow: 0 10px 25px rgba(0,0,0,0.25);
}
.rt-button.model-flat{
  background: var(--accent);
  color: #000;
  box-shadow: none;
}
.rt-button.model-glass{
  background: rgba(255,255,255,0.08);
  border: 2px solid rgba(255,255,255,0.18);
  backdrop-filter: blur(10px);
  box-shadow: 0 12px 30px rgba(0,0,0,0.35);
}

/* Sliders */
.rt-slider.model-track{ height: 12px; border-radius: 6px; }
.rt-slider.model-min{ height: 6px; border-radius: 999px; }
.rt-slider.model-neon{
  height: 12px;
  border-radius: 999px;
  box-shadow: 0 0 20px rgba(0,212,255,0.25);
}
.rt-slider.model-neon::-webkit-slider-thumb{
  box-shadow: 0 0 25px rgba(179,136,255,0.7);
}
.rt-slider.model-min::-webkit-slider-thumb{
  width: 26px; height: 26px;
  background: linear-gradient(135deg, var(--accent), var(--pink));
}

/* Toggles */
.rt-toggle.model-square{ border-radius: 16px; }
.rt-toggle.model-pill{
  width: 90px; height: 46px;
  border-radius: 999px;
  display:flex; align-items:center; justify-content:center;
  font-size: 1.4rem;
}
.rt-toggle.model-icon{
  background: var(--card);
  border: 3px solid var(--surface);
  color: var(--text);
}
.rt-toggle.model-icon.on{
  border-color: var(--green);
  box-shadow: 0 0 30px rgba(0,230,118,0.35);
}

/* LEDs */
.rt-led.model-dot{ border-radius: 50%; }
.rt-led.model-bar{
  width: 90%;
  height: 28%;
  min-height: 18px;
  border-radius: 999px;
}
.rt-led.model-ring{
  background: transparent !important;
  border: 6px solid rgba(255,255,255,0.18);
  box-shadow: none !important;
}
.rt-led.model-ring.on{
  background: transparent !important;
}

/* Joysticks */
.rt-joystick-base.model-classic{ border: 4px solid var(--accent); }
.rt-joystick-base.model-neon{
  border: 4px solid var(--accent);
  box-shadow: 0 0 35px rgba(0,212,255,0.35);
}
.rt-joystick-base.model-min{
  border: 3px solid rgba(255,255,255,0.18);
}
.rt-joystick-stick.model-min{
  background: rgba(255,255,255,0.14);
}

/* Labels */
.rt-label-text.model-plain{ }
.rt-label-text.model-card{
  background: rgba(255,255,255,0.06);
  border: 2px solid rgba(255,255,255,0.14);
  border-radius: 16px;
  padding: 10px 14px;
}
.rt-label-text.model-glow{
  text-shadow: 0 0 18px rgba(0,212,255,0.55);
}

/* Props panel helpers */
.props-row{
  display:flex;
  gap:8px;
  align-items:center;
}
.props-apply{
  margin-top: 10px;
  width: 100%;
  padding: 10px 12px;
  border-radius: 14px;
  border: 2px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.06);
  color: var(--text);
  font-weight: 800;
  cursor: pointer;
}
.props-apply:hover{
  border-color: var(--accent);
}


/* Loading Overlay (kid-friendly) */
.loading-overlay{
  position: fixed; inset: 0;
  display: none;
  align-items: center; justify-content: center;
  background: rgba(0,0,0,0.65);
  z-index: 3000;
  padding: 18px;
}
.loading-overlay.show{ display:flex; }
.loading-card{
  width: min(520px, 95vw);
  background: linear-gradient(135deg, rgba(0,212,255,0.14), rgba(255,107,157,0.10));
  border: 2px solid rgba(255,255,255,0.18);
  border-radius: 22px;
  padding: 18px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.45);
  text-align: center;
}
.loading-title{ font-weight: 900; font-size: 1.1rem; }
.loading-sub{ margin-top: 6px; color: var(--text-dim); font-weight: 800; }
.loading-bar{
  margin-top: 14px;
  height: 14px;
  background: rgba(0,0,0,0.22);
  border-radius: 999px;
  overflow: hidden;
  border: 2px solid rgba(255,255,255,0.12);
}
.loading-bar-fill{
  height: 100%;
  width: 0%;
  border-radius: 999px;
  background: linear-gradient(90deg, var(--accent), var(--pink), var(--yellow));
  transition: width 0.18s ease;
}
.loading-pct{ margin-top: 10px; font-weight: 900; color: var(--accent); }

/* Graph: clearer axes & legend */
.rt-graph-head{ align-items: center; }
.rt-graph-head span:first-child{ display:flex; gap:8px; align-items:center; }
.rt-graph-head span:first-child::before{ content:"üìà"; }
.rt-graph-sub{ opacity: 0.92; }
.rt-graph-sub .legend-item{ display:flex; align-items:center; gap:6px; margin-right:10px; }
.rt-graph-dot{ box-shadow: 0 0 18px rgba(255,255,255,0.10); }

/* Gauge: nicer RemoteXY-like arc + ticks */
.rt-gauge-wrap{ position: relative; overflow: hidden; }
.rt-gauge-wrap::before{
  content:"";
  position:absolute; inset:0;
  background: radial-gradient(circle at 50% 40%, rgba(255,255,255,0.10), rgba(0,0,0,0) 60%);
  pointer-events:none;
}
.rt-gauge-svg{ max-height: 130px; }
.rt-gauge-center{ display:flex; flex-direction:column; align-items:center; gap:2px; }
.rt-gauge-value{ font-size: 1.2rem; }
.rt-gauge-emoji{ font-size: 1.05rem; margin-bottom: -2px; }

/* Toast */
.toast { position: fixed; bottom: -100px; left: 50%; transform: translateX(-50%); padding: 16px 32px; background: var(--card); border: 3px solid var(--accent); border-radius: 30px; font-weight: 700; font-size: 1rem; transition: 0.3s; z-index: 1000; }
.toast.show { bottom: 30px; }
.toast.success { border-color: var(--green); color: var(--green); }
.toast.error { border-color: var(--red); color: var(--red); }

/* Modal */
.modal-bg { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 200; align-items: center; justify-content: center; padding: 20px; }
.modal-bg.show { display: flex; }
.modal { background: var(--surface); border: 3px solid var(--accent); border-radius: 24px; padding: 24px; max-width: 600px; width: 100%; max-height: 85vh; overflow-y: auto; }
.modal-title { font-size: 1.4rem; font-weight: 800; color: var(--accent); margin-bottom: 16px; }
.modal-code { background: var(--card); padding: 16px; border-radius: 16px; font-family: 'Fira Code', 'Consolas', monospace; font-size: 0.8rem; max-height: 400px; overflow: auto; color: var(--green); white-space: pre-wrap; word-break: break-all; margin-bottom: 16px; line-height: 1.5; }
.modal-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
.modal-btn { flex: 1; padding: 14px 20px; border: none; border-radius: 16px; font-weight: 700; cursor: pointer; }
.modal-btn.primary { background: linear-gradient(135deg, var(--accent), var(--purple)); color: #000; }
.modal-btn.secondary { background: var(--card); color: var(--text); }

/* Template Modal */
.template-modal { position: fixed; inset: 0; background: rgba(26,26,46,0.98); z-index: 100; display: flex; align-items: center; justify-content: center; padding: 20px; }
.template-modal.hidden { display: none; }
.template-content { text-align: center; max-width: 500px; width: 100%; }
.template-content h2 { font-size: 1.8rem; margin-bottom: 10px; background: linear-gradient(90deg, var(--accent), var(--pink)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.template-content p { color: var(--text-dim); margin-bottom: 24px; font-size: 1rem; }
.templates-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
.template-card { background: var(--card); border: 3px solid transparent; border-radius: 20px; padding: 20px 10px; cursor: pointer; transition: 0.2s; }
.template-card:hover { border-color: var(--accent); transform: scale(1.05); }
.template-card:active { transform: scale(0.95); }
.template-icon { font-size: 3rem; margin-bottom: 10px; }
.template-name { font-weight: 700; font-size: 0.9rem; }

/* Responsive */
@media (min-width: 768px) {
  .builder-view { flex-direction: row; }
  .palette { flex-direction: column; width: 100px; border-top: none; border-right: 2px solid var(--card); order: 0; overflow-y: auto; overflow-x: visible; }
  .canvas-wrap { order: 0; }
  .palette-item { width: 100%; min-width: unset; }
}
@media (max-width: 500px) {
  .logo { font-size: 1rem; }
  .tab { padding: 8px 14px; font-size: 0.8rem; }
  .ble-btn span:last-child { display: none; }
  .templates-grid { grid-template-columns: repeat(2, 1fr); }
  .template-icon { font-size: 2.2rem; }
  .header-btn { padding: 10px 14px; font-size: 0.75rem; }
}

/* Properties Panel */
.props-panel{
  background: var(--surface);
  border-left: 2px solid var(--card);
  padding: 12px;
  width: 260px;
  min-width: 240px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.props-title{ font-weight: 800; color: var(--accent); }
.props-empty{ color: var(--text-dim); font-weight: 600; font-size: 0.9rem; }

.props-form label{
  display:block;
  margin-top: 10px;
  font-size: 0.8rem;
  color: var(--text-dim);
  font-weight: 800;
  text-transform: uppercase;
}
.props-form input, .props-form select{
  width: 100%;
  margin-top: 6px;
  padding: 10px 12px;
  border-radius: 14px;
  border: 2px solid transparent;
  background: var(--card);
  color: var(--text);
  font-weight: 700;
}
.props-form input:focus, .props-form select:focus{
  outline: none;
  border-color: var(--accent);
}

@media (max-width: 768px){
  .props-panel{
    width: 100%;
    border-left: none;
    border-top: 2px solid var(--card);
  }
}

</style>
</head>
<body>
<div class="app">
  <header>
    <div class="logo">üéÆ <span>micro:bit</span></div>
    <div class="spacer"></div>
    <div class="tabs">
      <button class="tab active" data-tab="builder">‚úèÔ∏è Build</button>
      <button class="tab" data-tab="runtime">‚ñ∂Ô∏è Play</button>
    </div>
    <button id="soundBtn" class="ble-btn" style="border-color: var(--accent); color: var(--accent);" title="Sound">
      <span class="ble-dot" style="background: currentColor;"></span>
      <span>Sound</span>
    </button>
    <button id="bleBtn" class="ble-btn">
      <span class="ble-dot"></span>
      <span>Connect</span>
    </button>
  </header>

  <div id="templateModal" class="template-modal">
    <div class="template-content">
      <h2>üé® Choose a Template!</h2>
      <p>Pick one to start building your remote</p>
      <div class="templates-grid">
        <div class="template-card" data-tpl="gamepad"><div class="template-icon">üéÆ</div><div class="template-name">Game Pad</div></div>
        <div class="template-card" data-tpl="robot"><div class="template-icon">ü§ñ</div><div class="template-name">Robot</div></div>
        <div class="template-card" data-tpl="mixer"><div class="template-icon">üéµ</div><div class="template-name">DJ Mixer</div></div>
        <div class="template-card" data-tpl="racing"><div class="template-icon">üèéÔ∏è</div><div class="template-name">Race Car</div></div>
        <div class="template-card" data-tpl="lights"><div class="template-icon">üí°</div><div class="template-name">Lights</div></div>
        <div class="template-card" data-tpl="blank"><div class="template-icon">‚ú®</div><div class="template-name">Start Fresh</div></div>
      </div>
    </div>
  </div>

  <main>
    <div class="view builder-view active">
      <div class="builder-header">
        <input type="text" id="titleInput" class="title-input" placeholder="üè∑Ô∏è Name your remote..." maxlength="25">
        <button class="header-btn btn-demo" id="demoBtn">üéÆ Try All Widgets!</button>
        <button class="header-btn btn-template" id="templateBtn">üé® Templates</button>
        <button class="header-btn btn-code" id="codeBtn">üìÑ Code</button>
        <button class="header-btn btn-delete" id="deleteBtn">üóëÔ∏è</button>
      </div>
      <div class="canvas-wrap">
        <div class="canvas-hint">üëÜ Tap a widget below, then <span>tap here</span> to place it!</div>
        <div id="canvas" class="canvas"><div id="widgetsLayer"></div></div>
      </div>

      <div id="propsPanel" class="props-panel">
        <div class="props-title">üõ†Ô∏è Widget Properties</div>
        <div id="propsEmpty" class="props-empty">Select a widget to edit it.</div>
        <div id="propsForm" class="props-form" style="display:none;"></div>
      </div>

      <div class="palette">
        <div class="palette-item" data-type="button"><div class="palette-icon">üëÜ</div><div class="palette-name">Button</div></div>
        <div class="palette-item" data-type="slider"><div class="palette-icon">üéöÔ∏è</div><div class="palette-name">Slider</div></div>
        <div class="palette-item" data-type="toggle"><div class="palette-icon">üîò</div><div class="palette-name">Switch</div></div>
        <div class="palette-item" data-type="joystick"><div class="palette-icon">üïπÔ∏è</div><div class="palette-name">Joystick</div></div>
        <div class="palette-item" data-type="led"><div class="palette-icon">üí°</div><div class="palette-name">Light</div></div>
        <div class="palette-item" data-type="label"><div class="palette-icon">üè∑Ô∏è</div><div class="palette-name">Label</div></div>
        <div class="palette-item" data-type="gauge"><div class="palette-icon">üß≠</div><div class="palette-name">Gauge</div></div>
        <div class="palette-item" data-type="graph"><div class="palette-icon">üìà</div><div class="palette-name">Graph</div></div>
      </div>
    </div>

    <div class="view runtime-view">
      <div id="connectPrompt" class="connect-box">
        <div class="connect-icon">üì°</div>
        <div class="connect-text">Connect your micro:bit!</div>
        <button id="connectBtn" class="connect-btn">üîó Connect</button>
      </div>
      <div id="runtimeContent"><div id="runtimeTitle"></div><div id="runtimeGrid"></div></div>
    </div>
  </main>
</div>

<div id="toast" class="toast"></div>

<div id="loadingOverlay" class="loading-overlay" aria-hidden="true">
  <div class="loading-card">
    <div class="loading-title">üß© Loading your remote...</div>
    <div class="loading-sub" id="loadingSub">Getting layout from micro:bit</div>
    <div class="loading-bar">
      <div class="loading-bar-fill" id="loadingBarFill"></div>
    </div>
    <div class="loading-pct" id="loadingPct">0%</div>
  </div>
</div>

<div id="modalBg" class="modal-bg">
  <div class="modal">
    <div id="modalTitle" class="modal-title"></div>
    <pre id="modalCode" class="modal-code"></pre>
    <div class="modal-buttons">
      <button class="modal-btn primary" id="copyBtn">üìã Copy</button>
      <button class="modal-btn primary" id="downloadBtn">üíæ Save</button>
      <button class="modal-btn secondary" id="modalClose">‚úñÔ∏è Close</button>
    </div>
  </div>
</div>
<input type="file" id="fileInput" accept=".json" hidden>

<script>
window.__ovl = window.__ovl || { t:null };

const UART_SERVICE = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const UART_TX_CHAR = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
const UART_RX_CHAR = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

const encoder = new TextEncoder();
const esc = s => { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; };
const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);

const ICONS = { button:'üëÜ', slider:'üéöÔ∏è', toggle:'üîò', joystick:'üïπÔ∏è', led:'üí°', label:'üè∑Ô∏è', graph:'üìà', gauge:'üß≠' };
const SIZES = { button:[90,90], slider:[90,160], toggle:[90,90], joystick:[120,120], led:[90,90], label:[120,60], graph:[240,140], gauge:[150,150] };

const templates = {
  gamepad: [
    { t:'joystick', x:20, y:30, w:120, h:120, label:'Move' },
    { t:'button', x:180, y:40, w:90, h:90, label:'Jump' },
    { t:'button', x:290, y:40, w:90, h:90, label:'Fire' },
    { t:'toggle', x:180, y:160, w:90, h:90, label:'Turbo' }
  ],
  robot: [
    { t:'slider', x:20, y:20, w:90, h:180, label:'Arm 1' },
    { t:'slider', x:130, y:20, w:90, h:180, label:'Arm 2' },
    { t:'slider', x:240, y:20, w:90, h:180, label:'Arm 3' },
    { t:'toggle', x:350, y:80, w:90, h:90, label:'Grip' }
  ],
  mixer: [
    { t:'slider', x:20, y:20, w:80, h:200, label:'Bass' },
    { t:'slider', x:120, y:20, w:80, h:200, label:'Mid' },
    { t:'slider', x:220, y:20, w:80, h:200, label:'High' },
    { t:'toggle', x:320, y:80, w:90, h:90, label:'FX' },
    { t:'led', x:320, y:20, w:90, h:50, label:'Beat' }
  ],
  racing: [
    { t:'joystick', x:150, y:20, w:130, h:130, label:'Steer' },
    { t:'slider', x:20, y:170, w:80, h:140, label:'Gas' },
    { t:'slider', x:330, y:170, w:80, h:140, label:'Brake' },
    { t:'button', x:150, y:180, w:130, h:80, label:'Nitro!' }
  ],
  lights: [
    { t:'toggle', x:30, y:30, w:100, h:100, label:'Red' },
    { t:'toggle', x:160, y:30, w:100, h:100, label:'Green' },
    { t:'toggle', x:290, y:30, w:100, h:100, label:'Blue' },
    { t:'led', x:90, y:160, w:100, h:100, label:'Status' },
    { t:'led', x:230, y:160, w:100, h:100, label:'Alert' }
  ],
  blank: []
};

const state = {
  widgets: [], selected: null, nextId: 1, selectedType: null,
  ble: { device:null, server:null, service:null, notifyChar:null, writeChar:null, connected:false },
  config: null, values: {}, rxBuffer: '',
  justDragged: false, _dragT: null
};
state._allowLoadingOverlay = false;


// ---- Kid-friendly sound engine (WebAudio) ----
state.soundOn = true;
state._audio = { ctx: null, unlocked: false };
state._gaugeLast = state._gaugeLast || {};

function ensureAudio() {
  if (!state.soundOn) return null;
  if (state._audio.ctx) return state._audio.ctx;
  try {
    const Ctx = window.AudioContext || window.webkitAudioContext;
    state._audio.ctx = new Ctx();
    return state._audio.ctx;
  } catch (e) { return null; }
}

function unlockAudioOnce() {
  const ctx = ensureAudio();
  if (!ctx) return;
  if (ctx.state === 'suspended') ctx.resume().catch(()=>{});
  state._audio.unlocked = true;
}

document.addEventListener('pointerdown', () => unlockAudioOnce(), { once: true });

function beep(freq=880, dur=0.06, vol=0.05, type='sine') {
  if (!state.soundOn) return;
  const ctx = ensureAudio();
  if (!ctx) return;
  if (ctx.state === 'suspended') ctx.resume().catch(()=>{});
  const o = ctx.createOscillator();
  const g = ctx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g); g.connect(ctx.destination);
  const t = ctx.currentTime;
  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(vol, t + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
  o.start(t);
  o.stop(t + dur + 0.02);
}
// Sound patterns
function beepClick(){ beep(880, 0.05, 0.05, 'sine'); }
function beepToggle(on){ beep(on?1046:659, 0.06, 0.05, 'square'); }
function beepWarn(){ beep(523, 0.09, 0.06, 'triangle'); setTimeout(()=>beep(659,0.09,0.05,'triangle'), 110); }
function beepDanger(){ beep(330, 0.10, 0.07, 'sawtooth'); setTimeout(()=>beep(330,0.10,0.07,'sawtooth'), 130); }

// Sound UI
function updateSoundUI(){
  const b = $('#soundBtn');
  if (!b) return;
  b.classList.toggle('connected', state.soundOn);
  b.querySelector('span:last-child').textContent = state.soundOn ? 'Sound On' : 'Sound Off';
  b.style.opacity = state.soundOn ? '1' : '0.7';
}



// Ensure older configs/templates still look good when new properties are added
function applyWidgetDefaults(w){
  if (!w || !w.t) return w;

  // Default models (3 per widget type)
  if (!w.model){
    if (w.t === 'button') w.model = 'neo';
    if (w.t === 'slider') w.model = 'track';
    if (w.t === 'toggle') w.model = 'square';
    if (w.t === 'led') w.model = 'dot';
    if (w.t === 'joystick') w.model = 'classic';
    if (w.t === 'label') w.model = 'plain';
    if (w.t === 'gauge') w.model = 'classic';
    if (w.t === 'graph') w.model = 'grid';
  }

  // Existing per-type defaults
  if (w.t === 'led'){
    if (!w.colorOn) w.colorOn = '#ff5252';
    if (!w.colorOff) w.colorOff = '#2a2a3a';
  }
  if (w.t === 'slider'){
    if (w.min == null) w.min = 0;
    if (w.max == null) w.max = 100;
    if (w.step == null) w.step = 1;
  }

  // Gauge defaults
  if (w.t === 'gauge'){
    if (w.min == null) w.min = 0;
    if (w.max == null) w.max = 100;
    if (w.decimals == null) w.decimals = 1;
    if (w.units == null) w.units = '';
    if (w.warn == null) w.warn = null;   // optional threshold
    if (w.danger == null) w.danger = null;
  }

  // Graph defaults (comma-separated multi-series values: "23.4,2.1")
  if (w.t === 'graph'){
    if (w.series == null) w.series = 1;      // 1..10
    if (w.windowSec == null) w.windowSec = 30; // visible time window
    if (w.autoScale == null) w.autoScale = true;
    if (w.min == null) w.min = 0;
    if (w.max == null) w.max = 100;
    if (w.showLegend == null) w.showLegend = true;
  }

  return w;
}

function modelOptionsForType(t){
  switch(t){
    case 'button': return [
      { v:'neo',   name:'Neo (gradient)' },
      { v:'flat',  name:'Flat' },
      { v:'glass', name:'Glass' }
    ];
    case 'slider': return [
      { v:'track', name:'Track' },
      { v:'neon',  name:'Neon' },
      { v:'min',   name:'Minimal' }
    ];
    case 'toggle': return [
      { v:'square', name:'Square' },
      { v:'pill',   name:'Pill' },
      { v:'icon',   name:'Icon' }
    ];
    case 'led': return [
      { v:'dot',  name:'Dot' },
      { v:'bar',  name:'Bar' },
      { v:'ring', name:'Ring' }
    ];
    case 'joystick': return [
      { v:'classic', name:'Classic' },
      { v:'neon',    name:'Neon' },
      { v:'min',     name:'Minimal' }
    ];
    case 'label': return [
      { v:'plain', name:'Plain' },
      { v:'card',  name:'Card' },
      { v:'glow',  name:'Glow' }
    ];
    case 'gauge': return [
      { v:'classic', name:'Classic' },
      { v:'neon',    name:'Neon' },
      { v:'min',     name:'Minimal' }
    ];
    case 'graph': return [
      { v:'grid',    name:'Grid' },
      { v:'dark',    name:'Dark' },
      { v:'min',     name:'Minimal' }
    ];
    default: return null;
  }
}

// BLE send with verbose debug logging
async function send(msg) {
  console.log('[BLE] Attempting to send:', msg);
  
  if (!state.ble.writeChar) {
    console.log('[BLE] ERROR: No writeChar available');
    return;
  }
  
  // Check if still connected
  const gattConnected = state.ble.device?.gatt?.connected;
  console.log('[BLE] GATT connected:', gattConnected);
  
  if (!gattConnected) {
    console.log('[BLE] ERROR: GATT disconnected, triggering onDisconnect');
    onDisconnect();
    return;
  }
  
  try {
    console.log('[BLE] Writing value...');
    await state.ble.writeChar.writeValue(encoder.encode(msg + '\n'));
    console.log('[BLE] Write SUCCESS');
  } catch (err) { 
    console.error('[BLE] Write FAILED:', err.name, err.message);
    // If write fails with certain errors, assume disconnected
    if (err.message?.includes('GATT') || err.message?.includes('disconnected')) {
      console.log('[BLE] Triggering disconnect due to GATT error');
      onDisconnect();
    }
  }
}

// One-click Demo - creates full showcase with all widgets
function showDemo() {
  // Create a demo with ALL widget types
  state.widgets = [
    { id: 'btn_jump', t: 'button', x: 20, y: 20, w: 100, h: 100, label: 'Jump!', model:'neo' },
    { id: 'btn_fire', t: 'button', x: 140, y: 20, w: 100, h: 100, label: 'Fire!', model:'glass' },
    { id: 'slider_speed', t: 'slider', x: 260, y: 20, w: 90, h: 180, label: 'Speed', model:'track', min:0, max:100, step:1 },
    { id: 'slider_power', t: 'slider', x: 370, y: 20, w: 90, h: 180, label: 'Power', model:'neon', min:0, max:100, step:1 },
    { id: 'toggle_turbo', t: 'toggle', x: 20, y: 140, w: 100, h: 100, label: 'Turbo', model:'pill' },
    { id: 'toggle_shield', t: 'toggle', x: 140, y: 140, w: 100, h: 100, label: 'Shield', model:'icon' },
    { id: 'joy_move', t: 'joystick', x: 20, y: 260, w: 140, h: 140, label: 'Move', model:'ring' },
    { id: 'led_status', t: 'led', x: 180, y: 260, w: 100, h: 100, label: 'Status', model:'dot', colorOn:'#00e676', colorOff:'#1b2a3a' },
    { id: 'led_alert', t: 'led', x: 300, y: 260, w: 100, h: 100, label: 'Alert', model:'ring', colorOn:'#ff5252', colorOff:'#1b2a3a' },
    { id: 'label_score', t: 'label', x: 180, y: 380, w: 220, h: 50, label: 'Score: 0', model:'chip' },

    { id: 'gauge_temp', t: 'gauge', x: 20, y: 430, w: 150, h: 170, label: 'Temp', min: 0, max: 50, units: '¬∞C', decimals: 1, model:'classic' },
    { id: 'gauge_level', t: 'gauge', x: 190, y: 430, w: 150, h: 170, label: 'Level', min: 0, max: 100, units: '%', decimals: 0, model:'neon' },
    { id: 'graph_env', t: 'graph', x: 20, y: 610, w: 370, h: 170, label: 'Online Graph', series: 2, windowSec: 30, autoScale: true, model:'grid' }
  ];
  state.widgets = state.widgets.map(applyWidgetDefaults);
  state.nextId = 20;
  state.selected = null;
  $('#titleInput').value = 'Super Demo Remote';
  renderWidgets();
  renderPropsPanel();
  
  // Show the code modal with demo code
  const cfg = { title: 'Super Demo Remote', widgets: state.widgets };
  // Load demo into runtime immediately (no micro:bit required)
  state.config = cfg;
  state.values = state.values || {};
  renderRuntime();
  startDemoSim();
  $('#modalTitle').textContent = 'Demo Ready! Copy this code to MakeCode:';
  $('#modalCode').textContent = generateDemoCode(cfg);
  $('#modalBg').classList.add('show');
  
  toast('Demo loaded with ALL widgets!', 'success');
}

function generateDemoCode(cfg) {
  // Unicode-safe base64 encoding (handles emojis!)
  const b64 = btoa(unescape(encodeURIComponent(JSON.stringify(cfg))));
  
  // Group widgets by type
  const buttons = cfg.widgets.filter(w => w.t === 'button');
  const sliders = cfg.widgets.filter(w => w.t === 'slider');
  const toggles = cfg.widgets.filter(w => w.t === 'toggle');
  const joysticks = cfg.widgets.filter(w => w.t === 'joystick');
  const leds = cfg.widgets.filter(w => w.t === 'led');
  const labels = cfg.widgets.filter(w => w.t === 'label');
  const gauges = cfg.widgets.filter(w => w.t === 'gauge');
  const graphs = cfg.widgets.filter(w => w.t === 'graph');
  
  // Generate handler code for each widget
  let buttonCode = buttons.map(w => `    // Button: ${w.label || w.id}
    if (id == "${w.id}" && val == "1") {
        basic.showIcon(IconNames.Heart)
        // Add your code here!
    }`).join('\n');
  
  let sliderCode = sliders.map(w => `    // Slider: ${w.label || w.id} (val = 0-100)
    if (id == "${w.id}") {
        let value = parseInt(val)
        led.plotBarGraph(value, 100)
        // Use value for motors, sounds, etc!
    }`).join('\n');
  
  let toggleCode = toggles.map(w => `    // Toggle: ${w.label || w.id} (val = "1" or "0")
    if (id == "${w.id}") {
        if (val == "1") {
            basic.showIcon(IconNames.Yes)
        } else {
            basic.showIcon(IconNames.No)
        }
    }`).join('\n');
  
  let joystickCode = joysticks.map(w => `    // Joystick: ${w.label || w.id} (val = "angle distance")
    if (id == "${w.id}") {
        let parts = val.split(" ")
        let angle = parseInt(parts[0])  // -180 to 180
        let dist = parseInt(parts[1])   // 0 to ~50
        // Use for steering, movement, etc!
        if (dist > 10) {
            basic.showArrow(angle > 0 ? ArrowNames.East : ArrowNames.West)
        } else {
            basic.showLeds(\`
                . . . . .
                . . # . .
                . # # # .
                . . # . .
                . . . . .
            \`)
        }
    }`).join('\n');

  let ledList = leds.map(w => `//   sendValue("${w.id}", "1")  // Turn ON ${w.label || 'LED'}
//   sendValue("${w.id}", "0")  // Turn OFF`).join('\n');

  let labelList = labels.map(w => `//   sendValue("${w.id}", "Hello!")  // Update ${w.label || 'label'}`).join('\n');

  return `// ${cfg.title} - micro:bit Remote
// Copy this to MakeCode: https://makecode.microbit.org
// Then flash it to your micro:bit!

bluetooth.startUartService()
let cfgSent = false
let blinkState = false
const CFG = "${b64}"

// This sends the remote layout to the app
bluetooth.onUartDataReceived(serial.delimiters(Delimiters.NewLine), function() {
    let cmd = bluetooth.uartReadUntil(serial.delimiters(Delimiters.NewLine))
    
    if (cmd == "GETCFG") {
        bluetooth.uartWriteLine("CFGBEGIN")
        for (let i = 0; i < CFG.length; i += 18) {
            bluetooth.uartWriteLine("CFG " + CFG.substr(i, 18))
        }
        bluetooth.uartWriteLine("CFGEND")
        cfgSent = true
        basic.showIcon(IconNames.Yes)
    } 
    else if (cmd.indexOf("SET ") == 0) {
        let parts = cmd.substr(4).split(" ")
        let id = parts[0]
        let val = parts.slice(1).join(" ")
        handleWidget(id, val)
    }
})

// HANDLE YOUR WIDGETS HERE!
function handleWidget(id: string, val: string) {
    serial.writeLine(id + " = " + val)
    
${buttonCode || '    // No buttons in this remote'}

${sliderCode || '    // No sliders in this remote'}

${toggleCode || '    // No toggles in this remote'}

${joystickCode || '    // No joysticks in this remote'}
}

// Send values TO the app (for LEDs and Labels)
function sendValue(id: string, val: string) {
    if (cfgSent) bluetooth.uartWriteLine("UPD " + id + " " + val)
}

// Show we are ready!
basic.showIcon(IconNames.Heart)

// BLINK THE APP LEDs! This runs forever in background
basic.forever(function() {
    if (cfgSent) {
        blinkState = !blinkState
        ${leds.length > 0 ? leds.map(l => `sendValue("${l.id}", blinkState ? "1" : "0")`).join('\n        ') : '// No LEDs to blink'}
        ${labels.length > 0 ? `sendValue("${labels[0].id}", blinkState ? "ON!" : "OFF")` : ''}
        // Demo updates for Gauges (single value) and Graphs (comma-separated)
        let t = input.runningTime()
        ${gauges.length > 0 ? gauges.map((g,i)=>`sendValue("${g.id}", "" + (Math.round((Math.sin((t/1000)+${i}) + 1) * 25)))`).join("\n        ") : "// No gauges to update"}
        ${graphs.length > 0 ? graphs.map((g,i)=>`sendValue("${g.id}", "" + (Math.round((Math.sin((t/900)+${i}) + 1) * 50)) + "," + (Math.round((Math.cos((t/1100)+${i}) + 1) * 50)))`).join("\n        ") : "// No graphs to update"}
    }
    basic.pause(200)
})

// BONUS: Use micro:bit buttons too!
input.onButtonPressed(Button.A, function() {
    basic.showString("A")
    ${leds.length > 0 ? `sendValue("${leds[0].id}", "1")` : '// Add an LED to control it here!'}
})
input.onButtonPressed(Button.B, function() {
    basic.showString("B")
    ${leds.length > 0 ? `sendValue("${leds[0].id}", "0")` : '// Add an LED to control it here!'}
})`;
}

function init() {
  state._allowLoadingOverlay = false;
  if (typeof hideLoading === 'function') hideLoading();
  // Tabs
  $$('.tab').forEach(t => t.onclick = () => switchTab(t.dataset.tab));
  
  // Templates
  $$('.template-card').forEach(c => c.onclick = () => selectTemplate(c.dataset.tpl));
  
  // Palette - tap to select
  $$('.palette-item').forEach(p => {
    p.onclick = () => {
      $$('.palette-item').forEach(x => x.classList.remove('selected'));
      p.classList.add('selected');
      state.selectedType = p.dataset.type;
      toast(`‚úÖ ${ICONS[state.selectedType]} selected! Tap canvas to place`, 'success');
    };
  });
  
  // Canvas - tap to place
  $('#canvas').onclick = e => {
    if (e.target.closest('.widget')) return;
    if (state.selectedType) {
      const rect = $('#canvas').getBoundingClientRect();
      const [w, h] = SIZES[state.selectedType];
      const x = Math.max(0, Math.min(e.clientX - rect.left - w/2, rect.width - w));
      const y = Math.max(0, Math.min(e.clientY - rect.top - h/2, rect.height - h));
      const base = applyWidgetDefaults({ id: `${state.selectedType}${state.nextId++}`, t: state.selectedType, x, y, w, h, label: '' });
      state.widgets.push(base);
      renderWidgets();
      toast(`‚ú® ${ICONS[state.selectedType]} added!`, 'success');
    } else {
      state.selected = null;
      renderWidgets();
      renderPropsPanel();
    }
  };
  
  // Buttons
  $('#soundBtn').onclick = () => { state.soundOn = !state.soundOn; updateSoundUI(); if (state.soundOn) beepClick(); };
  updateSoundUI();
  $('#bleBtn').onclick = connectBle;
  $('#connectBtn').onclick = connectBle;
  $('#demoBtn').onclick = showDemo;
  $('#templateBtn').onclick = () => $('#templateModal').classList.remove('hidden');
  var _ov=$('#loadingOverlay');
  if (_ov) _ov.onclick = () => { state._allowLoadingOverlay=false; hideLoading(); };
  if (typeof hideLoadOverlay==='function') hideLoadOverlay();
  $('#codeBtn').onclick = showCode;
  $('#deleteBtn').onclick = deleteSelected;
  $('#modalClose').onclick = () => $('#modalBg').classList.remove('show');
  $('#modalBg').onclick = e => { if (e.target === $('#modalBg')) $('#modalBg').classList.remove('show'); };
  $('#copyBtn').onclick = () => { navigator.clipboard.writeText($('#modalCode').textContent); toast('üìã Copied!', 'success'); };
  $('#downloadBtn').onclick = downloadCode;
  
  $('#templateModal').classList.remove('hidden');
  var _ov=$('#loadingOverlay');
  if (_ov) _ov.onclick = () => { state._allowLoadingOverlay=false; hideLoading(); };
  if (typeof hideLoadOverlay==='function') hideLoadOverlay();
}

function selectTemplate(name) {
  const t = templates[name];
  if (!t) return;

  // Kids-friendly loading overlay while building a template
  if (typeof showLoadOverlay === 'function') {
    const titles = {
      gamepad: 'üéÆ Building Game Pad...',
      robot: 'ü§ñ Building Robot Remote...',
      mixer: 'üéµ Building DJ Mixer...',
      racing: 'üèéÔ∏è Building Race Car...',
      lights: 'üí° Building Lights Panel...',
      blank: '‚ú® Preparing Blank Canvas...'
    };
    showBuildOverlay(titles[name] || '‚ú® Building...');
  }

  // Small delay so the overlay is visible and feels animated
  setTimeout(() => {
    state.widgets = t.map((w, i) => ({ id: `${w.t}${state.nextId + i}`, ...w }));
    state.nextId += t.length || 1;

    // Apply defaults for new widget types / models
    if (typeof applyWidgetDefaults === 'function') {
      state.widgets.forEach(applyWidgetDefaults);
    }

    state.selected = null;
    $('#templateModal').classList.add('hidden');
    renderWidgets();
    renderPropsPanel();

    if (typeof showLoadOverlay === 'function') showBuildOverlay(titles[name] || '‚ú® Building...');
    if (typeof hideLoadOverlay === 'function') hideLoadOverlay();

    if (name === 'blank') toast('‚ú® Canvas ready! Pick a widget below', 'success');
    else toast('‚úÖ Template loaded!', 'success');
  }, 250);
}

function switchTab(tab) {
  $$('.tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
  $$('.view').forEach(v => v.classList.remove('active'));
  $(`.${tab === 'builder' ? 'builder-view' : 'runtime-view'}`).classList.add('active');
  if (tab === 'runtime') startDemoSim(); else stopDemoSim();
}

function renderWidgets() {
  const layer = $('#widgetsLayer');
  layer.innerHTML = '';
  state.widgets.forEach(w => {
    const el = document.createElement('div');
    el.className = 'widget' + (state.selected === w.id ? ' selected' : '');
    el.dataset.id = w.id;
    el.style.cssText = `left:${w.x}px;top:${w.y}px;width:${w.w}px;height:${w.h}px`;
    el.innerHTML = `<div class="widget-icon">${ICONS[w.t]}</div><div class="widget-label">${esc(w.label) || w.t}</div><div class="resize-handle"></div>`;
    layer.appendChild(el);
    
    interact(el).draggable({
      inertia: true,
      modifiers: [interact.modifiers.restrictRect({ restriction: 'parent' })],
      listeners: {
        start() { state.selected = w.id; updateSelectionUI(); },
        move(e) {
          state.justDragged = true;
          clearTimeout(state._dragT);
          state._dragT = setTimeout(() => state.justDragged = false, 50);
          w.x += e.dx; w.y += e.dy;
          e.target.style.left = w.x + 'px';
          e.target.style.top = w.y + 'px';
        }
      }
    }).resizable({
      edges: { right: true, bottom: true },
      modifiers: [interact.modifiers.restrictSize({ min: { width: 60, height: 60 } })],
      listeners: {
        move(e) {
          w.w = e.rect.width; w.h = e.rect.height;
          e.target.style.width = w.w + 'px';
          e.target.style.height = w.h + 'px';
        }
      }
    });
    
    el.onclick = e => { e.stopPropagation(); state.selected = w.id; updateSelectionUI(); };
  });
}


function updateSelectionUI() {
  $$('.widget').forEach(el => el.classList.toggle('selected', el.dataset.id === state.selected));
  renderPropsPanel();
}

function getSelectedWidget(){
  return state.widgets.find(w => w.id === state.selected);
}

function renderPropsPanel(){
  const form = $('#propsForm');
  const empty = $('#propsEmpty');
  const w = getSelectedWidget();

  if (!form || !empty) return;

  if (!w){
    empty.style.display = 'block';
    form.style.display = 'none';
    form.innerHTML = '';
    return;
  }

  empty.style.display = 'none';
  form.style.display = 'block';

  // Common fields
  let html = `
    <label>Widget ID</label>
    <input id="prop_id" value="${esc(w.id)}" />

    <label>Label</label>
    <input id="prop_label" value="${esc(w.label || '')}" />
  `;

  // Model selector (3 presets per widget type)
  const opts = modelOptionsForType(w.t);
  if (opts){
    html += `
      <label>Model</label>
      <select id="prop_model">
        ${opts.map(o => `<option value="${o.v}" ${w.model === o.v ? 'selected' : ''}>${o.name}</option>`).join('')}
      </select>
      <button class="props-apply" id="prop_applyAll">Apply this model to ALL ${w.t}s</button>
    `;
  }

  // Type-specific fields
  if (w.t === 'led'){
    html += `
      <label>LED On Color</label>
      <input id="prop_colorOn" type="color" value="${w.colorOn || '#ff5252'}" />

      <label>LED Off Color</label>
      <input id="prop_colorOff" type="color" value="${w.colorOff || '#2a2a3a'}" />
    `;
  }

  if (w.t === 'slider'){
    html += `
      <label>Min</label>
      <input id="prop_min" type="number" value="${w.min ?? 0}" />

      <label>Max</label>
      <input id="prop_max" type="number" value="${w.max ?? 100}" />

      <label>Step</label>
      <input id="prop_step" type="number" value="${w.step ?? 1}" />
    `;
  }

  
  if (w.t === 'gauge'){
    html += `
      <label>Min</label>
      <input id="prop_gmin" type="number" value="${w.min ?? 0}" />

      <label>Max</label>
      <input id="prop_gmax" type="number" value="${w.max ?? 100}" />

      <label>Decimals</label>
      <input id="prop_gdec" type="number" value="${w.decimals ?? 0}" />

      <label>Units (optional)</label>
      <input id="prop_gunits" value="${esc(w.units || '')}" />

      <label>Warn (optional)</label>
      <input id="prop_gwarn" type="number" value="${w.warn ?? ''}" />

      <label>Danger (optional)</label>
      <input id="prop_gdanger" type="number" value="${w.danger ?? ''}" />
    `;
  }

  if (w.t === 'graph'){
    html += `
      <label>Series (1-10)</label>
      <input id="prop_series" type="number" min="1" max="10" value="${w.series ?? 1}" />

      <label>Window (seconds)</label>
      <input id="prop_window" type="number" min="5" max="120" value="${w.windowSec ?? 30}" />

      <label>Auto scale</label>
      <select id="prop_autoscale">
        <option value="1" ${w.autoScale !== false ? 'selected' : ''}>Yes</option>
        <option value="0" ${w.autoScale === false ? 'selected' : ''}>No</option>
      </select>

      <label>Fixed Min (when auto off)</label>
      <input id="prop_ymin" type="number" value="${w.yMin ?? 0}" />

      <label>Fixed Max (when auto off)</label>
      <input id="prop_ymax" type="number" value="${w.yMax ?? 100}" />

      <label>Series Names (comma separated)</label>
      <input id="prop_names" value="${esc((w.seriesNames || '').toString())}" placeholder="Temp,Level,Power" />

      <label>Y Axis Label (optional)</label>
      <input id="prop_ylabel" value="${esc(w.yLabel || '')}" placeholder="¬∞C / % / rpm" />
    `;
  }

form.innerHTML = html;

  // Wire events
  $('#prop_label').oninput = e => {
    w.label = e.target.value;
    const el = $(`.widget[data-id="${w.id}"] .widget-label`);
    if (el) el.textContent = w.label || w.t;
  };

  $('#prop_id').onchange = e => {
    const newId = e.target.value.trim();
    if (!newId || state.widgets.some(x => x.id === newId && x !== w)){
      toast('‚ùå ID must be unique', 'error');
      e.target.value = w.id;
      return;
    }
    const oldId = w.id;
    w.id = newId;

    const root = $(`.widget[data-id="${oldId}"]`);
    if (root) root.dataset.id = newId;

    if (state.values[oldId] != null){
      state.values[newId] = state.values[oldId];
      delete state.values[oldId];
    }

    state.selected = newId;
    updateSelectionUI();
    toast('‚úÖ ID updated', 'success');
  };

  // Model wiring (and quick apply to all widgets of same type)
  const modelSel = $('#prop_model');
  if (modelSel){
    modelSel.onchange = e => { w.model = e.target.value; toast('‚úÖ Model updated', 'success'); };
  }
  const applyBtn = $('#prop_applyAll');
  if (applyBtn){
    applyBtn.onclick = () => {
      const val = w.model;
      state.widgets.forEach(x => { if (x.t === w.t) x.model = val; });
      if (state.config?.widgets) state.config.widgets.forEach(x => { if (x.t === w.t) x.model = val; });
      renderWidgets();
      if (state.config) renderRuntime();
      toast(`‚ú® Applied model to all ${w.t}s`, 'success');
    };
  }


  if (w.t === 'led'){
    $('#prop_colorOn').oninput = e => { w.colorOn = e.target.value; };
    $('#prop_colorOff').oninput = e => { w.colorOff = e.target.value; };
  }

  if (w.t === 'slider'){
    $('#prop_min').oninput = e => { w.min = parseFloat(e.target.value); };
    $('#prop_max').oninput = e => { w.max = parseFloat(e.target.value); };
    $('#prop_step').oninput = e => { w.step = parseFloat(e.target.value); };
  }

  if (w.t === 'gauge'){
    $('#prop_gmin').oninput = e => { w.min = parseFloat(e.target.value); if (state.config) renderRuntime(); };
    $('#prop_gmax').oninput = e => { w.max = parseFloat(e.target.value); if (state.config) renderRuntime(); };
    $('#prop_gdec').oninput = e => { w.decimals = parseInt(e.target.value, 10); if (state.config) renderRuntime(); };
    $('#prop_gunits').oninput = e => { w.units = e.target.value; if (state.config) renderRuntime(); };
    $('#prop_gwarn').oninput = e => { w.warn = e.target.value === '' ? null : parseFloat(e.target.value); };
    $('#prop_gdanger').oninput = e => { w.danger = e.target.value === '' ? null : parseFloat(e.target.value); };
  }

  if (w.t === 'graph'){
    $('#prop_series').oninput = e => { w.series = Math.max(1, Math.min(10, parseInt(e.target.value, 10) || 1)); if (state.config) renderRuntime(); };
    $('#prop_window').oninput = e => { w.windowSec = Math.max(5, parseInt(e.target.value, 10) || 30); };
    $('#prop_autoscale').onchange = e => { w.autoScale = (e.target.value === '1'); };
    $('#prop_ymin').oninput = e => { w.yMin = parseFloat(e.target.value); };
    $('#prop_ymax').oninput = e => { w.yMax = parseFloat(e.target.value); };
    $('#prop_names').oninput = e => { w.seriesNames = e.target.value; if (state.config) renderRuntime(); };
    $('#prop_ylabel').oninput = e => { w.yLabel = e.target.value; };
  }

}


function deleteSelected() {
  if (!state.selected) { toast('üëÜ Select a widget first!', 'error'); return; }
  state.widgets = state.widgets.filter(w => w.id !== state.selected);
  state.selected = null;
  renderWidgets();
  renderPropsPanel();
  toast('üóëÔ∏è Deleted!', 'success');
}

function showCode() {
  if (state.widgets.length === 0) {
    toast('üëÜ Add some widgets first!', 'error');
    return;
  }
  const cfg = { title: $('#titleInput').value || 'My Remote', widgets: state.widgets };
  $('#modalTitle').textContent = 'üìÑ Your micro:bit Code';
  $('#modalCode').textContent = generateDemoCode(cfg);
  $('#modalBg').classList.add('show');
}

function downloadCode() {
  const blob = new Blob([$('#modalCode').textContent], { type: 'text/plain' });
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = 'microbit-remote.ts'; a.click();
  toast('üíæ Downloaded!', 'success');
}

function toast(msg, type = '') {
  const t = $('#toast'); t.textContent = msg;
  t.className = `toast ${type} show`;
  setTimeout(() => t.classList.remove('show'), 2500);
}



function showBuildOverlay(sub='‚ú® Building...'){
  const ov = $('#loadingOverlay');
  if (!ov) return;
  ov.classList.add('show');
  ov.setAttribute('aria-hidden','false');
  const subEl = $('#loadingSub'); if (subEl) subEl.textContent = sub;
  const pctEl = $('#loadingPct'); if (pctEl) pctEl.textContent = '';
  const bar = $('#loadingBarFill'); if (bar) bar.style.width = '100%';
}

// Loading overlay helpers
let _loadingIndeterminate = null;
function showLoading(title = 'üß© Loading your remote...', sub = 'Getting layout from micro:bit'){
  if (!state._allowLoadingOverlay) return;
  const ov = $('#loadingOverlay');
  if (!ov) return;
  ov.classList.add('show');
  ov.setAttribute('aria-hidden','false');
  const subEl = $('#loadingSub'); if (subEl) subEl.textContent = sub;
  const pctEl = $('#loadingPct'); if (pctEl) pctEl.textContent = '0%';
  const bar = $('#loadingBarFill'); if (bar) bar.style.width = '8%';

  clearInterval(_loadingIndeterminate);
  // fun, kid-friendly "wiggle" while chunks arrive
  let p = 8; let dir = 1;
  _loadingIndeterminate = setInterval(() => {
    p += dir * 3;
    if (p > 22) { p = 22; dir = -1; }
    if (p < 8)  { p = 8;  dir = 1; }
    if (bar) bar.style.width = p + '%';
  }, 220);
}

function setLoadingProgress(pct, sub){
  const bar = $('#loadingBarFill');
  const pctEl = $('#loadingPct');
  const subEl = $('#loadingSub');
  if (subEl && sub) subEl.textContent = sub;
  const clamped = Math.max(0, Math.min(100, pct));
  if (bar) bar.style.width = clamped + '%';
  if (pctEl) pctEl.textContent = Math.round(clamped) + '%';
}

function hideLoading(){
  const ov = $('#loadingOverlay');
  if (!ov) return;
  clearInterval(_loadingIndeterminate);
  _loadingIndeterminate = null;
  ov.classList.remove('show');
  ov.setAttribute('aria-hidden','true');
}

// BLE Connection
async function connectBle() {
  console.log('[BLE] Starting connection...');
  state._allowLoadingOverlay = true;
  try {
    console.log('[BLE] Requesting device...');
    const device = await navigator.bluetooth.requestDevice({
      filters: [{ namePrefix: 'BBC micro:bit' }],
      optionalServices: [UART_SERVICE]
    });
    console.log('[BLE] Device selected:', device.name);
    
    device.addEventListener('gattserverdisconnected', () => {
      console.log('[BLE] GATT server disconnected event');
      onDisconnect();
    });
    
    console.log('[BLE] Connecting to GATT server...');
    const server = await device.gatt.connect();
    console.log('[BLE] GATT connected');
    
    console.log('[BLE] Getting UART service...');
    const service = await server.getPrimaryService(UART_SERVICE);
    console.log('[BLE] UART service found');
    
    console.log('[BLE] Getting TX characteristic...');
    const notifyChar = await service.getCharacteristic(UART_TX_CHAR);
    console.log('[BLE] TX characteristic found');
    
    console.log('[BLE] Getting RX characteristic...');
    const writeChar = await service.getCharacteristic(UART_RX_CHAR);
    console.log('[BLE] RX characteristic found');
    
    console.log('[BLE] Starting notifications...');
    await notifyChar.startNotifications();
    notifyChar.addEventListener('characteristicvaluechanged', onNotify);
    console.log('[BLE] Notifications started');
    
    state.ble = { device, server, service, notifyChar, writeChar, connected: true };
    state.rxBuffer = '';
    updateBleUI();
    toast('Connected!', 'success');
    
    console.log('[BLE] Waiting 500ms then sending GETCFG...');
    showLoading('üß© Loading your remote...', 'Requesting layout (GETCFG)‚Ä¶');
    setTimeout(() => { 
      console.log('[BLE] Sending GETCFG now');
      state.rxBuffer = ''; 
      send('GETCFG'); 
    }, 500);
  } catch (err) {
    console.error('[BLE] Connection error:', err);
    toast('Connection failed', 'error');
  }
}

function onDisconnect() {
  console.log('[BLE] Disconnected!');
  state._allowLoadingOverlay = false;
  if (typeof hideLoading==='function') hideLoading();
  state.ble = { device:null, server:null, service:null, notifyChar:null, writeChar:null, connected:false };
  updateBleUI();
  hideLoading();
  beepDanger();
  toast('Disconnected', 'error');
}

function updateBleUI() {
  const btn = $('#bleBtn');
  if (state.ble.connected) {
    btn.classList.add('connected');
    btn.querySelector('span:last-child').textContent = 'Connected';
    $('#connectPrompt').style.display = 'none';
    $('#runtimeContent').style.display = 'flex';
  } else {
    btn.classList.remove('connected');
    btn.querySelector('span:last-child').textContent = 'Connect';
    $('#connectPrompt').style.display = 'block';
    $('#runtimeContent').style.display = 'none';
  }
}

let configBuffer = '';
    configChunks = 0;
    showLoading('üß© Loading your remote...', 'Receiving layout‚Ä¶');
    setLoadingProgress(12, 'Receiving layout‚Ä¶');
var configChunks = 0;
function onNotify(event) {
  const value = event.target.value;
  let str = '';
  for (let i = 0; i < value.byteLength; i++) {
    const byte = value.getUint8(i);
    if (byte !== 13) str += String.fromCharCode(byte);
  }
  console.log('[BLE RX] Received:', str.replace(/\n/g, '\\n'));
  state.rxBuffer += str;
  let nl;
  while ((nl = state.rxBuffer.indexOf('\n')) !== -1) {
    const line = state.rxBuffer.slice(0, nl).trim();
    state.rxBuffer = state.rxBuffer.slice(nl + 1);
    if (line) processLine(line);
  }
}

function processLine(line) {
  console.log('[BLE] Processing line:', line);
  if (line.startsWith('CFGBEGIN')) {
    console.log('[BLE] Config begin');
    configBuffer = '';
  }
  else if (line.startsWith('CFG ')) {
    configBuffer += line.substring(4);
    configChunks++;
    setLoadingProgress(Math.min(90, 12 + configChunks * 4), `Receiving layout‚Ä¶ (${configChunks} chunks)`);
    console.log('[BLE] Config chunk, total length:', configBuffer.length);
  }
  else if (line === 'CFGEND') {
    console.log('[BLE] Config end, decoding...');
    setLoadingProgress(96, 'Decoding layout‚Ä¶');
    try { 
      // Unicode-safe base64 decoding (handles emojis!)
      state.config = JSON.parse(decodeURIComponent(escape(atob(configBuffer))));
      if (state.config?.widgets) state.config.widgets.forEach(applyWidgetDefaults); 
      console.log('[BLE] Config decoded:', state.config);
      renderRuntime();
      setLoadingProgress(100, 'Ready!');
      setTimeout(hideLoading, 250);
      state._allowLoadingOverlay = false;
      hideLoading();
      toast('Remote loaded!', 'success'); 
    }
    catch(e) { console.error('[BLE] Config parse error:', e); hideLoading();
      toast('Config error', 'error'); }
  } else if (line.startsWith('UPD ')) {
    const parts = line.substring(4).split(' ');
    const id = parts[0];
    const val = parts.slice(1).join(' ');
    console.log('[BLE] Update widget:', id, '=', val);
    state.values[id] = val;
    updateRuntimeWidget(id, val);
  }
}

function renderRuntime() {
  if (!state.config) return;
  const cfg = state.config;
  $('#runtimeTitle').textContent = cfg.title || 'My Remote';
  const grid = $('#runtimeGrid');
  let maxX = 0, maxY = 0;
  cfg.widgets.forEach(w => { maxX = Math.max(maxX, w.x + w.w); maxY = Math.max(maxY, w.y + w.h); });
  grid.style.width = `${Math.max(400, maxX + 20)}px`;
  grid.style.height = `${Math.max(320, maxY + 20)}px`;
  grid.innerHTML = '';
  cfg.widgets.forEach(w => {
    const el = document.createElement('div');
    el.className = 'rt-widget'; el.dataset.id = w.id;
    el.style.cssText = `left:${w.x}px;top:${w.y}px;width:${w.w}px;height:${w.h}px`;
    el.innerHTML = createRuntimeWidget(w);
    grid.appendChild(el);
    bindRuntimeWidget(el, w);
  });

  // Initial draw for graphs & gauges
  cfg.widgets.forEach(w => {
    applyWidgetDefaults(w);
    if (w.t === 'graph') drawGraphWidget(w);
    if (w.t === 'gauge') updateGaugeWidget(w, state.values[w.id] || '0');
  });
}


function createRuntimeWidget(w) {
  const val = esc(state.values[w.id] || '0');
  const label = esc(w.label || w.t);
  const rawVal = state.values[w.id] || '0';
  const model = (w.model || '').trim();

  switch (w.t) {
    case 'button': {
      const m = model || 'neo';
      return `<button class="rt-button model-${m}"><span class="icon">üëÜ</span><span>${label}</span></button>`;
    }

    case 'slider': {
      const m = model || 'track';
      const min = (w.min ?? 0);
      const max = (w.max ?? 100);
      const step = (w.step ?? 1);
      const clamped = Math.max(min, Math.min(max, parseFloat(rawVal) || min));
      return `<div class="rt-slider-wrap">
        <div class="rt-slider-info"><span>${label}</span><span class="rt-slider-val">${esc(String(clamped))}</span></div>
        <input type="range" class="rt-slider model-${m}" min="${min}" max="${max}" step="${step}" value="${clamped}">
      </div>`;
    }

    case 'toggle': {
      const m = model || 'square';
      const on = rawVal === '1';
      const glyph = m === 'icon' ? (on ? '‚èª' : '‚≠ò') : (on ? '‚úì' : '‚óã');
      return `<div class="rt-toggle-wrap">
        <button class="rt-toggle model-${m}${on ? ' on' : ''}">${glyph}</button>
        <span>${label}</span>
      </div>`;
    }

    case 'led': {
      const m = model || 'dot';
      const on = rawVal === '1';
      const onColor = w.colorOn || '#ff5252';
      const offColor = w.colorOff || '#2a2a3a';
      const style = (m === 'ring')
        ? `border-color:${on ? onColor : 'rgba(255,255,255,0.18)'};`
        : `background:${on ? onColor : offColor};`;
      const shadow = (m === 'ring')
        ? (on ? `box-shadow:0 0 40px ${onColor};` : 'box-shadow:none;')
        : (on ? `box-shadow:0 0 40px ${onColor};` : 'box-shadow:none;');

      return `<div class="rt-led-wrap">
        <div class="rt-led model-${m}${on ? ' on' : ''}" style="${style}${shadow}"></div>
        <span>${label}</span>
      </div>`;
    }

    case 'joystick': {
      const m = model || 'classic';
      const stickM = m === 'min' ? 'min' : 'classic';
      return `<div class="rt-joystick-wrap">
        <div class="rt-joystick-base model-${m}"><div class="rt-joystick-stick model-${stickM}"></div></div>
        <span>${label}</span>
      </div>`;
    }

    case 'label': {
      const m = model || 'plain';
      return `<div class="rt-label-text model-${m}">${val || label}</div>`;
    }

    case 'gauge': {
      const m = model || 'classic';
      const units = esc(w.units || '');
      const decimals = (w.decimals ?? 0);
      // 11 tick marks across the arc
      const ticks = Array.from({length: 11}, (_, i) => {
        const a = (-180 + (180 * (i/10))) * Math.PI/180; // -180..0
        const cx = 60, cy = 70;
        const r1 = 42, r2 = 50;
        const x1 = cx + Math.cos(a) * r1;
        const y1 = cy + Math.sin(a) * r1;
        const x2 = cx + Math.cos(a) * r2;
        const y2 = cy + Math.sin(a) * r2;
        return `<line x1="${x1.toFixed(1)}" y1="${y1.toFixed(1)}" x2="${x2.toFixed(1)}" y2="${y2.toFixed(1)}" />`;
      }).join('');
      return `<div class="rt-gauge-wrap model-${m}">
        <div class="rt-gauge-svg">
          <svg viewBox="0 0 120 80" width="100%" height="100%">
            <g class="rt-gauge-ticks">${ticks}</g>
            <path class="rt-gauge-bg" d="M10,70 A50,50 0 0 1 110,70" />
            <path class="rt-gauge-fg" data-role="gaugeArc" d="M10,70 A50,50 0 0 1 110,70" />
          </svg>
        </div>
        <div class="rt-gauge-center">
          <div class="rt-gauge-emoji" data-role="gaugeEmoji">üòÉ</div>
          <div class="rt-gauge-value" data-role="gaugeValue">${esc((parseFloat(rawVal)||0).toFixed(decimals))}</div>
          <div class="rt-gauge-label">${label}${units ? ' ' + units : ''}</div>
        </div>
      </div>`;
    }
    
    case 'graph': {
      const m = model || 'grid';
      const win = parseInt(w.windowSec ?? 30, 10) || 30;
      const auto = (w.autoScale !== false);
      const series = Math.max(1, Math.min(10, parseInt(w.series ?? 1, 10) || 1));
      return `<div class="rt-graph-wrap model-${m}">
        <div class="rt-graph-head">
          <span>${label}</span>
          <span data-role="graphLast"></span>
        </div>
        <div class="rt-graph-sub" data-role="graphLegend"></div>
        <canvas class="rt-graph-canvas" data-role="graphCanvas"></canvas>
        <div class="rt-graph-sub">Win:${win}s&nbsp;&nbsp;${auto ? 'Auto' : 'Fixed'}&nbsp;&nbsp;Series:${series}</div>
      </div>`;
    }

    default:
      return `<div>${w.t}</div>`;
  }
}


function bindRuntimeWidget(el, w) {
  switch (w.t) {
    case 'button':
      const btn = el.querySelector('.rt-button');
      const press = e => { 
        e.preventDefault(); 
        console.log('[BUTTON] Pressed:', w.id);
        beepClick();
        send(`SET ${w.id} 1`); 
        btn.style.transform = 'scale(0.9)'; 
      };
      const release = () => { 
        console.log('[BUTTON] Released:', w.id);
        send(`SET ${w.id} 0`); 
        btn.style.transform = ''; 
      };
      btn.onmousedown = btn.ontouchstart = press;
      btn.onmouseup = btn.onmouseleave = btn.ontouchend = release;
      break;
    case 'slider':
      let sliderTimer = null;
      el.querySelector('.rt-slider').oninput = e => {
        el.querySelector('.rt-slider-val').textContent = e.target.value;
        // Debounce: only send after 50ms of no changes
        clearTimeout(sliderTimer);
        sliderTimer = setTimeout(() => {
          console.log('[SLIDER] Sending value:', e.target.value);
          send(`SET ${w.id} ${e.target.value}`);
        }, 50);
      };
      break;
    case 'toggle':
      el.querySelector('.rt-toggle').onclick = function() {
        const on = this.classList.toggle('on');
        this.textContent = on ? '‚úì' : '‚óã';
        beepToggle(on);
        send(`SET ${w.id} ${on ? '1' : '0'}`);
      };
      break;
    case 'joystick':
      const stick = el.querySelector('.rt-joystick-stick');
      const base = el.querySelector('.rt-joystick-base');
      let isDown = false;
      let joyTimer = null;
      let lastJoyMsg = '';
      const handleMove = e => {
        if (!isDown) return;
        const rect = base.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const dx = clientX - centerX;
        const dy = clientY - centerY;
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        const distance = Math.min(40, Math.hypot(dx, dy));
        stick.style.transform = `translate(${Math.cos(angle * Math.PI / 180) * distance}px, ${Math.sin(angle * Math.PI / 180) * distance}px)`;
        // Debounce joystick messages
        const msg = `SET ${w.id} ${Math.round(angle)} ${Math.round(distance)}`;
        if (msg !== lastJoyMsg) {
          lastJoyMsg = msg;
          clearTimeout(joyTimer);
          joyTimer = setTimeout(() => {
            console.log('[JOYSTICK] Sending:', msg);
            send(msg);
          }, 50);
        }
      };
      base.onmousedown = () => { console.log('[JOYSTICK] Down'); isDown = true; };
      base.ontouchstart = e => { e.preventDefault(); console.log('[JOYSTICK] Touch start'); isDown = true; };
      document.addEventListener('mousemove', handleMove);
      document.addEventListener('touchmove', handleMove, { passive: false });
      document.addEventListener('mouseup', () => { console.log('[JOYSTICK] Up'); isDown = false; stick.style.transform = ''; clearTimeout(joyTimer); });
      document.addEventListener('touchend', () => { console.log('[JOYSTICK] Touch end'); isDown = false; stick.style.transform = ''; clearTimeout(joyTimer); });
      break;
  }
}


// --- Graph & Gauge helpers ---
state.history = state.history || {}; // { [id]: { points: Array<{t:number, v:number[]}>, colors:string[] } }

function parseCsvNumbers(s){
  return String(s ?? '').split(',').map(x => parseFloat(x.trim())).filter(x => isFinite(x));
}

function ensureGraphState(id, series){
  if (!state.history[id]) state.history[id] = { points: [], colors: [] };
  const hs = state.history[id];
  if (!hs.colors || hs.colors.length !== series){
    // generate distinct-ish hues using HSL (no hard-coded palette)
    hs.colors = Array.from({length: series}).map((_,i)=>`hsl(${(i*360/series)|0} 85% 60%)`);
  }
  return hs;
}

function pushGraphPoint(w, csvVal){
  const nums = parseCsvNumbers(csvVal);
  const series = Math.max(1, Math.min(10, parseInt(w.series ?? 1, 10)));
  const hs = ensureGraphState(w.id, series);
  const now = performance.now();
  const arr = Array.from({length: series}).map((_,i)=> (nums[i] != null ? nums[i] : NaN));
  hs.points.push({ t: now, v: arr });

  // trim window
  const winMs = Math.max(5, Math.min(300, parseFloat(w.windowSec ?? 30))) * 1000;
  const cutoff = now - winMs;
  while (hs.points.length && hs.points[0].t < cutoff) hs.points.shift();
}

function resizeCanvasToDisplaySize(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(10, Math.floor(rect.width * dpr));
  const h = Math.max(10, Math.floor(rect.height * dpr));
  if (canvas.width !== w || canvas.height !== h){
    canvas.width = w; canvas.height = h;
    return true;
  }
  return false;
}

function drawGraphWidget(w){
  const root = document.querySelector(`.rt-widget[data-id="${w.id}"]`);
  if (!root) return;
  const canvas = root.querySelector('[data-role="graphCanvas"]');
  if (!canvas) return;

  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const cssW = Math.max(50, rect.width);
  const cssH = Math.max(40, rect.height);
  const W = Math.floor(cssW * dpr);
  const H = Math.floor(cssH * dpr);
  if (canvas.width !== W || canvas.height !== H){
    canvas.width = W; canvas.height = H;
  }

  const ctx = canvas.getContext('2d');
  // draw in CSS pixels for predictable fonts/line widths
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,cssW,cssH);

  const seriesCount = Math.max(1, Math.min(10, parseInt(w.series ?? 1, 10)));
  const hs = ensureGraphState(w.id, seriesCount);
  const pts = hs.points || [];


  // legend (kid-friendly)
  const legend = root.querySelector('[data-role="graphLegend"]');
  if (legend){
    const names = (w.seriesNames || '').split(',').map(s => s.trim()).filter(Boolean);
    legend.innerHTML = Array.from({length: seriesCount}).map((_,i) => {
      const nm = esc(names[i] || `S${i+1}`);
      return `<span class="legend-item"><span class="rt-graph-dot" data-s="${i}"></span>${nm}</span>`;
    }).join('');
  }

  // layout
  const mL = 36, mR = 10, mT = 10, mB = 22;
  const plotX = mL, plotY = mT;
  const plotW = Math.max(10, cssW - mL - mR);
  const plotH = Math.max(10, cssH - mT - mB);

  // background
  ctx.globalAlpha = 1;
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0,0,cssW,cssH);

  // axes + grid
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;

  // y grid + labels
  ctx.font = '10px system-ui, Segoe UI, sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.7)';

  // if no data, draw frame + hint
  ctx.strokeRect(plotX, plotY, plotW, plotH);
  if (pts.length < 2){
    ctx.fillStyle = 'rgba(255,255,255,0.55)';
    ctx.fillText('waiting for UPD...', plotX + 8, plotY + 16);
    // legend colors
    const legend2 = root.querySelector('[data-role="graphLegend"]');
    if (legend2){
      legend2.querySelectorAll('.rt-graph-dot').forEach(dot => {
        const i = parseInt(dot.getAttribute('data-s') || '0', 10);
        dot.style.background = hs.colors[i] || 'var(--accent)';
      });
    }
    return;
  }

  const t0 = pts[0].t;
  const t1 = pts[pts.length-1].t;
  const span = Math.max(0.001, t1 - t0);

  // y scale
  let yMin = Infinity, yMax = -Infinity;
  if (w.autoScale ?? true){
    pts.forEach(p => p.v.forEach(v => { if (isFinite(v)) { yMin = Math.min(yMin, v); yMax = Math.max(yMax, v); } }));
    if (!isFinite(yMin) || !isFinite(yMax)){ yMin = 0; yMax = 1; }
  } else {
    yMin = parseFloat(w.yMin ?? 0);
    yMax = parseFloat(w.yMax ?? 100);
    if (!isFinite(yMin) || !isFinite(yMax)){ yMin = 0; yMax = 1; }
  }
  if (yMin === yMax){ yMin -= 1; yMax += 1; }
  const pad = (yMax - yMin) * 0.08;
  yMin -= pad; yMax += pad;

  const xForT = t => plotX + ((t - t0) / span) * plotW;
  const yForV = v => plotY + plotH - ((v - yMin) / (yMax - yMin)) * plotH;

  // Y ticks
  const yTicks = 4;
  for (let i=0;i<=yTicks;i++){
    const p = i / yTicks;
    const y = plotY + p * plotH;
    ctx.beginPath(); ctx.moveTo(plotX, y); ctx.lineTo(plotX+plotW, y); ctx.stroke();
    const v = (yMax - (yMax - yMin) * p);
    ctx.fillText(v.toFixed(1), 4, y + 3);
  }

  
  // Y axis label
  if ((w.yLabel || '').trim()){
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    ctx.font = '11px system-ui, Segoe UI, sans-serif';
    ctx.translate(12, plotY + plotH/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(w.yLabel, 0, 0);
    ctx.restore();
  }

  // X ticks (seconds)
  const xTicks = 4;
  for (let i=0;i<=xTicks;i++){
    const p = i / xTicks;
    const x = plotX + p * plotW;
    ctx.beginPath(); ctx.moveTo(x, plotY); ctx.lineTo(x, plotY+plotH); ctx.stroke();
    const sec = ((t0 + span * p) - t1) / 1000; // negative to 0
    ctx.fillText(sec.toFixed(0) + 's', x - 10, plotY + plotH + 16);
  }

  // draw each series
  hs.colors.forEach((c, si) => {
    ctx.strokeStyle = c;
    ctx.lineWidth = 2;
    ctx.beginPath();
    let started = false;
    for (let i=0;i<pts.length;i++){
      const v = pts[i].v[si];
      if (!isFinite(v)) continue;
      const x = xForT(pts[i].t);
      const y = yForV(v);
      if (!started){ ctx.moveTo(x,y); started = true; }
      else { ctx.lineTo(x,y); }
    }
    if (started) ctx.stroke();
  });

  // update legend dots colors
  const legend2 = root.querySelector('[data-role="graphLegend"]');
  if (legend2){
    legend2.querySelectorAll('.rt-graph-dot').forEach(dot => {
      const i = parseInt(dot.getAttribute('data-s') || '0', 10);
      dot.style.background = hs.colors[i] || 'var(--accent)';
    });
  }
}

function stopDemoSim(){
  if (state._demoTimer){
    clearInterval(state._demoTimer);
    state._demoTimer = null;
  }
}

function startDemoSim(){
  stopDemoSim();
  const hasGraph = !!document.querySelector('.rt-widget[data-id="graph_env"] [data-role="graphCanvas"]');
  const hasGauge = !!document.querySelector('.rt-widget[data-id="gauge_temp"] .rt-gauge-wrap');
  if (!hasGraph && !hasGauge) return;

  let t0 = Date.now();
  state._demoTimer = setInterval(() => {
    const t = (Date.now() - t0) / 1000;

    const temp = 25 + 10 * Math.sin(t / 2);
    const level = 50 + 40 * Math.sin(t / 3);

    state.values['gauge_temp'] = temp.toFixed(1);
    state.values['gauge_level'] = level.toFixed(0);

    updateRuntimeWidget('gauge_temp', state.values['gauge_temp']);
    updateRuntimeWidget('gauge_level', state.values['gauge_level']);

    const s1 = 50 + 25 * Math.sin(t);
    const s2 = 30 + 15 * Math.cos(t * 1.2);
    const csv = `${s1.toFixed(1)},${s2.toFixed(1)}`;
    state.values['graph_env'] = csv;
    updateRuntimeWidget('graph_env', csv);

    const scoreEl = state.config?.widgets?.find(x => x.id === 'label_score');
    if (scoreEl){
      const sc = Math.floor((t * 3) % 999);
      const txt = `Score: ${sc}`;
      state.values['label_score'] = txt;
      updateRuntimeWidget('label_score', txt);
    }
  }, 250);
}


function updateGaugeWidget(w, valStr){
  const root = document.querySelector(`.rt-widget[data-id="${w.id}"]`);
  if (!root) return;
  const wrap = root.querySelector('.rt-gauge-wrap');
  if (!wrap) return;

  const arc = wrap.querySelector('[data-role="gaugeArc"]') || wrap.querySelector('.rt-gauge-fg');
  const txt = wrap.querySelector('[data-role="gaugeValue"]');
  const emo = wrap.querySelector('[data-role="gaugeEmoji"]');

  const min = parseFloat(w.min ?? 0);
  const max = parseFloat(w.max ?? 100);
  const dec = parseInt(w.decimals ?? 0, 10);

  let v = parseFloat(valStr);
  if (!isFinite(v)) v = min;

  const denom = (max - min) || 1;
  const t = Math.max(0, Math.min(1, (v - min) / denom));

  // Match CSS dasharray (half-ish arc). If changed in CSS, keep in sync.
  const L = 157.1;

  // Color zones (kid-friendly)
  const warn = (w.warn != null) ? parseFloat(w.warn) : null;
  const danger = (w.danger != null) ? parseFloat(w.danger) : null;

  let color = 'var(--green)';
  if (danger != null && isFinite(danger) && v >= danger) color = 'var(--red)';
  else if (warn != null && isFinite(warn) && v >= warn) color = 'var(--orange)';
  else color = 'var(--green)';

  if (arc){
    arc.style.strokeDasharray = String(L);
    arc.style.strokeDashoffset = String(L * (1 - t));
    arc.style.stroke = color;
  }

  if (txt){
    const d = isFinite(dec) ? dec : 0;
    txt.textContent = v.toFixed(d);
  }

  if (emo){
    // Cute emoji based on percent
    const pct = Math.round(t * 100);
    emo.textContent = pct < 20 ? 'üò¥' : pct < 40 ? 'üôÇ' : pct < 60 ? 'üòÉ' : pct < 80 ? 'ü§©' : 'üöÄ';
  }
}



function updateRuntimeWidget(id, val) {
  console.log('[UI] Updating widget:', id, 'to', val);
  const el = $(`.rt-widget[data-id="${id}"]`);
  if (!el || !state.config) {
    console.log('[UI] Widget not found or no config');
    return;
  }
  const w = state.config.widgets.find(x => x.id === id);
  if (!w) {
    console.log('[UI] Widget definition not found');
    return;
  }
  console.log('[UI] Widget type:', w.t);
  switch (w.t) {
    case 'slider': el.querySelector('.rt-slider').value = val; el.querySelector('.rt-slider-val').textContent = val; break;
    case 'toggle': el.querySelector('.rt-toggle').classList.toggle('on', val === '1'); el.querySelector('.rt-toggle').textContent = val === '1' ? '‚úì' : '‚óã'; break;
    case 'led': {
      const ledEl = el.querySelector('.rt-led');
      const wdef = state.config.widgets.find(x => x.id === id);
      const onColor = wdef?.colorOn || '#ff5252';
      const offColor = wdef?.colorOff || '#2a2a3a';
      const model = (wdef?.model || 'dot');
      const on = val === '1';

      // Ensure model class is present (in case config changed live)
      ledEl.className = `rt-led model-${model}${on ? ' on' : ''}`;

      if (model === 'ring'){
        ledEl.style.background = 'transparent';
        ledEl.style.borderColor = on ? onColor : 'rgba(255,255,255,0.18)';
        ledEl.style.boxShadow = on ? `0 0 40px ${onColor}` : 'none';
      } else {
        ledEl.style.borderColor = '';
        ledEl.style.background = on ? onColor : offColor;
        ledEl.style.boxShadow = on ? `0 0 40px ${onColor}` : 'none';
      }

      console.log('[UI] LED', id, 'is now', on ? 'ON' : 'OFF');
      break;
    }
    case 'label': el.querySelector('.rt-label-text').textContent = val; break;
    case 'gauge': updateGaugeWidget(w, val); break;
    case 'graph': {
      // val is comma-separated numbers: "23.4,2.1"
      pushGraphPoint(w, val);
      const last = el.querySelector('[data-role="graphLast"]');
      if (last) last.textContent = val;
      drawGraphWidget(w);
      break;
    }
  }
}

document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
