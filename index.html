<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>micro:bit Remote</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/interact.js/1.10.27/interact.min.js"></script>
<style>
:root {
  --bg: #1a1a2e;
  --surface: #16213e;
  --card: #1f3460;
  --accent: #00d4ff;
  --pink: #ff6b9d;
  --green: #00e676;
  --orange: #ff9100;
  --purple: #b388ff;
  --red: #ff5252;
  --yellow: #ffea00;
  --text: #ffffff;
  --text-dim: #8892b0;
}

* { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; overflow: hidden; touch-action: manipulation; font-family: 'Segoe UI', system-ui, sans-serif; }
body { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: var(--text); }

.app { display: flex; flex-direction: column; height: 100dvh; }

/* Header */
header {
  display: flex; align-items: center; gap: 10px;
  padding: 8px 12px; background: rgba(22,33,62,0.95);
  border-bottom: 2px solid var(--card);
}
.logo { font-size: 1.3rem; font-weight: 800; }
.logo span { background: linear-gradient(90deg, var(--accent), var(--pink)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.spacer { flex: 1; }

.tabs { display: flex; background: var(--card); border-radius: 30px; padding: 4px; }
.tab {
  padding: 10px 20px; border: none; background: none;
  color: var(--text-dim); font-weight: 700; font-size: 0.9rem;
  border-radius: 30px; cursor: pointer; transition: 0.2s;
}
.tab.active { background: linear-gradient(135deg, var(--accent), var(--purple)); color: #000; }

.ble-btn {
  display: flex; align-items: center; gap: 8px;
  padding: 10px 16px; border-radius: 30px;
  background: var(--card); border: 2px solid var(--red);
  color: var(--red); font-weight: 700; cursor: pointer;
}
.ble-btn.connected { border-color: var(--green); color: var(--green); }
.ble-dot { width: 12px; height: 12px; border-radius: 50%; background: currentColor; }

/* Main Content */
main { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
.view { display: none; flex-direction: column; height: 100%; }
.view.active { display: flex; }

/* Builder View */
.builder-header {
  display: flex; align-items: center; gap: 8px;
  padding: 10px 12px; background: var(--surface);
  flex-wrap: wrap;
}
.title-input {
  flex: 1; min-width: 120px; padding: 12px 16px;
  background: var(--card); border: 2px solid transparent;
  border-radius: 16px; color: var(--text); font-size: 1rem; font-weight: 600;
}
.title-input:focus { outline: none; border-color: var(--accent); }
.header-btn {
  padding: 12px 20px; border: none; border-radius: 16px;
  font-weight: 700; font-size: 0.85rem; cursor: pointer; transition: 0.2s;
  display: flex; align-items: center; gap: 6px;
}
.header-btn:hover { transform: scale(1.05); }
.btn-demo { background: linear-gradient(135deg, var(--yellow), var(--orange)); color: #000; }
.btn-code { background: linear-gradient(135deg, var(--accent), var(--purple)); color: #000; }
.btn-delete { background: var(--red); color: #fff; }

/* Palette - Bottom on mobile */
.palette {
  display: flex; gap: 8px; padding: 10px;
  background: var(--surface); border-top: 2px solid var(--card);
  overflow-x: auto; order: 2;
}
.palette-item {
  flex-shrink: 0; display: flex; flex-direction: column;
  align-items: center; gap: 6px; padding: 12px 16px;
  background: var(--card); border: 3px solid transparent;
  border-radius: 16px; cursor: pointer; transition: 0.2s;
  min-width: 72px;
}
.palette-item:hover, .palette-item.selected { border-color: var(--accent); transform: scale(1.05); }
.palette-item.selected { background: linear-gradient(135deg, var(--accent), var(--purple)); }
.palette-item.selected .palette-name { color: #000; }
.palette-icon { font-size: 28px; }
.palette-name { font-size: 0.7rem; font-weight: 700; color: var(--text-dim); text-transform: uppercase; }

/* Canvas */
.canvas-wrap { flex: 1; padding: 10px; overflow: hidden; order: 1; display: flex; flex-direction: column; }
.canvas-hint { text-align: center; padding: 8px; color: var(--text-dim); font-size: 0.85rem; }
.canvas-hint span { color: var(--accent); font-weight: 700; }
.canvas {
  flex: 1; position: relative; background: var(--card);
  border: 3px dashed var(--text-dim); border-radius: 20px;
  overflow: auto; min-height: 250px;
}
#widgetsLayer { position: absolute; inset: 0; }

.widget {
  position: absolute; background: var(--surface);
  border: 3px solid var(--text-dim); border-radius: 16px;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  cursor: move; touch-action: none; user-select: none; gap: 4px; padding: 8px;
}
.widget.selected { border-color: var(--accent); box-shadow: 0 0 30px rgba(0,212,255,0.5); }
.widget-icon { font-size: 2rem; pointer-events: none; }
.widget-label { font-size: 0.75rem; font-weight: 700; color: var(--text-dim); pointer-events: none; }
.widget .resize-handle {
  position: absolute; bottom: -2px; right: -2px;
  width: 24px; height: 24px; cursor: se-resize;
  background: var(--accent); border-radius: 0 0 14px 0;
  clip-path: polygon(100% 0, 100% 100%, 0 100%);
}

/* Runtime View */
.runtime-view { align-items: center; justify-content: center; padding: 20px; }
.connect-box { text-align: center; }
.connect-icon { font-size: 6rem; margin-bottom: 20px; animation: bounce 1s infinite; }
@keyframes bounce { 0%,100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
.connect-text { font-size: 1.3rem; font-weight: 700; margin-bottom: 24px; }
.connect-btn {
  padding: 18px 40px; border: none; border-radius: 30px;
  background: linear-gradient(135deg, var(--green), var(--accent));
  color: #000; font-size: 1.2rem; font-weight: 800; cursor: pointer;
}
#runtimeContent { display: none; flex-direction: column; align-items: center; width: 100%; }
#runtimeTitle { font-size: 1.6rem; font-weight: 800; color: var(--accent); margin-bottom: 20px; }
#runtimeGrid { position: relative; background: var(--card); border: 3px solid var(--surface); border-radius: 20px; }

/* Runtime Widgets */
/* Graph (Online) */
.rt-graph-wrap{
  width: 100%; height: 100%;
  display:flex; flex-direction:column; gap:8px;
  padding: 10px;
  border-radius: 16px;
}
.rt-graph-head{ display:flex; justify-content:space-between; font-weight:800; font-size:0.9rem; color: var(--text); }
.rt-graph-sub{ display:flex; gap:8px; flex-wrap:wrap; font-size:0.75rem; color: var(--text-dim); font-weight:800; }
.rt-graph-dot{ width:10px; height:10px; border-radius:999px; display:inline-block; vertical-align:middle; margin-right:6px; }
.rt-graph-canvas{
  width: 100%; flex:1;
  border-radius: 14px;
  background: rgba(0,0,0,0.14);
  border: 2px solid rgba(255,255,255,0.10);
}
.rt-graph-wrap.model-grid{
  background: linear-gradient(135deg, rgba(0,212,255,0.10), rgba(179,136,255,0.10));
}
.rt-graph-wrap.model-dark{
  background: rgba(0,0,0,0.15);
}
.rt-graph-wrap.model-min{
  background: transparent;
  border: 2px solid rgba(255,255,255,0.10);
}

/* Gauge */
.rt-gauge-wrap{
  width:100%; height:100%;
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  gap:8px; padding:10px;
  border-radius: 16px;
}
.rt-gauge-svg{ width: 100%; height: 100%; max-height: 120px; }
.rt-gauge-label{ font-weight:800; color: var(--text-dim); font-size:0.85rem; text-align:center; }
.rt-gauge-value{ font-weight:900; font-size:1.1rem; color: var(--text); text-align:center; }
.rt-gauge-wrap.model-classic{ background: rgba(0,0,0,0.10); border: 2px solid rgba(255,255,255,0.10); }
.rt-gauge-wrap.model-neon{ background: linear-gradient(135deg, rgba(0,212,255,0.12), rgba(255,107,157,0.10)); box-shadow: 0 0 30px rgba(0,212,255,0.12); }
.rt-gauge-wrap.model-min{ background: transparent; border: 2px solid rgba(255,255,255,0.10); }

.rt-gauge-bg{ stroke: rgba(255,255,255,0.18); stroke-width: 10; fill: none; }
.rt-gauge-fg{ stroke: var(--accent); stroke-width: 10; fill: none; stroke-linecap: round; }


.rt-widget { position: absolute; padding: 10px; display: flex; align-items: center; justify-content: center; }
.rt-button {
  width: 100%; height: 100%; border: none; border-radius: 16px;
  background: linear-gradient(135deg, #6366f1, var(--purple));
  color: #fff; font-weight: 700; cursor: pointer;
  display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 6px;
  font-size: 1rem; transition: 0.1s;
}
.rt-button:active { transform: scale(0.9); }
.rt-button .icon { font-size: 2rem; }

.rt-slider-wrap { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; gap: 10px; }
.rt-slider-info { display: flex; justify-content: space-between; font-weight: 700; }
.rt-slider { width: 100%; height: 12px; border-radius: 6px; background: var(--surface); -webkit-appearance: none; }
.rt-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 30px; height: 30px; border-radius: 50%; background: linear-gradient(135deg, var(--purple), var(--pink)); cursor: pointer; }

.rt-toggle-wrap { display: flex; flex-direction: column; align-items: center; gap: 10px; }
.rt-toggle { width: 70px; height: 70px; border: none; border-radius: 16px; background: var(--red); color: #fff; font-size: 2rem; cursor: pointer; transition: 0.2s; }
.rt-toggle.on { background: var(--green); }

.rt-led-wrap { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 10px; }
.rt-led { width: 60px; height: 60px; border-radius: 50%; background: rgba(255,82,82,0.2); transition: 0.2s; }
.rt-led.on { background: var(--red); box-shadow: 0 0 40px var(--red); }

.rt-joystick-wrap { display: flex; flex-direction: column; align-items: center; gap: 6px; }
.rt-joystick-base { width: 100px; height: 100px; border-radius: 50%; background: var(--surface); border: 4px solid var(--accent); display: flex; align-items: center; justify-content: center; touch-action: none; }
.rt-joystick-stick { width: 50px; height: 50px; border-radius: 50%; background: linear-gradient(135deg, var(--accent), var(--purple)); pointer-events: none; }

.rt-label-text { font-weight: 700; font-size: 1.2rem; text-align: center; }

/* --- Widget Models (Runtime) --- */
/* Buttons */
.rt-button.model-neo{
  background: linear-gradient(135deg, #6366f1, var(--purple));
  box-shadow: 0 10px 25px rgba(0,0,0,0.25);
}
.rt-button.model-flat{
  background: var(--accent);
  color: #000;
  box-shadow: none;
}
.rt-button.model-glass{
  background: rgba(255,255,255,0.08);
  border: 2px solid rgba(255,255,255,0.18);
  backdrop-filter: blur(10px);
  box-shadow: 0 12px 30px rgba(0,0,0,0.35);
}

/* Sliders */
.rt-slider.model-track{ height: 12px; border-radius: 6px; }
.rt-slider.model-min{ height: 6px; border-radius: 999px; }
.rt-slider.model-neon{
  height: 12px;
  border-radius: 999px;
  box-shadow: 0 0 20px rgba(0,212,255,0.25);
}
.rt-slider.model-neon::-webkit-slider-thumb{
  box-shadow: 0 0 25px rgba(179,136,255,0.7);
}
.rt-slider.model-min::-webkit-slider-thumb{
  width: 26px; height: 26px;
  background: linear-gradient(135deg, var(--accent), var(--pink));
}

/* Toggles */
.rt-toggle.model-square{ border-radius: 16px; }
.rt-toggle.model-pill{
  width: 90px; height: 46px;
  border-radius: 999px;
  display:flex; align-items:center; justify-content:center;
  font-size: 1.4rem;
}
.rt-toggle.model-icon{
  background: var(--card);
  border: 3px solid var(--surface);
  color: var(--text);
}
.rt-toggle.model-icon.on{
  border-color: var(--green);
  box-shadow: 0 0 30px rgba(0,230,118,0.35);
}

/* LEDs */
.rt-led.model-dot{ border-radius: 50%; }
.rt-led.model-bar{
  width: 90%;
  height: 28%;
  min-height: 18px;
  border-radius: 999px;
}
.rt-led.model-ring{
  background: transparent !important;
  border: 6px solid rgba(255,255,255,0.18);
  box-shadow: none !important;
}
.rt-led.model-ring.on{
  background: transparent !important;
}

/* Joysticks */
.rt-joystick-base.model-classic{ border: 4px solid var(--accent); }
.rt-joystick-base.model-neon{
  border: 4px solid var(--accent);
  box-shadow: 0 0 35px rgba(0,212,255,0.35);
}
.rt-joystick-base.model-min{
  border: 3px solid rgba(255,255,255,0.18);
}
.rt-joystick-stick.model-min{
  background: rgba(255,255,255,0.14);
}

/* Labels */
.rt-label-text.model-plain{ }
.rt-label-text.model-card{
  background: rgba(255,255,255,0.06);
  border: 2px solid rgba(255,255,255,0.14);
  border-radius: 16px;
  padding: 10px 14px;
}
.rt-label-text.model-glow{
  text-shadow: 0 0 18px rgba(0,212,255,0.55);
}

/* Props panel helpers */
.props-row{
  display:flex;
  gap:8px;
  align-items:center;
}
.props-apply{
  margin-top: 10px;
  width: 100%;
  padding: 10px 12px;
  border-radius: 14px;
  border: 2px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.06);
  color: var(--text);
  font-weight: 800;
  cursor: pointer;
}
.props-apply:hover{
  border-color: var(--accent);
}

/* Toast */
.toast { position: fixed; bottom: -100px; left: 50%; transform: translateX(-50%); padding: 16px 32px; background: var(--card); border: 3px solid var(--accent); border-radius: 30px; font-weight: 700; font-size: 1rem; transition: 0.3s; z-index: 1000; }
.toast.show { bottom: 30px; }
.toast.success { border-color: var(--green); color: var(--green); }
.toast.error { border-color: var(--red); color: var(--red); }

/* Modal */
.modal-bg { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 200; align-items: center; justify-content: center; padding: 20px; }
.modal-bg.show { display: flex; }
.modal { background: var(--surface); border: 3px solid var(--accent); border-radius: 24px; padding: 24px; max-width: 600px; width: 100%; max-height: 85vh; overflow-y: auto; }
.modal-title { font-size: 1.4rem; font-weight: 800; color: var(--accent); margin-bottom: 16px; }
.modal-code { background: var(--card); padding: 16px; border-radius: 16px; font-family: 'Fira Code', 'Consolas', monospace; font-size: 0.8rem; max-height: 400px; overflow: auto; color: var(--green); white-space: pre-wrap; word-break: break-all; margin-bottom: 16px; line-height: 1.5; }
.modal-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
.modal-btn { flex: 1; padding: 14px 20px; border: none; border-radius: 16px; font-weight: 700; cursor: pointer; }
.modal-btn.primary { background: linear-gradient(135deg, var(--accent), var(--purple)); color: #000; }
.modal-btn.secondary { background: var(--card); color: var(--text); }

/* Template Modal */
.template-modal { position: fixed; inset: 0; background: rgba(26,26,46,0.98); z-index: 100; display: flex; align-items: center; justify-content: center; padding: 20px; }
.template-modal.hidden { display: none; }
.template-content { text-align: center; max-width: 500px; width: 100%; }
.template-content h2 { font-size: 1.8rem; margin-bottom: 10px; background: linear-gradient(90deg, var(--accent), var(--pink)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.template-content p { color: var(--text-dim); margin-bottom: 24px; font-size: 1rem; }
.templates-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
.template-card { background: var(--card); border: 3px solid transparent; border-radius: 20px; padding: 20px 10px; cursor: pointer; transition: 0.2s; }
.template-card:hover { border-color: var(--accent); transform: scale(1.05); }
.template-card:active { transform: scale(0.95); }
.template-icon { font-size: 3rem; margin-bottom: 10px; }
.template-name { font-weight: 700; font-size: 0.9rem; }

/* Responsive */
@media (min-width: 768px) {
  .builder-view { flex-direction: row; }
  .palette { flex-direction: column; width: 100px; border-top: none; border-right: 2px solid var(--card); order: 0; overflow-y: auto; overflow-x: visible; }
  .canvas-wrap { order: 0; }
  .palette-item { width: 100%; min-width: unset; }
}
@media (max-width: 500px) {
  .logo { font-size: 1rem; }
  .tab { padding: 8px 14px; font-size: 0.8rem; }
  .ble-btn span:last-child { display: none; }
  .templates-grid { grid-template-columns: repeat(2, 1fr); }
  .template-icon { font-size: 2.2rem; }
  .header-btn { padding: 10px 14px; font-size: 0.75rem; }
}

/* Properties Panel */
.props-panel{
  background: var(--surface);
  border-left: 2px solid var(--card);
  padding: 12px;
  width: 260px;
  min-width: 240px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.props-title{ font-weight: 800; color: var(--accent); }
.props-empty{ color: var(--text-dim); font-weight: 600; font-size: 0.9rem; }

.props-form label{
  display:block;
  margin-top: 10px;
  font-size: 0.8rem;
  color: var(--text-dim);
  font-weight: 800;
  text-transform: uppercase;
}
.props-form input, .props-form select{
  width: 100%;
  margin-top: 6px;
  padding: 10px 12px;
  border-radius: 14px;
  border: 2px solid transparent;
  background: var(--card);
  color: var(--text);
  font-weight: 700;
}
.props-form input:focus, .props-form select:focus{
  outline: none;
  border-color: var(--accent);
}

@media (max-width: 768px){
  .props-panel{
    width: 100%;
    border-left: none;
    border-top: 2px solid var(--card);
  }
}

</style>
</head>
<body>
<div class="app">
  <header>
    <div class="logo">üéÆ <span>micro:bit</span></div>
    <div class="spacer"></div>
    <div class="tabs">
      <button class="tab active" data-tab="builder">‚úèÔ∏è Build</button>
      <button class="tab" data-tab="runtime">‚ñ∂Ô∏è Play</button>
    </div>
    <button id="bleBtn" class="ble-btn">
      <span class="ble-dot"></span>
      <span>Connect</span>
    </button>
  </header>

  <div id="templateModal" class="template-modal">
    <div class="template-content">
      <h2>üé® Choose a Template!</h2>
      <p>Pick one to start building your remote</p>
      <div class="templates-grid">
        <div class="template-card" data-tpl="gamepad"><div class="template-icon">üéÆ</div><div class="template-name">Game Pad</div></div>
        <div class="template-card" data-tpl="robot"><div class="template-icon">ü§ñ</div><div class="template-name">Robot</div></div>
        <div class="template-card" data-tpl="mixer"><div class="template-icon">üéµ</div><div class="template-name">DJ Mixer</div></div>
        <div class="template-card" data-tpl="racing"><div class="template-icon">üèéÔ∏è</div><div class="template-name">Race Car</div></div>
        <div class="template-card" data-tpl="lights"><div class="template-icon">üí°</div><div class="template-name">Lights</div></div>
        <div class="template-card" data-tpl="blank"><div class="template-icon">‚ú®</div><div class="template-name">Start Fresh</div></div>
      </div>
    </div>
  </div>

  <main>
    <div class="view builder-view active">
      <div class="builder-header">
        <input type="text" id="titleInput" class="title-input" placeholder="üè∑Ô∏è Name your remote..." maxlength="25">
        <button class="header-btn btn-demo" id="demoBtn">üéÆ Try All Widgets!</button>
        <button class="header-btn btn-code" id="codeBtn">üìÑ Code</button>
        <button class="header-btn btn-delete" id="deleteBtn">üóëÔ∏è</button>
      </div>
      <div class="canvas-wrap">
        <div class="canvas-hint">üëÜ Tap a widget below, then <span>tap here</span> to place it!</div>
        <div id="canvas" class="canvas"><div id="widgetsLayer"></div></div>
      </div>

      <div id="propsPanel" class="props-panel">
        <div class="props-title">üõ†Ô∏è Widget Properties</div>
        <div id="propsEmpty" class="props-empty">Select a widget to edit it.</div>
        <div id="propsForm" class="props-form" style="display:none;"></div>
      </div>

      <div class="palette">
        <div class="palette-item" data-type="button"><div class="palette-icon">üëÜ</div><div class="palette-name">Button</div></div>
        <div class="palette-item" data-type="slider"><div class="palette-icon">üéöÔ∏è</div><div class="palette-name">Slider</div></div>
        <div class="palette-item" data-type="toggle"><div class="palette-icon">üîò</div><div class="palette-name">Switch</div></div>
        <div class="palette-item" data-type="joystick"><div class="palette-icon">üïπÔ∏è</div><div class="palette-name">Joystick</div></div>
        <div class="palette-item" data-type="led"><div class="palette-icon">üí°</div><div class="palette-name">Light</div></div>
        <div class="palette-item" data-type="label"><div class="palette-icon">üè∑Ô∏è</div><div class="palette-name">Label</div></div>
        <div class="palette-item" data-type="gauge"><div class="palette-icon">üß≠</div><div class="palette-name">Gauge</div></div>
        <div class="palette-item" data-type="graph"><div class="palette-icon">üìà</div><div class="palette-name">Graph</div></div>
      </div>
    </div>

    <div class="view runtime-view">
      <div id="connectPrompt" class="connect-box">
        <div class="connect-icon">üì°</div>
        <div class="connect-text">Connect your micro:bit!</div>
        <button id="connectBtn" class="connect-btn">üîó Connect</button>
      </div>
      <div id="runtimeContent"><div id="runtimeTitle"></div><div id="runtimeGrid"></div></div>
    </div>
  </main>
</div>

<div id="toast" class="toast"></div>
<div id="modalBg" class="modal-bg">
  <div class="modal">
    <div id="modalTitle" class="modal-title"></div>
    <pre id="modalCode" class="modal-code"></pre>
    <div class="modal-buttons">
      <button class="modal-btn primary" id="copyBtn">üìã Copy</button>
      <button class="modal-btn primary" id="downloadBtn">üíæ Save</button>
      <button class="modal-btn secondary" id="modalClose">‚úñÔ∏è Close</button>
    </div>
  </div>
</div>
<input type="file" id="fileInput" accept=".json" hidden>

<script>
const UART_SERVICE = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const UART_TX_CHAR = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
const UART_RX_CHAR = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

const encoder = new TextEncoder();
const esc = s => { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; };
const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);

const ICONS = { button:'üëÜ', slider:'üéöÔ∏è', toggle:'üîò', joystick:'üïπÔ∏è', led:'üí°', label:'üè∑Ô∏è', graph:'üìà', gauge:'üß≠' };
const SIZES = { button:[90,90], slider:[90,160], toggle:[90,90], joystick:[120,120], led:[90,90], label:[120,60], graph:[240,140], gauge:[150,150] };

const templates = {
  gamepad: [
    { t:'joystick', x:20, y:30, w:120, h:120, label:'Move' },
    { t:'button', x:180, y:40, w:90, h:90, label:'Jump' },
    { t:'button', x:290, y:40, w:90, h:90, label:'Fire' },
    { t:'toggle', x:180, y:160, w:90, h:90, label:'Turbo' }
  ],
  robot: [
    { t:'slider', x:20, y:20, w:90, h:180, label:'Arm 1' },
    { t:'slider', x:130, y:20, w:90, h:180, label:'Arm 2' },
    { t:'slider', x:240, y:20, w:90, h:180, label:'Arm 3' },
    { t:'toggle', x:350, y:80, w:90, h:90, label:'Grip' }
  ],
  mixer: [
    { t:'slider', x:20, y:20, w:80, h:200, label:'Bass' },
    { t:'slider', x:120, y:20, w:80, h:200, label:'Mid' },
    { t:'slider', x:220, y:20, w:80, h:200, label:'High' },
    { t:'toggle', x:320, y:80, w:90, h:90, label:'FX' },
    { t:'led', x:320, y:20, w:90, h:50, label:'Beat' }
  ],
  racing: [
    { t:'joystick', x:150, y:20, w:130, h:130, label:'Steer' },
    { t:'slider', x:20, y:170, w:80, h:140, label:'Gas' },
    { t:'slider', x:330, y:170, w:80, h:140, label:'Brake' },
    { t:'button', x:150, y:180, w:130, h:80, label:'Nitro!' }
  ],
  lights: [
    { t:'toggle', x:30, y:30, w:100, h:100, label:'Red' },
    { t:'toggle', x:160, y:30, w:100, h:100, label:'Green' },
    { t:'toggle', x:290, y:30, w:100, h:100, label:'Blue' },
    { t:'led', x:90, y:160, w:100, h:100, label:'Status' },
    { t:'led', x:230, y:160, w:100, h:100, label:'Alert' }
  ],
  blank: []
};

const state = {
  widgets: [], selected: null, nextId: 1, selectedType: null,
  ble: { device:null, server:null, service:null, notifyChar:null, writeChar:null, connected:false },
  config: null, values: {}, rxBuffer: '',
  justDragged: false, _dragT: null
};

// Ensure older configs/templates still look good when new properties are added
function applyWidgetDefaults(w){
  if (!w || !w.t) return w;

  // Default models (3 per widget type)
  if (!w.model){
    if (w.t === 'button') w.model = 'neo';
    if (w.t === 'slider') w.model = 'track';
    if (w.t === 'toggle') w.model = 'square';
    if (w.t === 'led') w.model = 'dot';
    if (w.t === 'joystick') w.model = 'classic';
    if (w.t === 'label') w.model = 'plain';
    if (w.t === 'gauge') w.model = 'classic';
    if (w.t === 'graph') w.model = 'grid';
  }

  // Existing per-type defaults
  if (w.t === 'led'){
    if (!w.colorOn) w.colorOn = '#ff5252';
    if (!w.colorOff) w.colorOff = '#2a2a3a';
  }
  if (w.t === 'slider'){
    if (w.min == null) w.min = 0;
    if (w.max == null) w.max = 100;
    if (w.step == null) w.step = 1;
  }

  // Gauge defaults
  if (w.t === 'gauge'){
    if (w.min == null) w.min = 0;
    if (w.max == null) w.max = 100;
    if (w.decimals == null) w.decimals = 1;
    if (w.units == null) w.units = '';
    if (w.warn == null) w.warn = null;   // optional threshold
    if (w.danger == null) w.danger = null;
  }

  // Graph defaults (comma-separated multi-series values: "23.4,2.1")
  if (w.t === 'graph'){
    if (w.series == null) w.series = 1;      // 1..10
    if (w.windowSec == null) w.windowSec = 30; // visible time window
    if (w.autoScale == null) w.autoScale = true;
    if (w.min == null) w.min = 0;
    if (w.max == null) w.max = 100;
    if (w.showLegend == null) w.showLegend = true;
  }

  return w;
}

function modelOptionsForType(t){
  switch(t){
    case 'button': return [
      { v:'neo',   name:'Neo (gradient)' },
      { v:'flat',  name:'Flat' },
      { v:'glass', name:'Glass' }
    ];
    case 'slider': return [
      { v:'track', name:'Track' },
      { v:'neon',  name:'Neon' },
      { v:'min',   name:'Minimal' }
    ];
    case 'toggle': return [
      { v:'square', name:'Square' },
      { v:'pill',   name:'Pill' },
      { v:'icon',   name:'Icon' }
    ];
    case 'led': return [
      { v:'dot',  name:'Dot' },
      { v:'bar',  name:'Bar' },
      { v:'ring', name:'Ring' }
    ];
    case 'joystick': return [
      { v:'classic', name:'Classic' },
      { v:'neon',    name:'Neon' },
      { v:'min',     name:'Minimal' }
    ];
    case 'label': return [
      { v:'plain', name:'Plain' },
      { v:'card',  name:'Card' },
      { v:'glow',  name:'Glow' }
    ];
    case 'gauge': return [
      { v:'classic', name:'Classic' },
      { v:'neon',    name:'Neon' },
      { v:'min',     name:'Minimal' }
    ];
    case 'graph': return [
      { v:'grid',    name:'Grid' },
      { v:'dark',    name:'Dark' },
      { v:'min',     name:'Minimal' }
    ];
    default: return null;
  }
}

// BLE send with verbose debug logging
async function send(msg) {
  console.log('[BLE] Attempting to send:', msg);
  
  if (!state.ble.writeChar) {
    console.log('[BLE] ERROR: No writeChar available');
    return;
  }
  
  // Check if still connected
  const gattConnected = state.ble.device?.gatt?.connected;
  console.log('[BLE] GATT connected:', gattConnected);
  
  if (!gattConnected) {
    console.log('[BLE] ERROR: GATT disconnected, triggering onDisconnect');
    onDisconnect();
    return;
  }
  
  try {
    console.log('[BLE] Writing value...');
    await state.ble.writeChar.writeValue(encoder.encode(msg + '\n'));
    console.log('[BLE] Write SUCCESS');
  } catch (err) { 
    console.error('[BLE] Write FAILED:', err.name, err.message);
    // If write fails with certain errors, assume disconnected
    if (err.message?.includes('GATT') || err.message?.includes('disconnected')) {
      console.log('[BLE] Triggering disconnect due to GATT error');
      onDisconnect();
    }
  }
}

// One-click Demo - creates full showcase with all widgets
function showDemo() {
  // Create a demo with ALL widget types
  state.widgets = [
    { id: 'btn_jump', t: 'button', x: 20, y: 20, w: 100, h: 100, label: 'Jump!' },
    { id: 'btn_fire', t: 'button', x: 140, y: 20, w: 100, h: 100, label: 'Fire!' },
    { id: 'slider_speed', t: 'slider', x: 260, y: 20, w: 90, h: 180, label: 'Speed' },
    { id: 'slider_power', t: 'slider', x: 370, y: 20, w: 90, h: 180, label: 'Power' },
    { id: 'toggle_turbo', t: 'toggle', x: 20, y: 140, w: 100, h: 100, label: 'Turbo' },
    { id: 'toggle_shield', t: 'toggle', x: 140, y: 140, w: 100, h: 100, label: 'Shield' },
    { id: 'joy_move', t: 'joystick', x: 20, y: 260, w: 140, h: 140, label: 'Move' },
    { id: 'led_status', t: 'led', x: 180, y: 260, w: 100, h: 100, label: 'Status' },
    { id: 'led_alert', t: 'led', x: 300, y: 260, w: 100, h: 100, label: 'Alert' },
    { id: 'label_score', t: 'label', x: 180, y: 380, w: 150, h: 50, label: 'Score: 0' }
  ];
  state.widgets = state.widgets.map(applyWidgetDefaults);
  state.nextId = 20;
  state.selected = null;
  $('#titleInput').value = 'Super Demo Remote';
  renderWidgets();
  renderPropsPanel();
  
  // Show the code modal with demo code
  const cfg = { title: 'Super Demo Remote', widgets: state.widgets };
  $('#modalTitle').textContent = 'Demo Ready! Copy this code to MakeCode:';
  $('#modalCode').textContent = generateDemoCode(cfg);
  $('#modalBg').classList.add('show');
  
  toast('Demo loaded with ALL widgets!', 'success');
}

function generateDemoCode(cfg) {
  // Unicode-safe base64 encoding (handles emojis!)
  const b64 = btoa(unescape(encodeURIComponent(JSON.stringify(cfg))));
  
  // Group widgets by type
  const buttons = cfg.widgets.filter(w => w.t === 'button');
  const sliders = cfg.widgets.filter(w => w.t === 'slider');
  const toggles = cfg.widgets.filter(w => w.t === 'toggle');
  const joysticks = cfg.widgets.filter(w => w.t === 'joystick');
  const leds = cfg.widgets.filter(w => w.t === 'led');
  const labels = cfg.widgets.filter(w => w.t === 'label');
  
  // Generate handler code for each widget
  let buttonCode = buttons.map(w => `    // Button: ${w.label || w.id}
    if (id == "${w.id}" && val == "1") {
        basic.showIcon(IconNames.Heart)
        // Add your code here!
    }`).join('\n');
  
  let sliderCode = sliders.map(w => `    // Slider: ${w.label || w.id} (val = 0-100)
    if (id == "${w.id}") {
        let value = parseInt(val)
        led.plotBarGraph(value, 100)
        // Use value for motors, sounds, etc!
    }`).join('\n');
  
  let toggleCode = toggles.map(w => `    // Toggle: ${w.label || w.id} (val = "1" or "0")
    if (id == "${w.id}") {
        if (val == "1") {
            basic.showIcon(IconNames.Yes)
        } else {
            basic.showIcon(IconNames.No)
        }
    }`).join('\n');
  
  let joystickCode = joysticks.map(w => `    // Joystick: ${w.label || w.id} (val = "angle distance")
    if (id == "${w.id}") {
        let parts = val.split(" ")
        let angle = parseInt(parts[0])  // -180 to 180
        let dist = parseInt(parts[1])   // 0 to ~50
        // Use for steering, movement, etc!
        if (dist > 10) {
            basic.showArrow(angle > 0 ? ArrowNames.East : ArrowNames.West)
        } else {
            basic.showLeds(\`
                . . . . .
                . . # . .
                . # # # .
                . . # . .
                . . . . .
            \`)
        }
    }`).join('\n');

  let ledList = leds.map(w => `//   sendValue("${w.id}", "1")  // Turn ON ${w.label || 'LED'}
//   sendValue("${w.id}", "0")  // Turn OFF`).join('\n');

  let labelList = labels.map(w => `//   sendValue("${w.id}", "Hello!")  // Update ${w.label || 'label'}`).join('\n');

  return `// ${cfg.title} - micro:bit Remote
// Copy this to MakeCode: https://makecode.microbit.org
// Then flash it to your micro:bit!

bluetooth.startUartService()
let cfgSent = false
let blinkState = false
const CFG = "${b64}"

// This sends the remote layout to the app
bluetooth.onUartDataReceived(serial.delimiters(Delimiters.NewLine), function() {
    let cmd = bluetooth.uartReadUntil(serial.delimiters(Delimiters.NewLine))
    
    if (cmd == "GETCFG") {
        bluetooth.uartWriteLine("CFGBEGIN")
        for (let i = 0; i < CFG.length; i += 18) {
            bluetooth.uartWriteLine("CFG " + CFG.substr(i, 18))
        }
        bluetooth.uartWriteLine("CFGEND")
        cfgSent = true
        basic.showIcon(IconNames.Yes)
    } 
    else if (cmd.indexOf("SET ") == 0) {
        let parts = cmd.substr(4).split(" ")
        let id = parts[0]
        let val = parts.slice(1).join(" ")
        handleWidget(id, val)
    }
})

// HANDLE YOUR WIDGETS HERE!
function handleWidget(id: string, val: string) {
    serial.writeLine(id + " = " + val)
    
${buttonCode || '    // No buttons in this remote'}

${sliderCode || '    // No sliders in this remote'}

${toggleCode || '    // No toggles in this remote'}

${joystickCode || '    // No joysticks in this remote'}
}

// Send values TO the app (for LEDs and Labels)
function sendValue(id: string, val: string) {
    if (cfgSent) bluetooth.uartWriteLine("UPD " + id + " " + val)
}

// Show we are ready!
basic.showIcon(IconNames.Heart)

// BLINK THE APP LEDs! This runs forever in background
basic.forever(function() {
    if (cfgSent) {
        blinkState = !blinkState
        ${leds.length > 0 ? leds.map(l => `sendValue("${l.id}", blinkState ? "1" : "0")`).join('\n        ') : '// No LEDs to blink'}
        ${labels.length > 0 ? `sendValue("${labels[0].id}", blinkState ? "ON!" : "OFF")` : ''}
    }
    basic.pause(1000)
})

// BONUS: Use micro:bit buttons too!
input.onButtonPressed(Button.A, function() {
    basic.showString("A")
    ${leds.length > 0 ? `sendValue("${leds[0].id}", "1")` : '// Add an LED to control it here!'}
})
input.onButtonPressed(Button.B, function() {
    basic.showString("B")
    ${leds.length > 0 ? `sendValue("${leds[0].id}", "0")` : '// Add an LED to control it here!'}
})`;
}

function init() {
  // Tabs
  $$('.tab').forEach(t => t.onclick = () => switchTab(t.dataset.tab));
  
  // Templates
  $$('.template-card').forEach(c => c.onclick = () => selectTemplate(c.dataset.tpl));
  
  // Palette - tap to select
  $$('.palette-item').forEach(p => {
    p.onclick = () => {
      $$('.palette-item').forEach(x => x.classList.remove('selected'));
      p.classList.add('selected');
      state.selectedType = p.dataset.type;
      toast(`‚úÖ ${ICONS[state.selectedType]} selected! Tap canvas to place`, 'success');
    };
  });
  
  // Canvas - tap to place
  $('#canvas').onclick = e => {
    if (e.target.closest('.widget')) return;
    if (state.selectedType) {
      const rect = $('#canvas').getBoundingClientRect();
      const [w, h] = SIZES[state.selectedType];
      const x = Math.max(0, Math.min(e.clientX - rect.left - w/2, rect.width - w));
      const y = Math.max(0, Math.min(e.clientY - rect.top - h/2, rect.height - h));
      const base = applyWidgetDefaults({ id: `${state.selectedType}${state.nextId++}`, t: state.selectedType, x, y, w, h, label: '' });
      state.widgets.push(base);
      renderWidgets();
      toast(`‚ú® ${ICONS[state.selectedType]} added!`, 'success');
    } else {
      state.selected = null;
      renderWidgets();
      renderPropsPanel();
    }
  };
  
  // Buttons
  $('#bleBtn').onclick = connectBle;
  $('#connectBtn').onclick = connectBle;
  $('#demoBtn').onclick = showDemo;
  $('#codeBtn').onclick = showCode;
  $('#deleteBtn').onclick = deleteSelected;
  $('#modalClose').onclick = () => $('#modalBg').classList.remove('show');
  $('#modalBg').onclick = e => { if (e.target === $('#modalBg')) $('#modalBg').classList.remove('show'); };
  $('#copyBtn').onclick = () => { navigator.clipboard.writeText($('#modalCode').textContent); toast('üìã Copied!', 'success'); };
  $('#downloadBtn').onclick = downloadCode;
  
  $('#templateModal').classList.remove('hidden');
}

function selectTemplate(name) {
  const t = templates[name];
  if (!t) return;
  state.widgets = t.map((w, i) => applyWidgetDefaults({ id: `${w.t}${state.nextId + i}`, ...w }));
  state.nextId += t.length || 1;
  state.selected = null;
  $('#templateModal').classList.add('hidden');
  renderWidgets();
  renderPropsPanel();
  if (name === 'blank') toast('‚ú® Canvas ready! Pick a widget below', 'success');
}

function switchTab(tab) {
  $$('.tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
  $$('.view').forEach(v => v.classList.remove('active'));
  $(`.${tab === 'builder' ? 'builder-view' : 'runtime-view'}`).classList.add('active');
}

function renderWidgets() {
  const layer = $('#widgetsLayer');
  layer.innerHTML = '';
  state.widgets.forEach(w => {
    const el = document.createElement('div');
    el.className = 'widget' + (state.selected === w.id ? ' selected' : '');
    el.dataset.id = w.id;
    el.style.cssText = `left:${w.x}px;top:${w.y}px;width:${w.w}px;height:${w.h}px`;
    el.innerHTML = `<div class="widget-icon">${ICONS[w.t]}</div><div class="widget-label">${esc(w.label) || w.t}</div><div class="resize-handle"></div>`;
    layer.appendChild(el);
    
    interact(el).draggable({
      inertia: true,
      modifiers: [interact.modifiers.restrictRect({ restriction: 'parent' })],
      listeners: {
        start() { state.selected = w.id; updateSelectionUI(); },
        move(e) {
          state.justDragged = true;
          clearTimeout(state._dragT);
          state._dragT = setTimeout(() => state.justDragged = false, 50);
          w.x += e.dx; w.y += e.dy;
          e.target.style.left = w.x + 'px';
          e.target.style.top = w.y + 'px';
        }
      }
    }).resizable({
      edges: { right: true, bottom: true },
      modifiers: [interact.modifiers.restrictSize({ min: { width: 60, height: 60 } })],
      listeners: {
        move(e) {
          w.w = e.rect.width; w.h = e.rect.height;
          e.target.style.width = w.w + 'px';
          e.target.style.height = w.h + 'px';
        }
      }
    });
    
    el.onclick = e => { e.stopPropagation(); state.selected = w.id; updateSelectionUI(); };
  });
}


function updateSelectionUI() {
  $$('.widget').forEach(el => el.classList.toggle('selected', el.dataset.id === state.selected));
  renderPropsPanel();
}

function getSelectedWidget(){
  return state.widgets.find(w => w.id === state.selected);
}

function renderPropsPanel(){
  const form = $('#propsForm');
  const empty = $('#propsEmpty');
  const w = getSelectedWidget();

  if (!form || !empty) return;

  if (!w){
    empty.style.display = 'block';
    form.style.display = 'none';
    form.innerHTML = '';
    return;
  }

  empty.style.display = 'none';
  form.style.display = 'block';

  // Common fields
  let html = `
    <label>Widget ID</label>
    <input id="prop_id" value="${esc(w.id)}" />

    <label>Label</label>
    <input id="prop_label" value="${esc(w.label || '')}" />
  `;

  // Model selector (3 presets per widget type)
  const opts = modelOptionsForType(w.t);
  if (opts){
    html += `
      <label>Model</label>
      <select id="prop_model">
        ${opts.map(o => `<option value="${o.v}" ${w.model === o.v ? 'selected' : ''}>${o.name}</option>`).join('')}
      </select>
      <button class="props-apply" id="prop_applyAll">Apply this model to ALL ${w.t}s</button>
    `;
  }

  // Type-specific fields
  if (w.t === 'led'){
    html += `
      <label>LED On Color</label>
      <input id="prop_colorOn" type="color" value="${w.colorOn || '#ff5252'}" />

      <label>LED Off Color</label>
      <input id="prop_colorOff" type="color" value="${w.colorOff || '#2a2a3a'}" />
    `;
  }

  if (w.t === 'slider'){
    html += `
      <label>Min</label>
      <input id="prop_min" type="number" value="${w.min ?? 0}" />

      <label>Max</label>
      <input id="prop_max" type="number" value="${w.max ?? 100}" />

      <label>Step</label>
      <input id="prop_step" type="number" value="${w.step ?? 1}" />
    `;
  }

  form.innerHTML = html;

  // Wire events
  $('#prop_label').oninput = e => {
    w.label = e.target.value;
    const el = $(`.widget[data-id="${w.id}"] .widget-label`);
    if (el) el.textContent = w.label || w.t;
  };

  $('#prop_id').onchange = e => {
    const newId = e.target.value.trim();
    if (!newId || state.widgets.some(x => x.id === newId && x !== w)){
      toast('‚ùå ID must be unique', 'error');
      e.target.value = w.id;
      return;
    }
    const oldId = w.id;
    w.id = newId;

    const root = $(`.widget[data-id="${oldId}"]`);
    if (root) root.dataset.id = newId;

    if (state.values[oldId] != null){
      state.values[newId] = state.values[oldId];
      delete state.values[oldId];
    }

    state.selected = newId;
    updateSelectionUI();
    toast('‚úÖ ID updated', 'success');
  };

  // Model wiring (and quick apply to all widgets of same type)
  const modelSel = $('#prop_model');
  if (modelSel){
    modelSel.onchange = e => { w.model = e.target.value; toast('‚úÖ Model updated', 'success'); };
  }
  const applyBtn = $('#prop_applyAll');
  if (applyBtn){
    applyBtn.onclick = () => {
      const val = w.model;
      state.widgets.forEach(x => { if (x.t === w.t) x.model = val; });
      if (state.config?.widgets) state.config.widgets.forEach(x => { if (x.t === w.t) x.model = val; });
      renderWidgets();
      if (state.config) renderRuntime();
      toast(`‚ú® Applied model to all ${w.t}s`, 'success');
    };
  }


  if (w.t === 'led'){
    $('#prop_colorOn').oninput = e => { w.colorOn = e.target.value; };
    $('#prop_colorOff').oninput = e => { w.colorOff = e.target.value; };
  }

  if (w.t === 'slider'){
    $('#prop_min').oninput = e => { w.min = parseFloat(e.target.value); };
    $('#prop_max').oninput = e => { w.max = parseFloat(e.target.value); };
    $('#prop_step').oninput = e => { w.step = parseFloat(e.target.value); };
  }
}


function deleteSelected() {
  if (!state.selected) { toast('üëÜ Select a widget first!', 'error'); return; }
  state.widgets = state.widgets.filter(w => w.id !== state.selected);
  state.selected = null;
  renderWidgets();
  renderPropsPanel();
  toast('üóëÔ∏è Deleted!', 'success');
}

function showCode() {
  if (state.widgets.length === 0) {
    toast('üëÜ Add some widgets first!', 'error');
    return;
  }
  const cfg = { title: $('#titleInput').value || 'My Remote', widgets: state.widgets };
  $('#modalTitle').textContent = 'üìÑ Your micro:bit Code';
  $('#modalCode').textContent = generateDemoCode(cfg);
  $('#modalBg').classList.add('show');
}

function downloadCode() {
  const blob = new Blob([$('#modalCode').textContent], { type: 'text/plain' });
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = 'microbit-remote.ts'; a.click();
  toast('üíæ Downloaded!', 'success');
}

function toast(msg, type = '') {
  const t = $('#toast'); t.textContent = msg;
  t.className = `toast ${type} show`;
  setTimeout(() => t.classList.remove('show'), 2500);
}

// BLE Connection
async function connectBle() {
  console.log('[BLE] Starting connection...');
  try {
    console.log('[BLE] Requesting device...');
    const device = await navigator.bluetooth.requestDevice({
      filters: [{ namePrefix: 'BBC micro:bit' }],
      optionalServices: [UART_SERVICE]
    });
    console.log('[BLE] Device selected:', device.name);
    
    device.addEventListener('gattserverdisconnected', () => {
      console.log('[BLE] GATT server disconnected event');
      onDisconnect();
    });
    
    console.log('[BLE] Connecting to GATT server...');
    const server = await device.gatt.connect();
    console.log('[BLE] GATT connected');
    
    console.log('[BLE] Getting UART service...');
    const service = await server.getPrimaryService(UART_SERVICE);
    console.log('[BLE] UART service found');
    
    console.log('[BLE] Getting TX characteristic...');
    const notifyChar = await service.getCharacteristic(UART_TX_CHAR);
    console.log('[BLE] TX characteristic found');
    
    console.log('[BLE] Getting RX characteristic...');
    const writeChar = await service.getCharacteristic(UART_RX_CHAR);
    console.log('[BLE] RX characteristic found');
    
    console.log('[BLE] Starting notifications...');
    await notifyChar.startNotifications();
    notifyChar.addEventListener('characteristicvaluechanged', onNotify);
    console.log('[BLE] Notifications started');
    
    state.ble = { device, server, service, notifyChar, writeChar, connected: true };
    state.rxBuffer = '';
    updateBleUI();
    toast('Connected!', 'success');
    
    console.log('[BLE] Waiting 500ms then sending GETCFG...');
    setTimeout(() => { 
      console.log('[BLE] Sending GETCFG now');
      state.rxBuffer = ''; 
      send('GETCFG'); 
    }, 500);
  } catch (err) {
    console.error('[BLE] Connection error:', err);
    toast('Connection failed', 'error');
  }
}

function onDisconnect() {
  console.log('[BLE] Disconnected!');
  state.ble = { device:null, server:null, service:null, notifyChar:null, writeChar:null, connected:false };
  updateBleUI();
  toast('Disconnected', 'error');
}

function updateBleUI() {
  const btn = $('#bleBtn');
  if (state.ble.connected) {
    btn.classList.add('connected');
    btn.querySelector('span:last-child').textContent = 'Connected';
    $('#connectPrompt').style.display = 'none';
    $('#runtimeContent').style.display = 'flex';
  } else {
    btn.classList.remove('connected');
    btn.querySelector('span:last-child').textContent = 'Connect';
    $('#connectPrompt').style.display = 'block';
    $('#runtimeContent').style.display = 'none';
  }
}

let configBuffer = '';
function onNotify(event) {
  const value = event.target.value;
  let str = '';
  for (let i = 0; i < value.byteLength; i++) {
    const byte = value.getUint8(i);
    if (byte !== 13) str += String.fromCharCode(byte);
  }
  console.log('[BLE RX] Received:', str.replace(/\n/g, '\\n'));
  state.rxBuffer += str;
  let nl;
  while ((nl = state.rxBuffer.indexOf('\n')) !== -1) {
    const line = state.rxBuffer.slice(0, nl).trim();
    state.rxBuffer = state.rxBuffer.slice(nl + 1);
    if (line) processLine(line);
  }
}

function processLine(line) {
  console.log('[BLE] Processing line:', line);
  if (line.startsWith('CFGBEGIN')) {
    console.log('[BLE] Config begin');
    configBuffer = '';
  }
  else if (line.startsWith('CFG ')) {
    configBuffer += line.substring(4);
    console.log('[BLE] Config chunk, total length:', configBuffer.length);
  }
  else if (line === 'CFGEND') {
    console.log('[BLE] Config end, decoding...');
    try { 
      // Unicode-safe base64 decoding (handles emojis!)
      state.config = JSON.parse(decodeURIComponent(escape(atob(configBuffer))));
      if (state.config?.widgets) state.config.widgets.forEach(applyWidgetDefaults); 
      console.log('[BLE] Config decoded:', state.config);
      renderRuntime(); 
      toast('Remote loaded!', 'success'); 
    }
    catch(e) { console.error('[BLE] Config parse error:', e); toast('Config error', 'error'); }
  } else if (line.startsWith('UPD ')) {
    const parts = line.substring(4).split(' ');
    const id = parts[0];
    const val = parts.slice(1).join(' ');
    console.log('[BLE] Update widget:', id, '=', val);
    state.values[id] = val;
    updateRuntimeWidget(id, val);
  }
}

function renderRuntime() {
  if (!state.config) return;
  const cfg = state.config;
  $('#runtimeTitle').textContent = cfg.title || 'My Remote';
  const grid = $('#runtimeGrid');
  let maxX = 0, maxY = 0;
  cfg.widgets.forEach(w => { maxX = Math.max(maxX, w.x + w.w); maxY = Math.max(maxY, w.y + w.h); });
  grid.style.width = `${Math.max(400, maxX + 20)}px`;
  grid.style.height = `${Math.max(320, maxY + 20)}px`;
  grid.innerHTML = '';
  cfg.widgets.forEach(w => {
    const el = document.createElement('div');
    el.className = 'rt-widget'; el.dataset.id = w.id;
    el.style.cssText = `left:${w.x}px;top:${w.y}px;width:${w.w}px;height:${w.h}px`;
    el.innerHTML = createRuntimeWidget(w);
    grid.appendChild(el);
    bindRuntimeWidget(el, w);
  });

  // Initial draw for graphs & gauges
  cfg.widgets.forEach(w => {
    applyWidgetDefaults(w);
    if (w.t === 'graph') drawGraphWidget(w);
    if (w.t === 'gauge') updateGaugeWidget(w, state.values[w.id] || '0');
  });
}


function createRuntimeWidget(w) {
  const val = esc(state.values[w.id] || '0');
  const label = esc(w.label || w.t);
  const rawVal = state.values[w.id] || '0';
  const model = (w.model || '').trim();

  switch (w.t) {
    case 'button': {
      const m = model || 'neo';
      return `<button class="rt-button model-${m}"><span class="icon">üëÜ</span><span>${label}</span></button>`;
    }

    case 'slider': {
      const m = model || 'track';
      const min = (w.min ?? 0);
      const max = (w.max ?? 100);
      const step = (w.step ?? 1);
      const clamped = Math.max(min, Math.min(max, parseFloat(rawVal) || min));
      return `<div class="rt-slider-wrap">
        <div class="rt-slider-info"><span>${label}</span><span class="rt-slider-val">${esc(String(clamped))}</span></div>
        <input type="range" class="rt-slider model-${m}" min="${min}" max="${max}" step="${step}" value="${clamped}">
      </div>`;
    }

    case 'toggle': {
      const m = model || 'square';
      const on = rawVal === '1';
      const glyph = m === 'icon' ? (on ? '‚èª' : '‚≠ò') : (on ? '‚úì' : '‚óã');
      return `<div class="rt-toggle-wrap">
        <button class="rt-toggle model-${m}${on ? ' on' : ''}">${glyph}</button>
        <span>${label}</span>
      </div>`;
    }

    case 'led': {
      const m = model || 'dot';
      const on = rawVal === '1';
      const onColor = w.colorOn || '#ff5252';
      const offColor = w.colorOff || '#2a2a3a';
      const style = (m === 'ring')
        ? `border-color:${on ? onColor : 'rgba(255,255,255,0.18)'};`
        : `background:${on ? onColor : offColor};`;
      const shadow = (m === 'ring')
        ? (on ? `box-shadow:0 0 40px ${onColor};` : 'box-shadow:none;')
        : (on ? `box-shadow:0 0 40px ${onColor};` : 'box-shadow:none;');

      return `<div class="rt-led-wrap">
        <div class="rt-led model-${m}${on ? ' on' : ''}" style="${style}${shadow}"></div>
        <span>${label}</span>
      </div>`;
    }

    case 'joystick': {
      const m = model || 'classic';
      const stickM = m === 'min' ? 'min' : 'classic';
      return `<div class="rt-joystick-wrap">
        <div class="rt-joystick-base model-${m}"><div class="rt-joystick-stick model-${stickM}"></div></div>
        <span>${label}</span>
      </div>`;
    }

    case 'label': {
      const m = model || 'plain';
      return `<div class="rt-label-text model-${m}">${val || label}</div>`;
    }

    
    case 'gauge': {
      const m = model || 'classic';
      const min = (w.min ?? 0);
      const dec = (w.decimals ?? 1);
      const units = esc((w.units || '').trim());
      const current = state.values[w.id];
      let v = parseFloat(current);
      if (!isFinite(v)) v = parseFloat(min) || 0;

      return `<div class="rt-gauge-wrap model-${m}">
        <svg class="rt-gauge-svg" viewBox="0 0 120 72" aria-label="gauge">
          <path class="rt-gauge-bg" d="M12 60 A48 48 0 0 1 108 60"></path>
          <path class="rt-gauge-fg" d="M12 60 A48 48 0 0 1 108 60"></path>
        </svg>
        <div class="rt-gauge-value" data-role="gaugeValue">${v.toFixed(dec)}${units ? ' ' + units : ''}</div>
        <div class="rt-gauge-label">${label}</div>
      </div>`;
    }

    case 'graph': {
      const m = model || 'grid';
      const series = Math.max(1, Math.min(10, parseInt(w.series ?? 1, 10)));
      const win = parseFloat(w.windowSec ?? 30);
      const auto = (w.autoScale ?? true);
      const min = (w.min ?? 0);
      const max = (w.max ?? 100);

      const dots = Array.from({length: series}).map((_,i)=>`<span><span class="rt-graph-dot" data-s="${i}"></span>S${i+1}</span>`).join('');

      return `<div class="rt-graph-wrap model-${m}">
        <div class="rt-graph-head"><span>${label}</span><span data-role="graphLast">‚Äî</span></div>
        <div class="rt-graph-sub" data-role="graphLegend">${dots}</div>
        <canvas class="rt-graph-canvas" data-role="graphCanvas"></canvas>
        <div class="rt-graph-sub">
          <span>Win: ${win}s</span>
          <span>${auto ? 'Auto' : `Min ${min} Max ${max}`}</span>
        </div>
      </div>`;
    }

default:
      return `<div>${w.t}</div>`;
  }
}


function bindRuntimeWidget(el, w) {
  switch (w.t) {
    case 'button':
      const btn = el.querySelector('.rt-button');
      const press = e => { 
        e.preventDefault(); 
        console.log('[BUTTON] Pressed:', w.id);
        send(`SET ${w.id} 1`); 
        btn.style.transform = 'scale(0.9)'; 
      };
      const release = () => { 
        console.log('[BUTTON] Released:', w.id);
        send(`SET ${w.id} 0`); 
        btn.style.transform = ''; 
      };
      btn.onmousedown = btn.ontouchstart = press;
      btn.onmouseup = btn.onmouseleave = btn.ontouchend = release;
      break;
    case 'slider':
      let sliderTimer = null;
      el.querySelector('.rt-slider').oninput = e => {
        el.querySelector('.rt-slider-val').textContent = e.target.value;
        // Debounce: only send after 50ms of no changes
        clearTimeout(sliderTimer);
        sliderTimer = setTimeout(() => {
          console.log('[SLIDER] Sending value:', e.target.value);
          send(`SET ${w.id} ${e.target.value}`);
        }, 50);
      };
      break;
    case 'toggle':
      el.querySelector('.rt-toggle').onclick = function() {
        const on = this.classList.toggle('on');
        this.textContent = on ? '‚úì' : '‚óã';
        send(`SET ${w.id} ${on ? '1' : '0'}`);
      };
      break;
    case 'joystick':
      const stick = el.querySelector('.rt-joystick-stick');
      const base = el.querySelector('.rt-joystick-base');
      let isDown = false;
      let joyTimer = null;
      let lastJoyMsg = '';
      const handleMove = e => {
        if (!isDown) return;
        const rect = base.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const dx = clientX - centerX;
        const dy = clientY - centerY;
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        const distance = Math.min(40, Math.hypot(dx, dy));
        stick.style.transform = `translate(${Math.cos(angle * Math.PI / 180) * distance}px, ${Math.sin(angle * Math.PI / 180) * distance}px)`;
        // Debounce joystick messages
        const msg = `SET ${w.id} ${Math.round(angle)} ${Math.round(distance)}`;
        if (msg !== lastJoyMsg) {
          lastJoyMsg = msg;
          clearTimeout(joyTimer);
          joyTimer = setTimeout(() => {
            console.log('[JOYSTICK] Sending:', msg);
            send(msg);
          }, 50);
        }
      };
      base.onmousedown = () => { console.log('[JOYSTICK] Down'); isDown = true; };
      base.ontouchstart = e => { e.preventDefault(); console.log('[JOYSTICK] Touch start'); isDown = true; };
      document.addEventListener('mousemove', handleMove);
      document.addEventListener('touchmove', handleMove, { passive: false });
      document.addEventListener('mouseup', () => { console.log('[JOYSTICK] Up'); isDown = false; stick.style.transform = ''; clearTimeout(joyTimer); });
      document.addEventListener('touchend', () => { console.log('[JOYSTICK] Touch end'); isDown = false; stick.style.transform = ''; clearTimeout(joyTimer); });
      break;
  }
}


// --- Graph & Gauge helpers ---
state.history = state.history || {}; // { [id]: { points: Array<{t:number, v:number[]}>, colors:string[] } }

function parseCsvNumbers(s){
  return String(s ?? '').split(',').map(x => parseFloat(x.trim())).filter(x => isFinite(x));
}

function ensureGraphState(id, series){
  if (!state.history[id]) state.history[id] = { points: [], colors: [] };
  const hs = state.history[id];
  if (!hs.colors || hs.colors.length !== series){
    // generate distinct-ish hues using HSL (no hard-coded palette)
    hs.colors = Array.from({length: series}).map((_,i)=>`hsl(${(i*360/series)|0} 85% 60%)`);
  }
  return hs;
}

function pushGraphPoint(w, csvVal){
  const nums = parseCsvNumbers(csvVal);
  const series = Math.max(1, Math.min(10, parseInt(w.series ?? 1, 10)));
  const hs = ensureGraphState(w.id, series);
  const now = performance.now();
  const arr = Array.from({length: series}).map((_,i)=> (nums[i] != null ? nums[i] : NaN));
  hs.points.push({ t: now, v: arr });

  // trim window
  const winMs = Math.max(5, Math.min(300, parseFloat(w.windowSec ?? 30))) * 1000;
  const cutoff = now - winMs;
  while (hs.points.length && hs.points[0].t < cutoff) hs.points.shift();
}

function resizeCanvasToDisplaySize(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(10, Math.floor(rect.width * dpr));
  const h = Math.max(10, Math.floor(rect.height * dpr));
  if (canvas.width !== w || canvas.height !== h){
    canvas.width = w; canvas.height = h;
    return true;
  }
  return false;
}

function drawGraphWidget(w){
  const root = document.querySelector(`.rt-widget[data-id="${w.id}"]`);
  if (!root) return;
  const canvas = root.querySelector('[data-role="graphCanvas"]');
  if (!canvas) return;

  resizeCanvasToDisplaySize(canvas);
  const ctx = canvas.getContext('2d');
  const hs = ensureGraphState(w.id, Math.max(1, Math.min(10, parseInt(w.series ?? 1, 10))));
  const pts = hs.points || [];
  const W = canvas.width, H = canvas.height;

  ctx.clearRect(0,0,W,H);

  // Plot area paddings for axes
  const padL = 36, padR = 10, padT = 10, padB = 24;
  const PW = Math.max(10, W - padL - padR);
  const PH = Math.max(10, H - padT - padB);

  // background
  ctx.fillStyle = 'rgba(0,0,0,0.10)';
  ctx.fillRect(0,0,W,H);

  // frame helper
  const frame = () => {
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.rect(padL, padT, PW, PH);
    ctx.stroke();
  };

  if (pts.length < 2){
    frame();
    return;
  }

  const t0 = pts[0].t;
  const t1 = pts[pts.length-1].t;
  const span = Math.max(1, t1 - t0);

  // y scale
  let yMin = Infinity, yMax = -Infinity;
  if (w.autoScale ?? true){
    pts.forEach(p => p.v.forEach(v => { if (isFinite(v)) { yMin = Math.min(yMin, v); yMax = Math.max(yMax, v); } }));
    if (!isFinite(yMin) || !isFinite(yMax) || yMin === yMax){ yMin = 0; yMax = 1; }
  } else {
    yMin = parseFloat(w.min ?? 0);
    yMax = parseFloat(w.max ?? 100);
    if (!isFinite(yMin) || !isFinite(yMax) || yMin === yMax){ yMin = 0; yMax = 1; }
  }

  const pad = (yMax - yMin) * 0.08;
  yMin -= pad; yMax += pad;

  const xForT = t => padL + ((t - t0) / span) * PW;
  const yForV = v => padT + (PH - ((v - yMin) / (yMax - yMin)) * PH);

  // axes/grid
  ctx.font = '12px Segoe UI, system-ui, sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.75)';
  ctx.strokeStyle = 'rgba(255,255,255,0.20)';
  ctx.lineWidth = 1;

  // Y ticks (5 lines)
  const yTicks = 4;
  for (let i=0;i<=yTicks;i++){
    const yy = padT + (PH * i/yTicks);
    ctx.beginPath(); ctx.moveTo(padL, yy); ctx.lineTo(padL+PW, yy); ctx.stroke();
    const v = yMax - (yMax - yMin) * (i/yTicks);
    const lab = (Math.round(v*100)/100).toString();
    ctx.fillText(lab, 4, yy + 4);
  }

  // X ticks (0, mid, end) seconds
  const xFracs = [0, 0.5, 1];
  xFracs.forEach(frac => {
    const xx = padL + PW*frac;
    ctx.beginPath(); ctx.moveTo(xx, padT); ctx.lineTo(xx, padT+PH); ctx.stroke();
    const sec = (span/1000)*frac;
    const sLab = (Math.round(sec*10)/10) + 's';
    ctx.fillText(sLab, xx - 12, padT + PH + 18);
  });

  // border
  ctx.strokeStyle = 'rgba(255,255,255,0.30)';
  ctx.beginPath();
  ctx.rect(padL, padT, PW, PH);
  ctx.stroke();

  // series lines
  hs.colors.forEach((c, si) => {
    ctx.strokeStyle = c;
    ctx.lineWidth = 2;
    ctx.beginPath();
    let started = false;
    for (let i=0;i<pts.length;i++){
      const v = pts[i].v[si];
      if (!isFinite(v)) continue;
      const x = xForT(pts[i].t);
      const y = yForV(v);
      if (!started){ ctx.moveTo(x,y); started = true; }
      else ctx.lineTo(x,y);
    }
    if (started) ctx.stroke();
  });

  // legend dots colors
  const legend = root.querySelector('[data-role="graphLegend"]');
  if (legend){
    legend.querySelectorAll('.rt-graph-dot').forEach(dot => {
      const i = parseInt(dot.getAttribute('data-s') || '0', 10);
      dot.style.background = hs.colors[i] || 'var(--accent)';
    });
  }
}

function updateGaugeWidget(w, valStr){
  const root = document.querySelector(`.rt-widget[data-id="${w.id}"]`);
  if (!root) return;
  const wrap = root.querySelector('.rt-gauge-wrap');
  if (!wrap) return;
  const fg = wrap.querySelector('.rt-gauge-fg');
  const txt = wrap.querySelector('[data-role="gaugeValue"]');

  const min = parseFloat(w.min ?? 0);
  const max = parseFloat(w.max ?? 100);
  const dec = parseInt(w.decimals ?? 1, 10);
  const units = (w.units || '').trim();

  let v = parseFloat(valStr);
  if (!isFinite(v)) v = min;
  const t = Math.max(0, Math.min(1, (v - min) / (max - min || 1)));

  // path length constant for our arc
  const L = 126;
  if (fg){
    fg.style.strokeDasharray = String(L);
    fg.style.strokeDashoffset = String(L * (1 - t));
    // simple threshold coloring
    const warn = w.warn != null ? parseFloat(w.warn) : null;
    const danger = w.danger != null ? parseFloat(w.danger) : null;
    if (danger != null && isFinite(danger) && v >= danger) fg.style.stroke = 'var(--red)';
    else if (warn != null && isFinite(warn) && v >= warn) fg.style.stroke = 'var(--orange)';
    else fg.style.stroke = 'var(--accent)';
  }
  if (txt){
    txt.textContent = `${v.toFixed(isFinite(dec) ? dec : 1)}${units ? ' ' + units : ''}`;
  }
}


function updateRuntimeWidget(id, val) {
  console.log('[UI] Updating widget:', id, 'to', val);
  const el = $(`.rt-widget[data-id="${id}"]`);
  if (!el || !state.config) {
    console.log('[UI] Widget not found or no config');
    return;
  }
  const w = state.config.widgets.find(x => x.id === id);
  if (!w) {
    console.log('[UI] Widget definition not found');
    return;
  }
  console.log('[UI] Widget type:', w.t);
  switch (w.t) {
    case 'slider': el.querySelector('.rt-slider').value = val; el.querySelector('.rt-slider-val').textContent = val; break;
    case 'toggle': el.querySelector('.rt-toggle').classList.toggle('on', val === '1'); el.querySelector('.rt-toggle').textContent = val === '1' ? '‚úì' : '‚óã'; break;
    case 'led': {
      const ledEl = el.querySelector('.rt-led');
      const wdef = state.config.widgets.find(x => x.id === id);
      const onColor = wdef?.colorOn || '#ff5252';
      const offColor = wdef?.colorOff || '#2a2a3a';
      const model = (wdef?.model || 'dot');
      const on = val === '1';

      // Ensure model class is present (in case config changed live)
      ledEl.className = `rt-led model-${model}${on ? ' on' : ''}`;

      if (model === 'ring'){
        ledEl.style.background = 'transparent';
        ledEl.style.borderColor = on ? onColor : 'rgba(255,255,255,0.18)';
        ledEl.style.boxShadow = on ? `0 0 40px ${onColor}` : 'none';
      } else {
        ledEl.style.borderColor = '';
        ledEl.style.background = on ? onColor : offColor;
        ledEl.style.boxShadow = on ? `0 0 40px ${onColor}` : 'none';
      }

      console.log('[UI] LED', id, 'is now', on ? 'ON' : 'OFF');
      break;
    }
    case 'label': el.querySelector('.rt-label-text').textContent = val; break;
    case 'gauge': updateGaugeWidget(w, val); break;
    case 'graph': {
      // val is comma-separated numbers: "23.4,2.1"
      pushGraphPoint(w, val);
      const last = el.querySelector('[data-role="graphLast"]');
      if (last) last.textContent = val;
      drawGraphWidget(w);
      break;
    }
  }
}

document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
