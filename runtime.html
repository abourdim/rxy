<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>micro:bit Dynamic UI Runtime (BLE)</title>
  <style>
    body { font-family: system-ui, sans-serif; margin:16px; }
    #top { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    button, input { padding:10px 12px; }
    #ui { margin-top:14px; display:grid; gap:10px; }
    .card { border:1px solid #ddd; border-radius:14px; padding:12px; }
    .hdr { display:flex; justify-content:space-between; gap:10px; align-items:center; }
    .title { font-weight:700; }
    .small { color:#666; font-size:.95em; }
    #log { white-space:pre-wrap; border:1px solid #eee; padding:10px; height:210px; overflow:auto; margin-top:12px; }
    .pill { font-size:.85em; background:#f3f3f3; padding: 2px 8px; border-radius:999px; }
  </style>
</head>
<body>
  <div id="top">
    <button id="connect">Connect</button>
    <button id="disconnect" disabled>Disconnect</button>
    <button id="offline">Offline preview</button>
    <span id="status" class="small">Not connected</span>
    <span class="pill" id="mode">mode: idle</span>
  </div>

  <div id="ui"></div>
  <div id="log"></div>

  <script src="./ble_microbit.js"></script>
  <script>
    // -----------------------
    // UI log + status hooks
    // -----------------------
    function uiLog(s) {
      const el = document.getElementById('log');
      el.textContent += s + "\n";
      el.scrollTop = el.scrollHeight;
    }
    function uiStatus(s) { document.getElementById('status').textContent = s; }
    function setMode(s) { document.getElementById('mode').textContent = "mode: " + s; }

    window.mbOnLog = (text, kind) => {
      const prefix = (kind === "error") ? "❌ " :
                     (kind === "success") ? "✅ " :
                     (kind === "tx") ? "TX " :
                     (kind === "rx") ? "RX " : "";
      uiLog(prefix + text);
    };
    window.mbOnConnectionChange = (c) => {
      document.getElementById('connect').disabled = c;
      document.getElementById('disconnect').disabled = !c;
      uiStatus(c ? ("Connected (" + (window.mbProfile ? mbProfile() : "?") + ")") : "Not connected");
    };

    // -----------------------
    // Protocol parser
    // Supports:
    //  A) Framed JSON: CFGBEGIN <len> + <raw json chars> + (optional) CFGEND line
    //  B) Legacy: CFG <base64(json)>
    //  C) Chunked base64:
    //      CFGB64BEGIN <n>
    //      CFGB64 <i> <data>
    //      CFGB64END
    // -----------------------
    let lineBuf = "";            // for line-based processing outside framed payload
    let mode = "idle";           // idle | cfg_json | cfg_b64
    let cfgExpectedLen = 0;
    let cfgJsonBuf = "";
    let ignoreNextCfgEnd = false;

    let b64Chunks = [];
    let b64Expected = 0;

    function b64ToJson(b64){
      const bin = atob(b64);
      const bytes = Uint8Array.from(bin, c => c.charCodeAt(0));
      const txt = new TextDecoder().decode(bytes);
      return JSON.parse(txt);
    }

    function handleLine(line) {
      if (!line) return;

      // Ignore CFGEND if we already consumed payload by length
      if (ignoreNextCfgEnd && (line === "CFGEND" || line.startsWith("CFGEND"))) {
        ignoreNextCfgEnd = false;
        return;
      }

      // Legacy single-line base64
      if (line.startsWith("CFG ")) {
        try {
          setMode("parsing cfg (base64)");
          const cfg = b64ToJson(line.slice(4).trim());
          renderUI(cfg);
          uiStatus("UI loaded: " + (cfg.title || "micro:bit"));
        } catch (e) {
          uiLog("❌ JSON.parse failed (base64): " + e);
        } finally {
          setMode("idle");
        }
        return;
      }

      // Chunked base64
      if (line.startsWith("CFGB64BEGIN")) {
        const parts = line.split(" ");
        b64Expected = (parts.length >= 2) ? parseInt(parts[1]) : 0;
        b64Chunks = [];
        mode = "cfg_b64";
        setMode("receiving cfg (chunked base64)");
        return;
      }
      if (mode === "cfg_b64") {
        if (line.startsWith("CFGB64END")) {
          try {
            const b64 = b64Chunks.join("");
            const cfg = b64ToJson(b64);
            renderUI(cfg);
            uiStatus("UI loaded: " + (cfg.title || "micro:bit"));
          } catch (e) {
            uiLog("❌ JSON.parse failed (chunked base64): " + e);
          } finally {
            mode = "idle";
            setMode("idle");
          }
          return;
        }
        if (line.startsWith("CFGB64 ")) {
          // CFGB64 <i> <data>
          const p = line.split(" ");
          if (p.length >= 3) {
            b64Chunks.push(p.slice(2).join(" "));
          }
          return;
        }
      }

      // Framed JSON start (line-based header)
      if (line.startsWith("CFGBEGIN")) {
        const parts = line.split(" ");
        cfgExpectedLen = (parts.length >= 2) ? parseInt(parts[1]) : 0;
        cfgJsonBuf = "";
        mode = "cfg_json";
        ignoreNextCfgEnd = true;
        setMode("receiving cfg (framed json)");
        return;
      }

      // Normal updates
      if (line.startsWith("UPD ")) {
        const parts = line.split(" ");
        const id = parts[1];
        const value = parts.slice(2).join(" ");
        applyUpdate(id, value);
        return;
      }

      // You can add more commands if needed (STATE/ERR etc).
    }

    // Receive raw chunks from BLE helper
    window.mbOnChunk = (chunk) => {
      // If we're currently receiving framed JSON payload, consume exact length as a raw stream.
      if (mode === "cfg_json") {
        let remaining = cfgExpectedLen - cfgJsonBuf.length;
        if (remaining > 0) {
          const take = chunk.length < remaining ? chunk.length : remaining;
          cfgJsonBuf += chunk.slice(0, take);
          chunk = chunk.slice(take);
        }

        if (cfgJsonBuf.length >= cfgExpectedLen) {
          // Payload complete (exact length). Parse it.
          try {
            const cfg = JSON.parse(cfgJsonBuf);
            renderUI(cfg);
            uiStatus("UI loaded: " + (cfg.title || "micro:bit"));
          } catch (e) {
            uiLog("⚠ Length mismatch (framed JSON): expected " + cfgExpectedLen + ", got " + cfgJsonBuf.length);
            uiLog("❌ JSON.parse failed (framed): " + e);
            uiLog(cfgJsonBuf);
          } finally {
            mode = "idle";
            setMode("idle");
          }
        }

        // Any leftover bytes in this chunk after consuming JSON are handled below as lines.
        // (often contains newline + CFGEND + UPD...)
      }

      // Line-based processing for everything else
      if (chunk && chunk.length) {
        lineBuf += chunk;

        while (true) {
          const idx = lineBuf.indexOf("\n");
          if (idx < 0) break;
          let line = lineBuf.slice(0, idx);
          lineBuf = lineBuf.slice(idx + 1);

          if (line.endsWith("\r")) line = line.slice(0, -1);

          // Log incoming lines (nice debugging)
          if (line.length) uiLog("⬅ " + line);

          handleLine(line);
        }
      }
    };

    async function connect() {
      const ok = await mbConnect();
      if (ok) {
        setMode("idle");
        await mbSendLine("GETCFG");
      }
    }

    document.getElementById('connect').onclick = () => connect();
    document.getElementById('disconnect').onclick = () => mbDisconnect();

    // Offline preview: load last config saved by Builder (localStorage) or use a built-in sample
    document.getElementById('offline').onclick = () => {
      const saved = localStorage.getItem("mb_ui_last_json");
      let cfg = null;
      try {
        if (saved) cfg = JSON.parse(saved);
      } catch (e) {}
      if (!cfg) cfg = SAMPLE_CFG;
      renderUI(cfg);
      uiStatus("Offline preview: " + (cfg.title || "sample"));
    };

    // -----------------------
    // Dynamic UI renderer (supports extra widgets)
    // -----------------------
    function renderUI(cfg){
      const ui = document.getElementById('ui');
      ui.innerHTML = "";
      ui.style.gridTemplateColumns = `repeat(${cfg.grid?.w ?? 12}, 1fr)`;

      const localState = {};

      for(const w of (cfg.widgets || [])){
        const card = document.createElement('div');
        card.className = "card";
        card.dataset.id = w.id;
        card.style.gridColumn = `${(w.x ?? 0)+1} / span ${(w.w ?? 4)}`;
        card.style.gridRow = `${(w.y ?? 0)+1} / span ${(w.h ?? 2)}`;

        const hdr = document.createElement('div');
        hdr.className = "hdr";
        const t = document.createElement('div');
        t.className = "title";
        t.textContent = w.label ?? w.id;
        const val = document.createElement('div');
        val.className = "small";
        val.dataset.val = "1";
        val.textContent = "";
        hdr.appendChild(t);
        hdr.appendChild(val);
        card.appendChild(hdr);

        // Button
        if(w.t === "btn"){
          const b = document.createElement('button');
          b.textContent = w.label ?? "Button";
          b.onpointerdown = () => mbSendLine(`SET ${w.id} 1`);
          b.onpointerup   = () => mbSendLine(`SET ${w.id} 0`);
          card.appendChild(b);
        }
        // Toggle
        else if(w.t === "tgl"){
          localState[w.id] = w.value ?? 0;
          const b = document.createElement('button');
          b.textContent = localState[w.id] ? "ON" : "OFF";
          val.textContent = String(localState[w.id]);
          b.onclick = () => {
            localState[w.id] = localState[w.id] ? 0 : 1;
            b.textContent = localState[w.id] ? "ON" : "OFF";
            val.textContent = String(localState[w.id]);
            mbSendLine(`SET ${w.id} ${localState[w.id]}`);
          };
          card.appendChild(b);
        }
        // Slider
        else if(w.t === "sld"){
          const r = document.createElement('input');
          r.type = "range";
          r.min = w.min ?? 0;
          r.max = w.max ?? 100;
          r.step = w.step ?? 1;
          r.value = w.value ?? 0;
          val.textContent = r.value;
          r.oninput = () => val.textContent = r.value;
          r.onchange = () => mbSendLine(`SET ${w.id} ${r.value}`);
          card.appendChild(r);
        }
        // Gauge (read-only range)
        else if(w.t === "g" || w.t === "lvl"){
          const r = document.createElement('input');
          r.type = "range";
          r.min = w.min ?? 0;
          r.max = w.max ?? 100;
          r.step = 1;
          r.value = w.value ?? 0;
          r.disabled = true;
          val.textContent = r.value;
          card.appendChild(r);
        }
        // Text (read-only)
        else if(w.t === "txt"){
          const p = document.createElement('div');
          p.className = "small";
          p.dataset.text = "1";
          p.textContent = String(w.value ?? "");
          card.appendChild(p);
        }
        // Joystick (touch/pointer)
        else if(w.t === "joy"){
          const box = document.createElement('div');
          box.style.height = "160px";
          box.style.border = "1px solid #eee";
          box.style.borderRadius = "12px";
          box.style.position = "relative";
          box.style.touchAction = "none";
          const dot = document.createElement('div');
          dot.style.width = "18px"; dot.style.height = "18px";
          dot.style.borderRadius = "999px";
          dot.style.background = "#888";
          dot.style.position = "absolute";
          dot.style.left = "50%"; dot.style.top = "50%";
          dot.style.transform = "translate(-50%,-50%)";
          box.appendChild(dot);
          val.textContent = "0,0";

          const dead = w.deadzone ?? 5;
          function sendJoy(nx, ny){
            // nx,ny in [-100..100]
            if (Math.abs(nx) < dead) nx = 0;
            if (Math.abs(ny) < dead) ny = 0;
            val.textContent = nx + "," + ny;
            mbSendLine(`SET ${w.id} ${nx},${ny}`);
          }
          function moveDot(nx, ny){
            dot.style.left = (50 + nx/2) + "%";
            dot.style.top  = (50 - ny/2) + "%";
          }

          let active = false;
          box.onpointerdown = (e) => { active = true; box.setPointerCapture(e.pointerId); };
          box.onpointerup = (e) => { active = false; moveDot(0,0); sendJoy(0,0); };
          box.onpointermove = (e) => {
            if (!active) return;
            const r = box.getBoundingClientRect();
            const cx = r.left + r.width/2;
            const cy = r.top + r.height/2;
            let nx = Math.round(((e.clientX - cx) / (r.width/2)) * 100);
            let ny = Math.round((-(e.clientY - cy) / (r.height/2)) * 100);
            if (nx < -100) nx = -100; if (nx > 100) nx = 100;
            if (ny < -100) ny = -100; if (ny > 100) ny = 100;
            moveDot(nx, ny);
            sendJoy(nx, ny);
          };

          card.appendChild(box);
        }
        // LED 5x5 grid
        else if(w.t === "led"){
          const grid = document.createElement('div');
          grid.style.display = "grid";
          grid.style.gridTemplateColumns = "repeat(5, 1fr)";
          grid.style.gap = "6px";
          const bits0 = String(w.bits ?? "0000000000000000000000000");
          let bits = bits0.padEnd(25, "0").slice(0,25).split("");

          function redraw(){
            grid.innerHTML = "";
            for (let i=0;i<25;i++){
              const cell = document.createElement('div');
              cell.style.height = "22px";
              cell.style.borderRadius = "6px";
              cell.style.border = "1px solid #eee";
              cell.style.background = bits[i] === "1" ? "#444" : "#fff";
              cell.style.cursor = "pointer";
              cell.onclick = () => {
                bits[i] = (bits[i] === "1") ? "0" : "1";
                redraw();
                mbSendLine(`SET ${w.id} ${bits.join("")}`);
              };
              grid.appendChild(cell);
            }
          }
          redraw();
          val.textContent = "tap cells";
          card.appendChild(grid);
        }
        // Sound widget (simple tone)
        else if(w.t === "snd"){
          const row = document.createElement('div');
          row.style.display="flex"; row.style.gap="10px"; row.style.alignItems="center";
          const freq = document.createElement('input');
          freq.type="number"; freq.value = w.freq ?? 440; freq.min=50; freq.max=5000;
          freq.style.width="120px";
          const ms = document.createElement('input');
          ms.type="number"; ms.value = w.ms ?? 150; ms.min=20; ms.max=2000;
          ms.style.width="120px";
          const play = document.createElement('button');
          play.textContent="Play";
          play.onclick = () => mbSendLine(`SET ${w.id} ${freq.value},${ms.value}`);
          row.appendChild(freq); row.appendChild(ms); row.appendChild(play);
          val.textContent = "Hz,ms";
          card.appendChild(row);
        }

        ui.appendChild(card);
      }

      // Save for offline preview
      try { localStorage.setItem("mb_ui_last_json", JSON.stringify(cfg)); } catch (e) {}
    }

    function applyUpdate(id, value){
      const card = document.querySelector(`.card[data-id="${id}"]`);
      if(!card) return;

      const valEl = card.querySelector('[data-val="1"]');
      if(valEl) valEl.textContent = value;

      const range = card.querySelector('input[type="range"]');
      if(range && range.disabled) range.value = value;

      const text = card.querySelector('[data-text="1"]');
      if(text) text.textContent = value;
    }

    // Built-in sample for offline preview
    const SAMPLE_CFG = {
      v: 1,
      title: "Offline Sample",
      grid: { w: 12, h: 8 },
      widgets: [
        {id:"btn1",t:"btn",x:0,y:0,w:4,h:2,label:"Button"},
        {id:"tgl1",t:"tgl",x:4,y:0,w:4,h:2,label:"Toggle",value:0},
        {id:"sld1",t:"sld",x:0,y:2,w:12,h:2,label:"Slider",min:0,max:100,step:1,value:50},
        {id:"g1",t:"g",x:0,y:4,w:9,h:2,label:"Temp Gauge",min:0,max:100,value:0},
        {id:"lvl1",t:"lvl",x:9,y:4,w:3,h:4,label:"Light",min:0,max:255,value:0},
        {id:"txt1",t:"txt",x:0,y:6,w:12,h:2,label:"Status",value:"Hello"},
        {id:"joy1",t:"joy",x:6,y:0,w:6,h:6,label:"Joystick",deadzone:5},
        {id:"led1",t:"led",x:0,y:0,w:6,h:6,label:"LED 5x5",bits:"0000000000000000000000000"},
        {id:"snd1",t:"snd",x:6,y:6,w:6,h:3,label:"Sound",freq:440,ms:150}
      ]
    };
  </script>
</body>
</html>
